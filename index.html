<!DOCTYPE html>

<!--
MIRRORFLOW INTERNAL (not user-facing)
Build: UI-lock v1i (placeholders + preview toggle + chatflow reorder)
Purpose: lock the tri-layout UI/Phone placement/Utilities hub and keep wiring stable before deeper engine work.

INTERNAL CHANGELOG
- UI-lock v1j: Pass 2 — CX tab routing + render gates (Writer: Agent audit chips only (Customer signals in Experience); UK/US + Jargon render only in their tabs; Experience gated).
- UI-lock v1j: Phone bars now use solid, theme-tinted surfaces (no black bars; clear/frosted affects panels only).
- UI-lock v1d: Fixed Phone™ scaling on window resize (updatePhoneScale now wired correctly).
- UI-lock v1d: Anchored .phone-wrap (position + scaled box) to prevent clipping/cropping.
- UI-lock v1d: Status time now renders immediately on load.
- UI-lock v1d: Customer input now triggers render for live Insights signals.
- UI-lock v1: Insights panel uses flex column layout on all breakpoints; Utilities hub pinned to bottom.
- UI-lock v1: Removed Focus modes placeholder card from Insights (header buttons remain).
- UI-lock v1: Phone panel body now flex:1 to guarantee vertical centring at all viewport heights.
- UI-lock v1: Persistence scope reduced to UI settings only (no draft/transcript restore). Editors always start blank.
- UI-lock v1: When Preview is OFF, show typing indicator instead of a live preview bubble in transcript.
Notes for future phases:
- Keep Phase-F scheduler/recompute pipeline untouched unless explicitly required.
- Add editor tool wiring incrementally (format, highlights, spacing) behind small, isolated functions.
- ChatFlow (drag/reorder) should be implemented as a thin layer over state.messages with stable IDs.
-->
<html lang="en-GB">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>MirrorFlow 2.0 — P0→P1 (Locked Tri + Classic Dock v2 + Canon Phone Fix + Particles)</title>
<style>
    :root{
      /* Layout tokens (LOCKED) */
      --app-pad: 14px;
      --gap: 12px;
      --radius: 18px;
      --radius-sm: 12px;
      --panel-header-h: 46px;
      --ring: 0 0 0 3px rgba(122, 180, 255, .22);

      /* Canon Phone™ tokens */
      --phone-ar-w: 9;
      --phone-ar-h: 19.5;
      --safe-top: 44px;
      --safe-bottom: 34px;
      --phone-header-h: 58px;
      --phone-input-h: 62px;
      --phone-max-h: 900px;

      /* Phone text scale */
      --phone-font-scale: 1;

      /* Typography */
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

      /* Theme vars (SOL/LUNAR will rewrite these) */
      --bg0: #070A12;
      --bg1: #0B1020;
      --panelA: rgba(255,255,255,.08);
      --panelB: rgba(255,255,255,.04);
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --faint: rgba(255,255,255,.42);
      --accent: #7AB4FF;
      --accent2:#B98BFF;
      --accentRGB: 122,180,255;
      --accent2RGB: 185,139,255;
      --shadow: rgba(0,0,0,.35);
      /* BG Builder vars (Lite) */
      --bg-c1: #050816;
      --bg-c2: #120a2a;
      --bg-c3: #3b82f6;
      --bg-c4: #8b5cf6;

      --poly-op: 0.92;
      --pat-op: 0.86;
      --vignette: 0.38;
      --pat-scale: 1;
      --pat-weight: 1;
      --pat-density: 1;

      --mag-den: 1;
      --mag-spd: 1;
      --mag-amp: 1;
      --bloom-int: 1;
      --tiles-int: 1;
      --orbs-int: 1;
      --stars-int: 1;


      /* Bubble colours */
      --bub-agent: rgba(122,180,255,.20);
      --bub-agent-stroke: rgba(122,180,255,.35);
      --bub-cust: rgba(255,255,255,.10);
      --bub-cust-stroke: rgba(255,255,255,.12);

      /* Phone bar tints (solid, theme-aware; phone remains opaque) */
      --phoneBarA: color-mix(in srgb, var(--bg1) 78%, var(--accent) 22%);
      --phoneBarB: color-mix(in srgb, var(--bg0) 86%, var(--accent2) 14%);
      --phoneBarStroke: color-mix(in srgb, var(--stroke) 70%, var(--accent) 30%);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
        body{
      margin:0;
      font-family: var(--font);
      color: var(--text);

      /* BG Builder: base sky + subtle glow (pattern + stars handled in layers below) */
      background:
        radial-gradient(1100px 820px at 18% 12%, color-mix(in srgb, var(--bg-c4) 22%, transparent) 0%, transparent 58%),
        radial-gradient(900px 720px at 82% 18%, color-mix(in srgb, var(--bg-c3) 18%, transparent) 0%, transparent 60%),
        radial-gradient(1000px 900px at 50% 110%, rgba(255,255,255,.04), transparent 62%),
        linear-gradient(180deg, var(--bg-c1), var(--bg-c2));
      overflow:hidden;
    }
    /* SOL lift: brighten the sky with a soft ombré overlay (Lunar stays untouched) */
    @media (prefers-reduced-motion: no-preference){
      body[data-tmode="sol"]::after{
        content:"";
        position:fixed;
        inset:0;
        pointer-events:none;
        background:
          radial-gradient(900px 640px at 50% -12%, rgba(255,255,255,.14), transparent 62%),
          radial-gradient(820px 620px at 12% 18%, rgba(255,205,140,.12), transparent 60%),
          radial-gradient(900px 700px at 88% 22%, rgba(180,220,255,.10), transparent 60%);
        mix-blend-mode: screen;
        opacity: .92;
      }
    }


    /* Subtle blur drift (kept) */

    .bg-fx{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
    }
    #bgParticles{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      opacity: .92;
    }
    .mf-pattern{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      opacity: var(--pat-op);
      mix-blend-mode: overlay;
      filter: saturate(1.08);
    }
    body[data-pattern="dots"] .mf-pattern{
      background-image:
        radial-gradient(circle at 1px 1px, rgba(255,255,255,.14) 0 1px, transparent 1.2px);
      background-size: calc(28px / max(0.55, var(--pat-scale))) calc(28px / max(0.55, var(--pat-scale)));
    }
    body[data-pattern="lines"] .mf-pattern{
      background-image:
        repeating-linear-gradient(
          135deg,
          rgba(255,255,255, calc(.10 * var(--pat-weight))) 0px,
          rgba(255,255,255, calc(.10 * var(--pat-weight))) 1px,
          transparent 1px,
          transparent calc(18px / max(0.55, var(--pat-scale)))
        );
      background-size: auto;
    }
    .mf-vignette{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      background:
        radial-gradient(120% 120% at 50% 40%, rgba(0,0,0,0) 0%, rgba(0,0,0, var(--vignette)) 72%, rgba(0,0,0, calc(var(--vignette) + .12)) 100%);
    }

    /* When BG mode is stars, disable the old blur drift overlay (stars already provide motion) */
    body[data-bgmode="stars"] .bg-fx::before{ content:none !important; display:none !important; }

    body[data-motion="on"] .bg-fx::before{
      content:"";
      position:fixed; inset:-40%;
      background:
        radial-gradient(circle at 30% 40%, rgba(122,180,255,.10), transparent 35%),
        radial-gradient(circle at 70% 60%, rgba(185,139,255,.09), transparent 38%),
        radial-gradient(circle at 50% 20%, rgba(255,255,255,.05), transparent 36%);
      filter: blur(18px);
      animation: drift 16s ease-in-out infinite alternate;
      pointer-events:none;
      z-index:0;
    }
    @keyframes drift{
      from{ transform: translate3d(-2%, -1%, 0) scale(1.02); opacity:.78; }
      to  { transform: translate3d( 2%,  1%, 0) scale(1.06); opacity:.95; }
    }
    
    /* Utilities hub at bottom of Insights */
    .panel[data-panel="insights"] .panel-body{
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }
    .panel[data-panel="insights"] .cards{ flex: 1 1 auto; min-height:0; overflow:auto; padding-right: 2px; }

    .utilitiesHub{
      margin-top: 10px;
      position: relative;
      bottom: auto;
      padding: 10px 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .utilitiesTitle{
      font-size: 11px;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: rgba(255,255,255,.56);
      margin: 2px 2px 8px;
    }
    .utilitiesHub .utilities-bar{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
    }
    /* Theme name is visible on hover via swatch title; keep label hidden */
    #themeLabel{ display:none !important; }

    .utilitiesHub .iconbtn{
  
  width: 24px; height: 24px;
  border-radius: 9px;
  border: 1px solid rgba(148,163,184,.22);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.16));
  display: grid; place-items: center;
  cursor: pointer;
  transition: transform .15s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease, color .2s ease;
  color: rgba(245,250,255,.94);
}
.iconbtn svg{ opacity:.95; filter: drop-shadow(0 6px 10px rgba(0,0,0,.35)); }
.iconbtn:hover{
  transform: translateY(-1px);
  border-color: rgba(148,163,184,.36);
  background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(0,0,0,.14));
  box-shadow: 0 12px 26px rgba(0,0,0,.38), 0 0 0 1px rgba(255,255,255,.06) inset;
}
.iconbtn:active{ transform: translateY(0px) scale(.98); }

    
/* utilities: Anim icon (matches dice) */
.iconbtn{ color: rgba(255,255,255,.92); }
#diceBtn{ color: rgba(255,255,255,.94); }
#fxBtn{ color: rgba(255,255,255,.94); }
#fxBtn[data-active="true"]{ border-color: rgba(122,180,255,.75); background: rgba(122,180,255,.14); box-shadow: 0 0 0 4px rgba(122,180,255,.10); }
#fxBtn::after{
  content:"";
  position:absolute;
  width:6px; height:6px;
  border-radius:999px;
  right:4px; bottom:4px;
  background: rgba(122,180,255,.92);
  opacity:0;
  box-shadow:0 0 0 3px rgba(122,180,255,.16);
}
#fxBtn[data-active="true"]::after{ opacity:1; }
/* --- Utilities fidget / widget feedback --- */
@keyframes mfDiceWobble{
  0%{ transform: rotate(0deg) scale(1); }
  25%{ transform: rotate(8deg) scale(1.05); }
  50%{ transform: rotate(-8deg) scale(1.05); }
  75%{ transform: rotate(4deg) scale(1.03); }
  100%{ transform: rotate(0deg) scale(1); }
}
@keyframes mfSoftPulse{
  0%{ box-shadow: 0 0 0 rgba(255,255,255,0); }
  50%{ box-shadow: 0 0 12px rgba(255,255,255,.25); }
  100%{ box-shadow: 0 0 0 rgba(255,255,255,0); }
}
.iconbtn, .modeswitch button{ position: relative; }
.mf-fidget-wobble{ animation: mfDiceWobble 420ms ease; }
.mf-fidget-pulse{ animation: mfSoftPulse 360ms ease; }


    .utilitiesHub .swatch{ width: 12px; height:  12px; }
    .utilitiesHub .textsize{
      margin-top: 10px;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap: 8px;
      flex-wrap:wrap;
      width: 100%;
      padding: 6px 0 0;
    }
    .utilitiesHub .textsize .label{
      font-size: 10px;
      opacity: .75;
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.10);
    }

@media (prefers-reduced-motion: reduce){
  body[data-motion="on"] .bg-fx::before{ animation:none; }
  .mf-fidget-wobble, .mf-fidget-pulse{ animation:none !important; }
}

/* Canvas particles */
    #bgParticles{
      position:fixed; inset:0;
      width:100%; height:100%;
      pointer-events:none;
      z-index:0;
      opacity: .85;
    }
    body[data-motion="off"] #bgParticles{ opacity: 0; }

    .app{ position:relative; height:100%; padding: var(--app-pad); z-index:1; }
    .tri{
      height:100%;
      display:grid;
      grid-template-columns: 1.05fr 1.0fr 0.95fr;
      gap: var(--gap);
      align-items: stretch;
    }

    .panel{
      background: linear-gradient(180deg, var(--panelA), var(--panelB));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width: 0;
      box-shadow: 0 14px 50px var(--shadow);
      backdrop-filter: blur(var(--panelBlur));
    }

    .panel-header{
      height: var(--panel-header-h);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panelHeaderA), var(--panelHeaderB));
    }

    .panel-title{
      display:flex; align-items:center; gap:10px;
      font-weight: 700;
      letter-spacing:.2px;
      font-size: 13.5px;
      white-space:nowrap;
    }
    .dot{
      width:8px; height:8px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(122,180,255,.15);
      flex: 0 0 auto;
    }

    .chips{ display:flex; align-items:center; gap:8px; min-width:0; }
    .chip{
      border: 1px solid var(--stroke2);
      background: rgba(0,0,0,.16);
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
    }

.chip--inline{
  margin-left: 8px;
  padding: 4px 10px;
  font-size: 12px;
  opacity: 0.95;
}
    .chip strong{ color: var(--text); font-weight:700; }

    .chipbtn{ cursor:pointer; }
    .chipbtn[aria-pressed="false"]{ opacity:.72; }
    .chipbtn:focus-visible{ outline:none; box-shadow: var(--ring); }

    /* ChatFlow: draggable transcript bubbles */
    .bubble.draggable{ cursor: grab; }
    .bubble.draggable:active{ cursor: grabbing; }
    .bubble.dragging{ opacity: .38; filter: saturate(.9); }
    .bubble.drop-target{ outline: 2px dashed rgba(122,180,255,.35); outline-offset: 2px; }

    /* Placeholder sample bubbles */
    .bubble.placeholder{
      opacity: .62;
      border-style: dashed;
      border-color: rgba(255,255,255,.22);
      background: rgba(0,0,0,.16);
    }

    .btn{
      border: 1px solid var(--stroke2);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 10px;
      font-size: 12.5px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select:none;
    }
    .btn:hover{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
    }
    .btn:active{ transform: translateY(1px); }
    .btn:focus-visible{ outline:none; box-shadow: var(--ring); }

    .panel-body{ padding: 12px; overflow:auto; min-height:0; }

    /* Draft panel */
    .stack{ display:flex; flex-direction:column; gap: 14px; }

/* Focus Editor (Notepad Mode) — hides customer block and expands agent draft */
body[data-focus="editor"] .customerBlock{
  opacity: 0;
  max-height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
  transition: opacity .18s ease, max-height .18s ease;
}
body[data-focus="editor"] .draftToolbarBlock{
  margin-top: 0;
}
body[data-focus="editor"] .agentBlock{
  flex: 1;
  display: flex;
  flex-direction: column;
}
body[data-focus="editor"] .agentBlock .editor-box{
  flex: 1;
}
body[data-focus="editor"] #agentDraft{
  flex: 1;
  min-height: 420px;
}

/* === MF:UI ORDER LOCK (MirrorFlow Editor stack) ===========================
   Hard-lock vertical order: 1 customer, 2 toolbar, 3 agent, 4 utilities.
   Even if future code accidentally reorders nodes, flex `order` preserves rhythm.
======================================================================= */

.stack > .customerBlock{ order: 10; }
.stack > .draftToolbarBlock{ order: 20; }
.stack > .agentBlock{ order: 30; }
.stack > .utilitiesHub{ order: 40; }

/* Kill any orphan/empty rows that may appear between blocks */
.char-count-row:empty,
.phone-text-size-row:empty,
.toolbar:empty,
.dock:empty,
.dock-left:empty,
.dock-right:empty{
  display:none !important;
  margin:0 !important;
  padding:0 !important;
}

/* If a legacy dock ever returns, hide it (utilities owns these controls now) */
.dock{ display:none !important; }

/* Utilities: two-row bar (row1: SOL/LUNAR + dice/fx; row2: how/dicts/checker + swatches) */
.utilities-bar{ display:flex; flex-direction:column; gap:8px; }
.utilities-row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
.utilities-row.row1{ justify-content:flex-start; }
.utilities-row.row2{ justify-content:flex-start; }
.checker-pill{ margin-left: 0; }

    label{
      font-size: 12px;
      color: var(--muted);
      display:block;
      margin: 0 0 6px 2px;
      user-select:none;
    }

    .editor-box{
      position:relative;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(120% 150% at 50% -20%, rgba(255,255,255,.08), transparent 45%),
        linear-gradient(180deg, rgba(0,0,0,.14), rgba(0,0,0,.22));
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.10),
        0 10px 30px rgba(0,0,0,.22);
      overflow:hidden;
    }

/* Solid focus borders for Customer/Agent boxes (Classic-style cue) */
.editor-box.customer-box:focus-within{
  border-color: var(--accent2);
  box-shadow: 0 0 0 2px rgba(0,0,0,.28);
}
.editor-box.agent-box:focus-within{
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(0,0,0,.28);
}

    textarea{
      width:100%;
      border: 0;
      background: transparent;
      color: var(--text);
      padding: 12px 46px 12px 12px;
      font-family: var(--font);
      font-size: 14px;
      line-height: 1.45;
      resize: vertical;
      outline:none;
      min-height: 64px;
    }

    .embedded-send{
      position:absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 34px; height: 34px;
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.20);
      display:grid; place-items:center;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select:none;
    }
    .embedded-send:hover{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.26); }
    .embedded-send:active{ transform: translateY(calc(-50% + 1px)); }
    .embedded-send:focus-visible{ outline:none; box-shadow: var(--ring); }

    .hint{
      font-size: 12px;
      color: var(--faint);
      margin: 6px 2px 0;
      line-height:1.35;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.78);
    }

    /* Toolbar: ONE ROW (scroll) so it doesn't eat vertical space */
    .classic-toolbar{
      position:relative;
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      padding: 8px 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.18) transparent;
    }
    .classic-toolbar::-webkit-scrollbar{ height: 10px; }
    .classic-toolbar::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.12);
      border-radius:999px;
      border: 3px solid transparent;
      background-clip: content-box;
    }
    .classic-toolbar::-webkit-scrollbar-track{ background: transparent; }

    .classic-toolbar::before,
    .classic-toolbar::after{
      content:"";
      position: relative;
      top: 0;
      width: 16px;
      height: 100%;
      pointer-events:none;
      flex: 0 0 16px;
    }
    .classic-toolbar::before{
      left: 0;
      background: linear-gradient(90deg, rgba(0,0,0,.20), transparent);
    }
    .classic-toolbar::after{
      right: 0;
      background: linear-gradient(270deg, rgba(0,0,0,.20), transparent);
    }

    .pillbtn{
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.16);
      color: rgba(255,255,255,.86);
      padding: 5px 7px;
      border-radius: 999px;
      font-size: 10px;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
      flex: 0 0 auto;
    }
    .pillbtn:hover{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.26); }
    .pillbtn:active{ transform: translateY(1px); }
    .pillbtn:focus-visible{ outline:none; box-shadow: var(--ring); }
    .pillbtn[data-active="true"]{ border-color: rgba(122,180,255,.40); background: rgba(122,180,255,.14); }
    .pillbtn.orange{ border-color: rgba(255,165,64,.35); background: rgba(255,165,64,.12); }
    .pillbtn .caret{ opacity:.85; font-size: 10px; }
    .pillbtn.danger{ border-color: rgba(255,120,120,.35); background: rgba(255,120,120,.10); }
    .pillbtn.danger:hover{ background: rgba(255,120,120,.14); }

    /* Dock */
    .dock{
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
    }
    .dock-left, .dock-mid, .dock-right{
      display:flex; align-items:center; gap: 8px; flex-wrap:wrap;
      min-width: 0;
    }
    .mini{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.82);
      padding: 6px 9px;
      border-radius: 999px;
      font-size: 12px;
      display:inline-flex;
      gap: 8px;
      align-items:center;
      user-select:none;
      white-space:nowrap;
    }
    .mini b{ font-weight:800; }
    .mini.badge{
      border-color: rgba(122,180,255,.28);
      background: rgba(122,180,255,.10);
    }
    .mini.pink{
      border-color: rgba(255,116,212,.28);
      background: rgba(255,116,212,.10);
    }

    /* Mode switch */
    
.modeswitch{
  display:flex;
  gap:3px;
  padding:3px;
  border-radius: 999px;
  border:1px solid rgba(255,255,255,.14);
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.10));
  box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
}
.modeswitch button{
  padding: 0;
  border-radius: 999px;
  width: 28px; height: 28px;
  display: grid; place-items: center;
  border:1px solid transparent;
  background: transparent;
  color: rgba(255,255,255,.78);
  font-weight: 800;
  letter-spacing: .08em;
  font-size: 0;
  line-height: 1;
  cursor:pointer;
  transition: background .15s ease, border-color .15s ease, color .15s ease, transform .12s ease;
}
.modeswitch button:hover{ transform: translateY(-1px); color: rgba(255,255,255,.92); }
.modeswitch button[data-active="true"]{
  color:#fff;
  border-color: rgba(255,255,255,.22);
  box-shadow: 0 10px 22px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.12);
}

.sr-only{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
body[data-tmode="sol"] .modeswitch button[data-active="true"]{
  background: radial-gradient(120% 140% at 20% 20%, rgba(255,182,72,.30), rgba(255,125,35,.14));
}
body[data-tmode="lunar"] .modeswitch button[data-active="true"]{
  background: radial-gradient(120% 140% at 20% 20%, rgba(160,140,255,.30), rgba(96,212,255,.14));
}
.modeswitch button:focus-visible{ outline:2px solid rgba(255,255,255,.25); outline-offset:2px; }


    /* Swatches */
    .swatches{
      display:flex;
      gap: 6px;
      align-items:center;
      padding: 3px 4px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .swatches.pulse{
      animation: skyPulse .55s ease;
    }
    @keyframes skyPulse{
      0%{ box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 0 0 0 rgba(255,165,64,.00); }
      40%{ box-shadow: inset 0 1px 0 rgba(255,255,255,.10), 0 0 0 6px rgba(255,165,64,.14); }
      100%{ box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 0 0 0 rgba(255,165,64,.00); }
    }

    
.swatch{
  width: 20px; height: 20px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.16);
  cursor:pointer;
  position:relative;
  flex: 0 0 auto;
  appearance: none;
  background: radial-gradient(140% 140% at 30% 25%, var(--sw1, rgba(255,255,255,.25)), var(--sw2, rgba(255,255,255,.08)));
  box-shadow: inset 0 1px 0 rgba(255,255,255,.20), 0 10px 22px rgba(0,0,0,.35);
  filter: saturate(1.12) contrast(1.02);
  transition: transform .08s ease, border-color .12s ease, box-shadow .12s ease, filter .12s ease;
}

    .swatch:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.26); }
    .swatch[data-active="true"]{
      border-color: rgba(255,165,64,.38);
      box-shadow: 0 0 0 4px rgba(255,165,64,.12);
    }
    .swatch:focus-visible{ outline:none; box-shadow: var(--ring); }

    .iconbtn{
      width: 34px; height: 34px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      display:grid; place-items:center;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select:none;
    }
    .iconbtn:hover{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.24); }
    .iconbtn:active{ transform: translateY(1px); }
    .iconbtn:focus-visible{ outline:none; box-shadow: var(--ring); }
    .iconbtn[data-active="true"]{
      border-color: rgba(86,242,194,.40);
      box-shadow: 0 0 0 4px rgba(86,242,194,.12);
    }
    .themeLabel{
      max-width: 220px;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* Phone panel */
    .phone-panel-body{
      padding: 12px;
      display:flex;
      flex: 1 1 auto;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 10px;
      overflow:hidden;
      min-height:0;
    }

    
    /* ===============================
       Phone Truth Layer — Shell System
       (Clean shell)
       Canon size + positioning preserved
       =============================== */

    .phone-wrap{
      position: relative;
      width: calc(380px * var(--phone-scale, 1));
      height: calc(760px * var(--phone-scale, 1));
      flex: 0 0 auto;
      /* default shell */
      --shell-stroke: rgba(120,190,255,0.18);
      --shell-shadow: 0 18px 40px rgba(0,0,0,0.55);
      --shell-bg-a: rgba(122,180,255,.10);
      --shell-bg-b: rgba(185,139,255,.08);
      --shell-surface-top: #0b1020;
      --shell-surface-bot: #060914;
    }

    /* Shell variants (ONLY change variables + optional halo) */
    .phone-wrap[data-shell="clean"]{
      --shell-stroke: rgba(120,190,255,0.18);
      --shell-shadow: 0 18px 40px rgba(0,0,0,0.55);
    }
    /* Optional ambient halo — applied only for dock/luxe */
    .phone-inner{
      position:absolute; left:0; top:0;
      width: 380px;
      height: 760px;
      transform: translateZ(0) scale(var(--phone-scale, 1));
      transform-origin: top left;
      display:grid;
      grid-template-rows: 44px 58px 1fr 62px 34px;

      /* One confident object (no stacked borders) */
      border-radius: 46px;
      overflow:hidden;
  background: linear-gradient(180deg, rgba(24,28,42,1), rgba(8,10,16,1)) !important;

      box-shadow:
        0 0 0 1px var(--shell-stroke),
        var(--shell-shadow);
      z-index:1;
    }

    /* Micro highlight — subtle, never a second border */
    /* Keep child stacking predictable */
    .phone-inner > *{ position: relative; z-index: 2; }
.statusbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 26px 8px 26px;
      font-size: calc(11.5px * var(--phone-font-scale));
      color: rgba(255,255,255,.78);
      background: linear-gradient(180deg, var(--phoneBarA), var(--phoneBarB));
      border-bottom: 1px solid var(--phoneBarStroke);
      }
    .status-left{ display:flex; align-items:center; gap:10px; min-width:0; }
    .phone-time{ font-variant-numeric: tabular-nums; letter-spacing:.2px; }
    .status-pill{
      display:inline-flex; align-items:center; gap:6px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      font-size: calc(10.8px * var(--phone-font-scale));
      color: rgba(255,255,255,.82);
      white-space: nowrap;
    }

    .status-online{
      display:inline-flex; align-items:center; gap:6px;
      padding: 0;
      border: none;
      background: transparent;
      font-size: calc(10.8px * var(--phone-font-scale));
      color: rgba(255,255,255,.78);
      white-space: nowrap;
    }
    .status-online .status-text{ opacity:.92; }

    .status-dot{
      width:6px; height:6px; border-radius:999px;
      background: rgba(110,255,190,.90);
      box-shadow: 0 0 0 3px rgba(110,255,190,.16);
      flex: 0 0 auto;
    }
    .status-right{ display:flex; align-items:center; gap:8px; color: rgba(255,255,255,.72); }
    .signal-bars{ display:flex; align-items:flex-end; gap:2px; height: 12px; }
    .signal-bars span{
      width:3px;
      border-radius:2px;
      background: rgba(255,255,255,.60);
      opacity:.86;
    }
    .signal-bars span:nth-child(1){ height:4px; opacity:.55; }
    .signal-bars span:nth-child(2){ height:6px; opacity:.65; }
    .signal-bars span:nth-child(3){ height:8px; opacity:.78; }
    .signal-bars span:nth-child(4){ height:10px; opacity:.92; }
    .battery{
      width:20px; height:11px;
      border-radius:3px;
      border: 1px solid rgba(255,255,255,.28);
      position:relative;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.28);
    }
    .battery::after{
      content:"";
      position:absolute; right:-3px; top:3px;
      width:2px; height:5px;
      border-radius:2px;
      background: rgba(255,255,255,.26);
    }
    .battery .battery-level{
      position:absolute; left:1px; top:1px; bottom:1px;
      width: 72%;
      border-radius:2px;
      background: rgba(122,180,255,.60);
    }

    .chathead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--phoneBarStroke);
      background: linear-gradient(180deg, var(--phoneBarA), var(--phoneBarB));
      /* phone header remains solid (no blur) */
      min-width:0;
    }
    .chathead-left{ display:flex; align-items:center; gap: 10px; min-width:0; }
    .avatar{
      width: 30px; height: 30px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(circle at 30% 35%, rgba(255,255,255,.10), transparent 45%),
        radial-gradient(circle at 70% 65%, rgba(122,180,255,.18), transparent 55%),
        rgba(0,0,0,.16);
      display:grid; place-items:center;
      font-weight:800;
      font-size: 12px;
      color: rgba(255,255,255,.86);
      flex:0 0 auto;
    }
    .chatmeta{ min-width:0; }
    .chatmeta .title{
      font-size: calc(12.8px * var(--phone-font-scale));
      font-weight: 800;
      letter-spacing:.2px;
      line-height:1.1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chatmeta .sub{
      margin-top: 2px;
      font-size: calc(11px * var(--phone-font-scale));
      color: rgba(255,255,255,.62);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chathead-right{
      display:flex; align-items:center; gap: 8px;
      color: rgba(255,255,255,.62);
      font-size: calc(11px * var(--phone-font-scale));
      white-space:nowrap;
      flex: 0 0 auto;
    }
    .dotlive{
      width:6px; height:6px; border-radius:999px;
      background: rgba(110,255,190,.85);
      box-shadow: 0 0 0 3px rgba(110,255,190,.15);
    }

    .chat{
      overflow:auto;
      padding: 12px 14px 12px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      min-width:0;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.18) transparent;
    }
    .chat::-webkit-scrollbar{ width:10px; }
    .chat::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.14); border-radius:999px; border: 3px solid transparent; background-clip: content-box; }
    .chat::-webkit-scrollbar-track{ background: transparent; }

    /* Bubble alignment FIX */
    .bubble{
      align-self: flex-start;
      /* Keep bubbles inside the phone — and force safe wrapping for long unbroken strings */
      display: inline-block;
      width: fit-content;
      min-width: 0;
      max-width: min(84%, 42ch);
      padding: 10px 12px;
      border-radius: 18px;
      border: 1px solid var(--bub-cust-stroke);
      background: var(--bub-cust);
      color: rgba(255,255,255,.92);
      font-size: calc(13.5px * var(--phone-font-scale));
      line-height: 1.35;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
      hyphens: auto;
    }
    .bubble[data-role="agent"]{
      align-self: flex-end;
      border-color: var(--bub-agent-stroke);
      background: var(--bub-agent);
    }
    .bubble.preview{
      opacity: .70;
      border-style: dashed;
      filter: saturate(1.05);
    }

    .phone-input{
      padding: 10px 10px 10px;
      display:flex;
      align-items:flex-end;
      gap: 8px;
      border-top: 1px solid var(--phoneBarStroke);
      background: var(--phoneBarB);
      }
    .phone-input .tipline{
  word-break: break-word;
      flex:1 1 auto;
      min-height: 46px;
      max-height: 52px; /* never grows beyond the input bar */
      height: auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.055);
      display:flex;
      align-items:center;
      padding: 7px 10px;
      color: rgba(255,255,255,.74);
      font-size: calc(10.6px * var(--phone-font-scale)); /* smaller = more 'real phone' */
      overflow:hidden;
      min-width:0;
      transition: opacity .28s ease, filter .28s ease;
    }
    .phone-input .tipline.tip-fade-out{ opacity: .18; filter: blur(.35px); }
    .phone-input .tipline .tip-text{
      /* 2-line clamp, ~35 chars/line */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      max-width: min(50ch, 100%);
      overflow:hidden;
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
      line-height: 1.18;
    }
    .send-dot{
      width: 40px; height: 40px;
      border-radius: 999px;
      border: 1px solid rgba(122,180,255,.35);
      background: rgba(122,180,255,.14);
      display:grid; place-items:center;
      color: rgba(255,255,255,.88);
      cursor:pointer;
      user-select:none;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      flex: 0 0 auto;
    }


/* Option 1: Phone™ rolling customer replies
   - Only triggers when agent draft is empty
   - Tap the send-dot to step to the next customer reply */
.send-dot.pulse{ animation: sendPulse 420ms ease-out; }
@keyframes sendPulse{
  0%{ transform: scale(1); box-shadow: 0 10px 28px rgba(155,220,255,.14), inset 0 0 0 1px rgba(255,255,255,.14); }
  45%{ transform: scale(1.06); box-shadow: 0 14px 34px rgba(155,220,255,.20), inset 0 0 0 1px rgba(255,255,255,.20); }
  100%{ transform: scale(1); box-shadow: 0 10px 28px rgba(155,220,255,.14), inset 0 0 0 1px rgba(255,255,255,.14); }
}

.bubble.typing{
  padding: 10px 12px;
  min-height: 28px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.bubble.typing .typing-dot{
  width: 6px; height: 6px; border-radius: 999px;
  background: rgba(255,255,255,.86);
  opacity: .55;
  animation: typingBounce 1.1s infinite ease-in-out;
}
.bubble.typing .typing-dot:nth-child(2){ animation-delay: .12s; opacity: .45; }
.bubble.typing .typing-dot:nth-child(3){ animation-delay: .24s; opacity: .38; }

@keyframes typingBounce{
  0%, 100%{ transform: translateY(0); opacity: .40; }
  50%{ transform: translateY(-2px); opacity: .90; }
}

@media (prefers-reduced-motion: reduce){
  .send-dot.pulse{ animation: none; }
  .bubble.typing .typing-dot{ animation: none; opacity: .70; }
}
    .send-dot:hover{ background: rgba(122,180,255,.18); border-color: rgba(122,180,255,.48); }
    .send-dot:active{ transform: translateY(1px); }
    .send-dot:focus-visible{ outline:none; box-shadow: var(--ring); }

    .gesture{
      display:flex;
      align-items:center;
      justify-content:center;
      padding-bottom: 6px;
    }
    .gesture::before{
      content:"";
      width: 120px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,.22);
      opacity: .75;
    }

    /* Phone text size */
    .textsize{
      width: min(520px, 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      padding: 6px 10px 0;
      color: rgba(255,255,255,.66);
      font-size: 12px;
      user-select:none;
    }
    .textsize .label{
      letter-spacing:.25px;
      font-weight:800;
      color: rgba(255,255,255,.70);
      margin-right: 6px;
    }
    .tsbtn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.86);
      padding: 4px 7px;
      border-radius: 999px;
      cursor:pointer;
      font-weight:800;
      font-size: 10px;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
    }
    .tsbtn:hover{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.24); }
    .tsbtn:active{ transform: translateY(1px); }
    .tsbtn:focus-visible{ outline:none; box-shadow: var(--ring); }
    .tsbtn[data-active="true"]{
      border-color: rgba(255,165,64,.40);
      background: rgba(255,165,64,.14);
    }

    /* Insights */
    .cards{ display:flex; flex-direction:column; gap: 10px; }
    .card{
      border: 1px solid var(--stroke);
      border-radius: var(--radius-sm);
      background: rgba(0,0,0,.14);
      padding: 10px;
    }
    .card h3{
      margin:0 0 6px;
      font-size: 12.5px;
      letter-spacing:.2px;
      display:flex; align-items:center; justify-content:space-between;
    }
    .card p{ margin:0; color: var(--muted); font-size: 12.5px; line-height:1.4; }

    /* Focus modes */
    body[data-focus="phone"] .tri{ grid-template-columns: 1fr; }
    body[data-focus="phone"] .panel[data-panel="draft"],
    body[data-focus="phone"] .panel[data-panel="insights"]{ display:none; }
    body[data-focus="phone"] .panel[data-panel="phone"] .phone-wrap{
      /* keep same scaling rules in focus mode (no stretch) */
      width: calc(380px * var(--phone-scale, 1));
      height: calc(760px * var(--phone-scale, 1));
      max-width: none;
      max-height: none;
    }

    body[data-focus="editor"] .tri{ grid-template-columns: 1fr; }
    body[data-focus="editor"] .panel[data-panel="phone"],
    body[data-focus="editor"] .panel[data-panel="insights"]{ display:none; }
    body[data-focus="editor"] #agentDraft{
      min-height: calc(100vh - (var(--app-pad) * 2) - var(--panel-header-h) - 190px);
      font-size: 15px;
      line-height: 1.55;
    }

    .focus-exit{ display:none; }
    body[data-focus="phone"] .focus-exit,
    body[data-focus="editor"] .focus-exit{ display:inline-flex; }

    /* Responsive */
    @media (max-width: 1060px){
      .tri{ grid-template-columns: 1fr; }
      .phone-wrap{ /* scaling handled globally via --phone-scale (see updatePhoneScale) */ }
      .textsize{ padding-bottom: 6px; }
    }
    /* --- P1c: Utilities hub + slimmer toolbars --- */

    /* Keep phone frame stable (no squash) */
    .phone-panel-body{ justify-content:center; }

    /* Draft toolbars: icon-only row + inserts row */
    .classic-toolbar.formatbar{ gap: 8px; flex-wrap: wrap; }
    .classic-toolbar .pillbtn.icononly{
      width: 34px; min-width: 34px;
      padding: 8px 0;
      display:inline-flex; align-items:center; justify-content:center;
      letter-spacing: .5px;
    }
    .classic-toolbar.insertbar{ margin-top: 8px; gap: 8px; flex-wrap: wrap; }

    /* Dock = two rows (stats then actions) */
    .dock{ flex-direction: column; align-items: stretch; gap: 10px; }
    .dock-left, .dock-right{ width: 100%; justify-content:flex-start; }

    /* Preview button becomes icon-only */
    .pillbtn.iconpill{
      min-width: 34px;
      padding: 8px 10px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 6px;
    }

    
    /* Utilities hub at bottom of Insights (moved to global styles in UI-lock v1) */
/* Slightly slimmer minis + buttons in dock */
    .mini{ padding: 8px 10px; border-radius: 999px; }
    .pillbtn{ padding: 9px 12px; border-radius: 999px; }

  
    /* --- P1d: Phone scaling ---
       Scaling is driven by updatePhoneScale() which sets --phone-scale on :root.
       - .phone-wrap uses scaled layout size (prevents clipping)
       - .phone-inner scales the contents (prevents stretch / reflow)
    */

    /* disable the old responsive/focus resizing that caused stretch */
    body[data-focus="phone"] .panel[data-panel="phone"] .phone-wrap{
      /* hard cap: never scale up beyond canonical; allow scale-down to prevent clipping */
      width: calc(380px * var(--phone-scale, 1)) !important;
      height: calc(760px * var(--phone-scale, 1)) !important;
      max-width: none !important;
      max-height: none !important;
      min-width: 0 !important;
      min-height: 0 !important;
    }
    @media (max-width: 1060px){
      .phone-wrap{
        width: calc(380px * var(--phone-scale, 1)) !important;
        height: calc(760px * var(--phone-scale, 1)) !important;
        max-width: none !important;
        max-height: none !important;
        min-width: 0 !important;
        min-height: 0 !important;
      }
    }

/* === P2: Always-visible Insights cards === */
.card-head{display:flex; align-items:flex-start; justify-content:space-between; gap:10px}
.mini-pills{display:flex; flex-wrap:wrap; gap:6px; justify-content:flex-end}
.pill{display:inline-flex; align-items:center; gap:6px; padding:5px 8px; border-radius:999px;
  background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); font-size:11px; color:rgba(235,245,255,.88)}
.pill b{font-variant-numeric:tabular-nums; color:#fff}
.insight-body{margin-top:10px}
.insight-list{display:flex; flex-direction:column; gap:8px}
.insight-item{display:flex; gap:10px; align-items:flex-start; padding:9px 10px;
  border-radius:14px; background:rgba(0,0,0,.16); border:1px solid rgba(255,255,255,.08)}
.insight-dot{width:9px; height:9px; margin-top:4px; border-radius:999px; background:var(--accent); box-shadow: 0 0 0 3px rgba(255,255,255,.03) inset}
.insight-item .k{font-weight:650; font-size:11px; margin-bottom:2px; letter-spacing:.01em}
.insight-item .v{font-size:11px; color:rgba(235,245,255,.78); line-height:1.30}
.insight-muted{padding:10px; border-radius:14px; background:rgba(255,255,255,.04); border:1px dashed rgba(255,255,255,.12);
  color:rgba(235,245,255,.70); font-size:12px}

.insight-item .meta{
  margin-top:4px;
  font-size:11px;
  color: rgba(235,245,255,.62);
  line-height:1.28;
}
.insight-item .meta2{ color: rgba(235,245,255,.58); }

/* --- D-4C: Top offenders + category pill (additive) --- */
.insight-chiprow{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  padding:10px 10px 6px;
  margin:8px 0 12px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  background: rgba(255,255,255,.03);
}
.insight-chip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.14);
  font-size:12px;
  cursor:pointer;
  user-select:none;
}
.insight-chip:hover{ filter:brightness(1.08); }

/* --- D-4H: Top offenders disclosure --- */
.insight-disclosure{
  margin:8px 0 12px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  background: rgba(255,255,255,.02);
  overflow:hidden;
}
.insight-disclosure > summary{
  list-style:none;
  cursor:pointer;
  user-select:none;
  padding:10px 10px;
  display:flex;
  align-items:center;
  gap:10px;
  font-size:12px;
  color:rgba(235,245,255,.78);
}
.insight-disclosure > summary::-webkit-details-marker{ display:none; }
.insight-disclosure > summary:before{
  content:"▸";
  opacity:.65;
  transform: translateY(-1px);
}
.insight-disclosure[open] > summary:before{ content:"▾"; }
.insight-disclosure .sum-right{
  margin-left:auto;
  opacity:.7;
  font-variant-numeric: tabular-nums;
}
.insight-disclosure .insight-chiprow{
  border:none;
  background:transparent;
  margin:0;
  padding:0 10px 10px;
}

.insight-cat{
  display:inline-flex;
  align-items:center;
  padding:3px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  font-size:11px;
  opacity:.95;
}
.issue-actions{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.panel[data-panel="insights"] .btn-mini{
  font-size:11px;
  padding:5px 10px;
  border-radius:999px;
  line-height:1;
}
.panel[data-panel="insights"] .btn-mini.danger{
  border-color: rgba(255,120,160,.35);
}


    /* === P1c: Pin Utilities hub to bottom of Insights (non-overlapping) === */
    .panel[data-panel="insights"] .panel-body{
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height:0;
      overflow:hidden; /* prevent whole panel scroll */
    }
    .panel[data-panel="insights"] .cards{
      flex: 1 1 auto;
      min-height:0;
      overflow:auto;  /* scroll flags here */
      padding-right: 2px;
      padding-bottom: 6px;
    }
    .panel[data-panel="insights"] .utilitiesHub{
      flex: 0 0 auto;
      margin-top: auto; /* push to bottom when content is short */
    }


/* === UIlock v2 patch: Dice-only sky + motion translucency === */
.swatches{ display:none !important; }
body[data-motion="on"] .panel{
  background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.12));
}
body[data-motion="on"] .panel::before{
  opacity: .75;
}



/* D-4B Agent audit (minimal UI) */
.cx-audit{ margin: 10px 0 6px; }
.cx-audit .audit-chips{ display:flex; flex-wrap:wrap; gap:8px; margin: 8px 0 6px; }
.cx-audit .audit-chips .chip{ background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); }
.cx-audit .audit-row{
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  padding: 10px 12px;
  margin: 8px 0;
}
.cx-audit .audit-title{ font-weight: 650; font-size: 12.5px; margin-bottom: 4px; }
.cx-audit .audit-detail{ font-size: 12px; opacity:.88; }

/* === UI polish: lighter glass + scrollbars (v2f) === */
:root{
  --panelA: rgba(12, 18, 26, .46);
  --panelB: rgba(10, 14, 22, .28);
  --card:   rgba(255,255,255,.075);
  --card2:  rgba(255,255,255,.095);
  --stroke: rgba(255,255,255,.14);
  --stroke2:rgba(255,255,255,.18);
  --shadow: rgba(0,0,0,.28);
  --panelBlur: 18px;
}
/* Glass clarity toggle (Utilities) */
body[data-glass="clear"]{
  /* clearer backdrop panels: higher transparency, minimal blur */
  --panelA: rgba(12, 18, 26, .06);
  --panelB: rgba(10, 14, 22, .02);
  /* keep controls / cards readable (inputs + toolbars stay solid-ish) */
  --card:   rgba(255,255,255,.075);
  --card2:  rgba(255,255,255,.095);
  --stroke: rgba(255,255,255,.12);
  --stroke2:rgba(255,255,255,.16);
  --shadow: rgba(0,0,0,.16);
  --panelBlur: 1px;
}


.panel{
  background: linear-gradient(180deg, var(--panelA), var(--panelB));
  backdrop-filter: blur(var(--panelBlur)) saturate(1.14) contrast(1.02);
  -webkit-backdrop-filter: blur(var(--panelBlur)) saturate(1.14) contrast(1.02);
  box-shadow:
    0 26px 70px rgba(0,0,0,.40),
    0 8px 24px rgba(0,0,0,.26),
    inset 0 1px 0 rgba(255,255,255,.08),
    inset 0 -1px 0 rgba(255,255,255,.04);
}

.panel::after{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  border-radius: inherit;
  background: radial-gradient(1200px 500px at 25% 0%, rgba(255,255,255,.06), transparent 55%),
              radial-gradient(900px 500px at 90% 15%, rgba(255,255,255,.04), transparent 55%);
  mix-blend-mode: screen;
  opacity:.65;
}

.card, .box, .pill, .seg, .seg button, .seg .btn{
  backdrop-filter: blur(10px) saturate(1.10);
  -webkit-backdrop-filter: blur(10px) saturate(1.10);
}

/* Scrollbars */
*{
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,.22) rgba(255,255,255,.06);
}
*::-webkit-scrollbar{ width: 10px; height: 10px; }
*::-webkit-scrollbar-track{
  background: rgba(255,255,255,.05);
  border-radius: 999px;
}
*::-webkit-scrollbar-thumb{
  background: linear-gradient(180deg, rgba(255,255,255,.30), rgba(255,255,255,.12));
  border: 2px solid rgba(0,0,0,.22);
  border-radius: 999px;
}
*::-webkit-scrollbar-thumb:hover{
  background: linear-gradient(180deg, rgba(255,255,255,.42), rgba(255,255,255,.18));
}


/* Toolbar: center + compact stats + separator */
.panel[data-panel="draft"] .classic-toolbar{ justify-content: center !important; }
.panel[data-panel="draft"] .classic-toolbar .vsep{
  width: 1px;
  height: 24px;
  align-self: center;
  margin: 0 6px;
  border-radius: 1px;
  background: rgba(255,255,255,.12);
  box-shadow: 0 0 0 1px rgba(0,0,0,.12) inset;
}
.panel[data-panel="draft"] .classic-toolbar .miniStat{
  padding: 6px 10px !important;
  opacity: .95;
}
.panel[data-panel="draft"] .classic-toolbar .miniStat b{
  font-weight: 700;
  margin-left: 6px;
}


/* === Toolbar Pocket (customizable tools, max 2 rows) === */

/* Draft stack ordering lock: Customer -> Toolbar -> Agent (prevents any accidental reflow) */
.panel[data-panel="draft"] .stack{ display:flex; flex-direction:column; }
.panel[data-panel="draft"] .customerBlock{ order: 1; }
.panel[data-panel="draft"] .draftToolbarBlock{ order: 2; }
.panel[data-panel="draft"] .agentBlock{ order: 3; }

.toolbarWrap{ position: relative; }
.classic-toolbar.compact2{
  gap: 8px;
  flex-wrap: wrap;
  padding: 10px 12px;
  align-items: center;
  /* hard-cap to two rows */
  --tb-row: 34px;
  max-height: calc((var(--tb-row) * 2) + 12px);
  overflow: hidden;
}
.classic-toolbar.compact2 .pillbtn{
  font-size: 11px;
  padding: 7px 10px;
}
.classic-toolbar.compact2 .pillbtn.icononly{
  width: 34px;
  height: 34px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.classic-toolbar.compact2 .miniStat{
  padding: 7px 10px;
  font-size: 11px;
  opacity: 0.95;
}
.classic-toolbar.compact2 .pinnedSlot{
  display: inline-flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}
.classic-toolbar.compact2 #btnToolPocket{
  width: 34px;
  height: 34px;
  padding: 0;
  border-style: dashed;
  opacity: 0.95;
}

/* Tool Pocket Notch (Pen icon) — dock to the toolbar corner */
#draftToolbar{ position: relative; padding-right: 46px; }
#btnToolPocket{
  position: absolute;
  right: 10px;
  top: 7px;
}
.toolPocket{
  margin-top: 10px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  background: rgba(10,16,28,.55);
  box-shadow: 0 18px 44px rgba(0,0,0,.38);
  padding: 12px;
}
.toolPocketHead{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 10px;
}
.toolPocketTitle{
  font-weight: 700;
  letter-spacing: .2px;
  opacity: .95;
}
.toolPocketGrid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
}
.toolToggle{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 9px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
}
.toolToggle .left{
  display:flex;
  align-items:center;
  gap: 10px;
  min-width: 0;
}
.toolToggle .ico{
  width: 34px;
  height: 34px;
  border-radius: 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  flex: 0 0 auto;
}
.toolToggle .lbl{
  font-size: 12px;
  opacity: .92;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.toolToggle input{ transform: scale(1.05); }
.toolPocketHint{
  margin-top: 10px;
  font-size: 11px;
  opacity: .75;
}
/* reclaim vertical space: dock actions now live in toolbar */
.dock-right{ display:none !important; }


/* === Compact Utilities (match new toolbar sizing) === */
.utilitiesHub{
  padding: 8px 8px !important;
  border-radius: 16px !important;
}
.utilitiesHub .utilities-bar{ gap: 6px !important; align-items:flex-start !important; justify-content:flex-start !important; }
.utilitiesHub .utilities-row{ gap: 8px !important; justify-content:flex-start !important; width:100% !important; }
.utilitiesHub .utilities-row .iconbtn{ margin-right: 0 !important; }
.utilitiesHub .iconbtn{
  width: 28px !important;
  height: 28px !important;
  border-radius: 10px !important;
}
.utilitiesHub .pillbtn,
.utilitiesHub .btn{
  padding: 6px 10px !important;
  border-radius: 999px !important;
  font-size: 12px !important;
  line-height: 1 !important;
}
.utilitiesTitle{ margin-bottom: 6px !important; font-size: 10px !important; }


/* === MF:UI: Editor toolbar notch + hard order lock extras === */
.toolbarWrap{ position: relative; }
#draftToolbar{ position: relative; padding-right: 44px; } /* space for notch */
#btnToolPocket{
  position: absolute !important;
  top: 8px;
  right: 10px;
  width: 30px;
  height: 30px;
  border-radius: 9px;
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  line-height: 1;
  padding: 0 !important;
  letter-spacing: 0.02em;
  opacity: 0.92;
}
#btnToolPocket:hover{ transform: translateY(-1px); opacity: 1; }


    /* ===== Utilities Modals (UI-only) ===== */
    .util-pill{
      padding: 7px 10px;
      font-size: 12px;
      letter-spacing: .2px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
    }
    .util-pill:hover{ background: rgba(255,255,255,.09); }
    .mf-modalOverlay{
      position: fixed;
      inset: 0;
      display: none;
      align-items: flex-end;           /* sheet: dock to bottom */
      justify-content: center;
      background: rgba(0,0,0,.32);     /* lighter than full modal */
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      z-index: 9999;
      padding: 0;                      /* sheet: edge-to-edge */
    }
    .mf-modalOverlay[data-open="true"]{ display: flex; }

    /* --- Docked Utility Sheet --- */
    .mf-modal{
      width: min(980px, 100vw);
      max-height: min(78vh, 860px);
      display: flex;
      flex-direction: column;
      border-radius: 18px 18px 0 0;    /* top rounded only */
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(16,20,36,.96), rgba(10,12,22,.96));
      box-shadow:
        0 -18px 40px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.06);
      transform: translate3d(0, 18px, 0);
      opacity: 0;
      transition: transform .22s ease, opacity .22s ease;
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }
    .mf-modalOverlay[data-open="true"] .mf-modal{
      transform: translate3d(0, 0, 0);
      opacity: 1;
    }

    .mf-modalOverlay.mf-sheetDragging{ user-select:none; }
    .mf-modalOverlay.mf-sheetDragging .mf-modal{ will-change: transform, opacity; }

    /* ===== Lite-safe Utilities Popups (CSS :target) ===== */
    .mf-popup{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(0,0,0,0.55);
      z-index: 99999;
    }
    .mf-popup:target{ display:flex; }
    .mf-popupCard{
      width: min(980px, calc(100vw - 48px));
      max-height: min(78vh, 760px);
      overflow: hidden;
      border-radius: 16px;
      background: rgba(15,18,28,0.92);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 22px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
    }
    .mf-popupHeader{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .mf-popupTitle{ font-weight: 750; letter-spacing: .2px; }
    .mf-popupHeaderRight{ display:flex; align-items:center; gap: 10px; }
    .mf-popupClose{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      text-decoration:none;
      line-height: 1;
    }
    .mf-popupClose:hover{ background: rgba(255,255,255,0.10); }
    .mf-popupBody{
      padding: 14px 16px 16px;
      max-height: calc(min(78vh, 760px) - 56px);
      overflow: auto;
    }
    /* === How it works: 2-panel layout === */
    .mf-howGrid{ display:grid; grid-template-columns: 2fr 1fr; gap: 14px; align-items:start; }
    @media (max-width: 860px){ .mf-howGrid{ grid-template-columns: 1fr; } }
    .mf-panelCard{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 12px 12px;
    }
    .mf-panelCard h3{ margin: 0 0 8px; }
    .mf-chipRow{ display:flex; flex-wrap:wrap; gap: 8px; margin: 8px 0 0; }
    .mf-chipPill{
      display:inline-flex; align-items:center; gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      font-size: 12px;
      opacity: .92;
      white-space: nowrap;
    }
    .mf-sideSticky{ position: sticky; top: 0; }

    .mf-popupBody h3{ margin: 12px 0 8px; font-size: 13px; opacity: .92; letter-spacing: .2px; }
    .mf-popupBody ul{ margin: 0 0 8px 18px; }
    .mf-popupBody li{ margin: 6px 0; }
    .mf-kvGrid{ display:grid; grid-template-columns: 180px 1fr; gap: 8px 12px; }
    .mf-k{ opacity: .85; }
    .mf-v{ opacity: .95; }
    .mf-miniNote{ font-size: 12px; opacity: .78; margin-top: 8px; }
    .mf-changelog{ display:flex; flex-direction:column; gap: 8px; margin-top: 8px; }
    .mf-changelogItem{ padding: 10px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); }
    .mf-changelogTop{ display:flex; justify-content:space-between; gap: 10px; font-size: 12px; opacity:.9; }
    .mf-changelogBullets{ margin: 8px 0 0 18px; }

    
    /* ===== Dev Lab (Visibility Manager) ===== */
    .mf-devGrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 860px){ .mf-devGrid{ grid-template-columns: 1fr; } }
    .mf-devCard{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      padding: 12px;
    }
    .mf-devCard h3{ margin: 0 0 8px; font-size: 13px; letter-spacing:.2px; }
    .mf-devMeta{ display:flex; align-items:center; justify-content:space-between; gap: 10px; margin: 0 0 10px; }
    .mf-devMeta .mini{ margin:0; opacity:.82; }
    .mf-devWarn{
      margin: 10px 0 0;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,180,120,0.26);
      background: rgba(255,180,120,0.10);
      font-size: 12px;
      opacity:.95;
    }
    .mf-devList{ display:flex; flex-direction:column; gap: 8px; max-height: 360px; overflow:auto; padding-right: 4px; }
    .mf-devRow{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    .mf-devKey{
      font-family: var(--mono);
      font-size: 12px;
      opacity: .92;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
    }
    .mf-devBtns{ display:flex; gap: 8px; align-items:center; flex: 0 0 auto; }
    .mf-devBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      padding: 7px 10px;
      border-radius: 999px;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
    }
    .mf-devBtn:hover{ background: rgba(255,255,255,0.09); }
    .mf-devBtn.danger{
      border-color: rgba(255,120,120,0.26);
      background: rgba(255,120,120,0.10);
    }
    .mf-devBtn.danger:hover{ background: rgba(255,120,120,0.14); }

/* === Dictionaries popup: tabs + sections === */
    .mf-dictTabs{ display:flex; gap: 8px; align-items:center; margin: 0 0 10px; }
    .mf-dictTabBtn{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      padding: 7px 10px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: .2px;
      cursor: pointer;
      user-select: none;
    }
    .mf-dictTabBtn:hover{ background: rgba(255,255,255,0.10); }
    .mf-dictTabBtn.is-active{ background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.18); }
    .mf-dictSection{ display:none; }
    .mf-dictSection.is-active{ display:block; }
    .mf-kpiRow{ display:flex; flex-wrap:wrap; gap: 8px; margin: 10px 0 0; }
    .mf-kpi{ font-size: 12px; opacity:.9; padding: 6px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.20); }

    /* drag handle */
    .mf-sheetGrab{
      height: 18px;
      display: grid;
      place-items: center;
      padding-top: 8px;
      cursor: grab;
      user-select: none;
    }
    .mf-sheetGrab::before{
      content:"";
      width: 54px;
      height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
    }

    /* keep header readable in sheet */
    .mf-modalHeader{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .mf-modalTitle{ font-weight: 700; font-size: 13px; letter-spacing:.3px; opacity:.95; }
    .mf-modalHeaderRight{ display:flex; align-items:center; gap:10px; }
    .mf-modalSearch{
      width: min(420px, 48vw);
      height: 32px;
      padding: 0 10px;
      border-radius: 10px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      outline: none;
    }
    .mf-modalSearch::placeholder{ color: rgba(255,255,255,.50); }
    .mf-modalClose{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 14px;
    }
    .mf-modalTabs{
      display:flex;
      gap: 8px;
      padding: 10px 14px 0 14px;
      flex-wrap: wrap;
    }
    .mf-tab{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-size: 12px;
      color: rgba(255,255,255,.86);
    }
    .mf-tab[aria-selected="true"]{
      background: rgba(140,180,255,.16);
      border-color: rgba(140,180,255,.30);
      box-shadow: 0 0 0 3px rgba(140,180,255,.12);
      color: rgba(255,255,255,.96);
    }
    .mf-modalBody{
      padding: 12px 14px 14px 14px;
      overflow:auto;
      flex: 1;
    }
    .mf-modalFooter{
      padding: 10px 14px;
      border-top: 1px solid rgba(255,255,255,.07);
      font-size: 12px;
      color: rgba(255,255,255,.65);
      background: rgba(0,0,0,.10);
    }
    .mf-table{
      width: 100%;
      border-collapse: collapse;
      overflow: hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
    }
    .mf-table th, .mf-table td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      vertical-align: top;
      font-size: 12px;
      color: rgba(255,255,255,.84);
    }
    .mf-table th{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .7px;
      color: rgba(255,255,255,.62);
      background: rgba(255,255,255,.04);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .mf-kbd{
      display:inline-flex;
      padding: 2px 7px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-size: 11px;
      color: rgba(255,255,255,.78);
    }
    .mf-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      color: rgba(255,255,255,.78);
      margin-right: 8px;
      margin-bottom: 8px;
    }


/* === Writer Insights actions (Jump / Hide / Apply / Ignore) === */
.insight-group{display:flex; align-items:center; justify-content:space-between; padding:8px 2px 2px; margin-top:2px;}
.insight-group .t{font-size:11px; letter-spacing:.14em; text-transform:uppercase; color:rgba(240,248,255,.60);}
.issue-actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px;}
.btn-mini{
  cursor:pointer; border:none;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  color:rgba(245,250,255,.92);
  font-size:11px; padding:4px 10px; border-radius:999px;
}
.btn-mini:hover{background:rgba(255,255,255,.09);}
.btn-mini:active{transform:translateY(1px);}
.btn-mini[disabled]{opacity:.45; cursor:not-allowed;}
.btn-mini.danger{
  border-color:rgba(255,120,120,.25);
  background:rgba(255,120,120,.08);
}
.meta.meta2{opacity:.85; margin-top:2px;}



/* ===== Phase A: Portal header + CX mode toggles ===== */
.panel[data-panel="phone"] .panel-header.portal-header{
  display:grid;
  grid-template-columns: 1fr auto 1fr;
  align-items:center;
}
.panel[data-panel="phone"] .panel-header.portal-header .panel-title{ justify-self:start; }
.panel[data-panel="phone"] .panel-header.portal-header .mf-appname{
  justify-self:center;
  font-weight: 800;
  letter-spacing: .35px;
  opacity: .92;
  user-select:none;
  pointer-events:none;
}
.panel[data-panel="phone"] .panel-header.portal-header .chips{
  justify-self:end;
  display:flex;
  align-items:center;
  gap:8px;
}

/* focus icon buttons (same footprint as dice) */
.panel-header .iconbtn.focusicon{
  width: 34px;
  height: 34px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:0;
  border-radius: 11px;
}


.cx-lens{margin:2px 0 10px}
/* CX Insights mode row */
.insights-modes{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  padding:10px 12px 0 12px;
}
.insights-modes .modebtn{
  padding:6px 10px;
  border-radius: 999px;
  font-size:12px;
}
.insights-modes .modebtn[data-active="true"]{
  border-color: rgba(185,139,255,.65);
  background: rgba(185,139,255,.14);
  box-shadow: 0 0 0 4px rgba(185,139,255,.10);
}

/* show one CX card at a time */
.panel[data-panel="insights"] .card[data-cx]{ display:none; }
.panel[data-panel="insights"][data-cxmode="writer"] .card[data-cx="writer"]{ display:block; }
.panel[data-panel="insights"][data-cxmode="ukus"] .card[data-cx="ukus"]{ display:block; }
.panel[data-panel="insights"][data-cxmode="jargon"] .card[data-cx="jargon"]{ display:block; }
.panel[data-panel="insights"][data-cxmode="experience"] .card[data-cx="experience"]{ display:block; }
.panel[data-panel="insights"][data-cxmode="compose"] .card[data-cx="compose"]{ display:block; }




/* === MF:UI: Theme-dynamic glow borders (Lite-safe) === */
body[data-glass="clear"] .shell,
body[data-glass="clear"] .panel,
body[data-glass="clear"] .pane{
  box-shadow:
    0 0 0 1px rgba(255,255,255,.06),
    0 0 26px rgba(var(--accentRGB), .10),
    0 0 42px rgba(var(--accent2RGB), .07);
}

.phone-wrap{
  /* phone stays solid; glow lives on the outer shell */
  filter: none !important;
}
.phone-wrap::before{
  box-shadow:
    0 26px 90px rgba(0,0,0,.62),
    0 10px 30px rgba(0,0,0,.34),
    0 0 28px rgba(var(--accentRGB), .18),
    0 0 48px rgba(var(--accent2RGB), .12),
    inset 0 0 0 1px rgba(0,0,0,.65),
    inset 0 0 0 1px rgba(255,255,255,.10),
    inset 0 14px 26px rgba(255,255,255,.04),
    inset 0 -24px 44px rgba(0,0,0,.55) !important;
}

/* optional: a tiny focus glow on active inputs (keeps Classic cue) */
.editor-box:focus-within{
  box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 0 18px rgba(var(--accentRGB), .10);
}


/* ---------------------------------------------------------------------
   D-4D — Inline Flagging Overlay (Lite-safe)
   - Highlights UK/US + Jargon matches inside Agent Draft without contenteditable
   - Uses a mirrored overlay layer + perf guards
--------------------------------------------------------------------- */
.editor-box.agent-box{ position:relative; }
.editor-box.agent-box textarea{ position:relative; z-index:2; }

.ta-overlay{
  position:absolute;
  inset:0;
  /* IMPORTANT: metrics are dynamically synced from the textarea in JS (trust-pass). */
  padding:12px 46px 12px 12px; /* fallback if JS sync fails */
  font: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  white-space:pre-wrap;
  word-wrap:break-word;
  overflow:auto;
  pointer-events:none;
  user-select:none;
  z-index:1;
  color:transparent; /* hide mirrored text; show highlight styling only */
}
.ta-overlay::-webkit-scrollbar{ width:0; height:0; }
.ta-overlay{ scrollbar-width:none; }

.ta-overlay .hl{
  padding:0;
  border-radius:4px;
  outline: 1px solid rgba(255,255,255,0.05);
}


.ta-overlay .hl-jargon{
  background: rgba(255, 162, 92, 0.08);
  box-shadow: inset 0 -1px 0 rgba(255, 162, 92, 0.62);
}
.ta-overlay .hl-ukus{
  background: rgba(120, 210, 255, 0.07);
  box-shadow: inset 0 -1px 0 rgba(120, 210, 255, 0.52);
}

@keyframes mfPulseFlash{
  0%{ transform: translateZ(0) scale(1); filter: brightness(1.05); }
  45%{ transform: translateZ(0) scale(1.005); filter: brightness(1.20); }
  100%{ transform: translateZ(0) scale(1); filter: brightness(1.05); }
}
.ta-overlay .hl-focus{
  /* Stronger active state (trust polish) */
  background: rgba(255,255,255,0.06);
  box-shadow:
    inset 0 -2px 0 rgba(255, 255, 255, 0.85),
    0 0 0 1px rgba(255, 255, 255, 0.18),
    0 10px 26px rgba(0,0,0,0.28);
  animation: mfPulseFlash 720ms ease-out 1;
}


.ta-tip{
  position:absolute;
  left:12px;
  bottom:10px; /* fallback position; JS will anchor near the highlighted range */
  top:auto;
  max-width: calc(100% - 70px);
  padding:8px 10px;
  border-radius:12px;
  background: linear-gradient(180deg, rgba(20,26,34,0.96), rgba(12,16,22,0.96));
  border: 1px solid rgba(255,255,255,0.16);
  -webkit-color: rgba(255,255,255,0.92);
  font-size:12px;
  line-height:1.25;
  z-index:3;
  pointer-events:auto;
  opacity:0;
  transform: translateY(6px);
  transition: opacity .16s ease, transform .16s ease;
}
.ta-tip[data-show="true"]{ opacity:1; transform: translateY(0); }
.ta-tip:not([data-show="true"]){ pointer-events:none; }
.ta-tip .actions{
  margin-top:8px;
  display:flex;
  gap:8px;
  align-items:center;
}
.ta-tip .tip-btn{
  padding:5px 10px;
  border-radius:999px;
  font-size:11px;
  line-height:1;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  color: rgba(255,255,255,0.92);
  cursor:pointer;
}
.ta-tip .tip-btn:hover{ border-color: rgba(255,255,255,0.24); background: rgba(255,255,255,0.10); }
.ta-tip .tip-btn:disabled{
  opacity:.45;
  cursor:not-allowed;
}
.ta-tip .pill{
  display:inline-flex; align-items:center; gap:6px;
  padding:2px 8px;
  border-radius:999px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.10);
  margin-right:6px;
}
.ta-tip .k{ opacity:.82; }
.ta-tip .v{ font-weight:600; }

.issue.is-flash{
  outline: 1px solid rgba(255,255,255,0.26);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.12), 0 14px 40px rgba(0,0,0,0.28);
  animation: mfPulseFlash 720ms ease-out 1;
}




/* === Option B: Experience tab structure tightening (Customer signals) === */
.sig-wrap{display:flex;flex-direction:column;gap:10px}
.sig-intro{padding:8px 10px;border:1px dashed var(--stroke2);border-radius:14px;color:var(--muted);font-size:12px;letter-spacing:.2px}
.sig-group{display:flex;flex-direction:column;gap:6px}
.sig-head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border:1px solid var(--stroke2);border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02))}
.sig-head .label{font-weight:700;font-size:12px;letter-spacing:.35px;text-transform:uppercase;color:var(--text)}
.sig-head .count{font-size:12px;color:var(--muted)}
.sig-empty{padding:6px 10px;color:var(--muted);font-size:13px}


/* === OPAQUE PANELS OVERRIDE (Lite-safe) === */
/* Phone must be fully opaque */
.phone,
.phone * {
  background-color: rgba(15, 18, 30, 1) !important;
  backdrop-filter: none !important;
}

/* Agent + Customer text areas fully opaque */
textarea,
.editor textarea,
.customer textarea,
.agent textarea {
  background-color: rgba(20, 24, 38, 1) !important;
  backdrop-filter: none !important;
}

/* Message bubbles fully opaque */
.phone .bubble,
.phone .message,
.phone .msg {
  background-color: rgba(32, 36, 54, 1) !important;
  backdrop-filter: none !important;
}

/* Input bar fully opaque */
.phone .input,
.phone .composer,
.phone footer {
  background-color: rgba(18, 22, 36, 1) !important;
  backdrop-filter: none !important;
}



/* MFCX Writer/Experience pack UI */
.mf-sec{ margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08); }
.mf-sec-head{ font-size:11px; font-weight:750; letter-spacing:.02em; color:rgba(235,245,255,.86); margin:0 0 8px 0; }
.mf-actions{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
.mf-chiprow{ display:flex; flex-wrap:wrap; gap:8px; padding:8px 0; }
.mf-chip{ text-align:left; max-width:100%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

.mf-block{ margin-top:10px; border:1px solid rgba(255,255,255,.10); border-radius:14px; background:rgba(0,0,0,.12); padding:8px 10px; }
.mf-block-sum{ cursor:pointer; font-weight:700; font-size:11px; color:rgba(235,245,255,.90); }
.mf-block-meta{ margin-top:6px; font-size:11px; color:rgba(235,245,255,.62); }
.mf-pre{ margin:10px 0 0; padding:10px; border-radius:12px; background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08);
  font-size:11px; line-height:1.35; color:rgba(235,245,255,.80); white-space:pre-wrap; }

.mf-pick .v{ opacity:.95; }

.mf-exp-card{ margin-top:10px; padding:10px; border-radius:14px; background:rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.10); }
.mf-exp-title{ font-size:11px; font-weight:800; margin-bottom:4px; }
.mf-exp-why{ font-size:11px; color:rgba(235,245,255,.72); line-height:1.3; }
.mf-exp-next{ margin:8px 0 0 16px; padding:0; color:rgba(235,245,255,.72); font-size:11px; }
.mf-tier{ margin-top:10px; padding:10px; border-radius:14px; background:rgba(0,0,0,.10); border:1px solid rgba(255,255,255,.08); }
.mf-tier-label{ font-size:11px; font-weight:750; margin-bottom:6px; color:rgba(235,245,255,.82); }


/* ---------- Compose (CX tab) ---------- */
.badge{
  display:inline-flex; align-items:center; justify-content:center;
  min-width:18px; height:18px; padding:0 6px; margin-left:8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.07);
  color: rgba(235,245,255,.92);
  font-size:11px; font-weight:800; line-height:1;
}
.pill.chipbtn{
  cursor:pointer;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: rgba(235,245,255,.88);
  font-size:11px;
  padding:5px 8px;
}
.pill.chipbtn:hover{ background: rgba(255,255,255,.09); }
.pill.chipbtn b{ font-weight:800; }

.compose-wrap{ display:flex; flex-direction:column; gap:10px; }
.compose-actions{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom:6px; }
.compose-empty{ color: rgba(235,245,255,.62); font-size: 12px; padding: 8px 0; }
.compose-preview-label{
  font-size:11px; letter-spacing:.06em; text-transform:uppercase;
  color: rgba(235,245,255,.62); margin: 8px 0 6px;
}
.compose-row{
  padding:8px; border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.10);
}
.compose-row .sub{ font-size:11px; color: rgba(235,245,255,.62); margin-top:2px; }
.compose-row .text{ font-size:12px; color: rgba(235,245,255,.78); margin-top:6px; white-space:pre-wrap; line-height:1.35; }
.compose-row .tools{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
</style>
</head>
<body data-bgmode="stars" data-colour="crown" data-focus="none" data-glass="frosted" data-motion="off" data-pattern="dots" data-poly="none" data-theme="lunar">
<div class="bg-fx"><div aria-hidden="true" class="mf-pattern"></div><div aria-hidden="true" class="mf-vignette"></div></div>
<canvas aria-hidden="true" id="bgParticles"></canvas>
<div class="app">
<div aria-label="MirrorFlow 2.0 P0→P1" class="tri" role="application">
<!-- DRAFT -->
<section aria-label="Editor+" class="panel" data-panel="draft">
<div class="panel-header">
<div class="panel-title">
<span aria-hidden="true" class="dot"></span>
            Editor+
          </div>
<div class="chips">
<button aria-label="Exit focus mode" class="btn focus-exit" id="exitFocusBtnDraft" type="button">Exit focus</button>
<button aria-label="Focus the agent draft" class="iconbtn focusicon" id="focusEditorBtn" title="Focus editor" type="button"><svg aria-hidden="true" fill="none" height="16" viewbox="0 0 24 24" width="16"><path d="M9 5H5v4M15 19h4v-4M5 15v4h4M19 9V5h-4" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg><span class="sr-only">Focus editor</span></button>
</div>
</div>
<div class="panel-body">
<div class="stack">
<!-- Customer input -->
<div class="customerBlock">
<label for="customerMsg">Customer message</label>
<div aria-label="Customer message box" class="editor-box customer-box">
<textarea id="customerMsg" placeholder="Hi, I need help with my claim." rows="3"></textarea>
<button aria-label="Add customer message to phone" class="embedded-send" id="addCustomerBtn" type="button">
<svg fill="none" height="16" viewbox="0 0 24 24" width="16">
<path d="M3 11.5L21 3l-8.5 18-1.8-7.1L3 11.5z" stroke="currentColor" stroke-linejoin="round" stroke-width="1.8"></path>
</svg>
</button>
</div>
<div class="hint">
                Tip: <span class="kbd">Ctrl</span> + <span class="kbd">Enter</span> adds the customer message.
              </div>
</div>
<!-- Toolbar -->
<div class="toolbarWrap draftToolbarBlock">
<div aria-label="Draft toolbar" class="classic-toolbar compact2" id="draftToolbar" role="toolbar">
<button class="pillbtn orange" id="btnClean" title="Clean (trim + tidy whitespace)" type="button">Clean</button>
<button class="pillbtn danger" id="clearBtn" title="Clear transcript + drafts" type="button">CLEAR</button>
<button class="pillbtn" id="copyBtn" title="Copy agent draft" type="button">COPY</button>
<button class="pillbtn" id="pasteBtn" title="Paste into agent draft" type="button">PASTE</button>
<span aria-hidden="true" class="pillbtn mini pink miniStat miniStat--jargon" style="display:none">Jargon <b id="jargonCount">0</b></span>
<span aria-hidden="true" class="vsep"></span>
<button class="pillbtn icononly" id="btnBold" title="Bold (wrap selection in ** **)" type="button"><b>B</b></button>
<button class="pillbtn icononly" id="btnItalic" title="Italic (wrap selection in * *)" type="button"><i>I</i></button>
<button class="pillbtn icononly" id="btnUnderline" title="Underline (wrap selection in __ __)" type="button"><u>U</u></button>
<button class="pillbtn icononly" id="btnBullets" title="Bullets" type="button">•</button>
<span aria-hidden="true" class="vsep"></span>
<button class="pillbtn" id="btnReplies" title="Insert a quick reply" type="button">REPLIES <span class="caret">▼</span></button>
<button class="pillbtn" id="btnPhrases" title="Insert a phrase" type="button">PHRASES <span class="caret">▼</span></button>
<span aria-hidden="true" class="vsep"></span>
<!-- Pinned tools render here (row 2, max 2 rows total) -->
<span aria-label="Pinned tools" class="pinnedSlot" id="pinnedToolsSlot"></span>
<span aria-label="Word count" class="pillbtn wordpill" id="toolbarWordPill" title="Word count of agent draft"><strong id="wordCount">0</strong> words</span>
<button class="pillbtn icononly" id="btnToolPocket" title="Customize toolbar" type="button">✎</button>
</div>
<div class="toolPocket" hidden="" id="toolPocket">
<div class="toolPocketHead">
<div class="toolPocketTitle">Toolbar tools</div>
<button class="pillbtn" id="btnPocketReset" title="Reset pins" type="button">Reset</button>
<button class="pillbtn" id="btnPocketDone" type="button">Done</button>
</div>
<div class="toolPocketGrid" id="toolPocketGrid"></div>
<div class="toolPocketHint">Pin tools to show them (max 2 toolbar rows). Staples stay fixed.</div>
</div>
<!-- Hidden bin: optional tools live here until pinned -->
<div hidden="" id="toolBin">
<button class="pillbtn icononly" id="btnStrike" title="Strikethrough (wrap selection in ~~ ~~)" type="button"><s>S</s></button>
<button class="pillbtn icononly" id="btnQuote" title="Quote (prefix lines with &gt; )" type="button">❝</button>
<button class="pillbtn icononly" id="btnChecklist" title="Checklist (prefix lines with - [ ] )" type="button">☐</button>
<button class="pillbtn icononly" id="btnCode" title="Inline code (wrap selection in ` `)" type="button">&lt;/&gt;</button>
<button class="pillbtn icononly" id="btnLink" title="Insert link" type="button">🔗</button>
<button class="pillbtn icononly" id="btnIndent" title="Indent lines" type="button">⇥</button>
<button class="pillbtn icononly" id="btnOutdent" title="Outdent lines" type="button">⇤</button>
<button class="pillbtn icononly" id="btnUndo" title="Undo" type="button">↺</button>
<button class="pillbtn icononly" id="btnRedo" title="Redo" type="button">↻</button>
</div>
</div>
<!-- Agent draft -->
<div class="agentBlock">
<label for="agentDraft">Agent draft</label>
<div aria-label="Agent draft box" class="editor-box agent-box">
<div aria-hidden="true" class="ta-overlay" id="agentDraftOverlay"></div>
<div aria-hidden="true" class="ta-tip" id="agentDraftTip"></div>
<textarea id="agentDraft" placeholder="Hi,
Thanks for reaching out, how can I help?" rows="12"></textarea>
<button aria-label="Send agent message to phone" class="embedded-send" id="sendAgentBtn" type="button">
<svg fill="none" height="16" viewbox="0 0 24 24" width="16">
<path d="M3 11.5L21 3l-8.5 18-1.8-7.1L3 11.5z" stroke="currentColor" stroke-linejoin="round" stroke-width="1.8"></path>
</svg>
</button>
</div>
<div class="hint">
<span class="kbd">Ctrl</span> + <span class="kbd">Enter</span> = Send • <span class="kbd">Shift</span> + <span class="kbd">Enter</span> = New line
              </div>
</div>
<div aria-label="Utilities hub" class="utilitiesHub">
<div class="utilitiesTitle">Utilities</div>
<div aria-label="Theme bar" class="utilities-bar">
<div aria-label="Utilities row 1" class="utilities-row row1">
<div aria-label="Mode switch" class="modeswitch" role="group">
<button aria-label="Set SOL mode" data-active="true" id="modeSol" type="button"><svg aria-hidden="true" fill="none" height="14" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" viewbox="0 0 24 24" width="14"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="M6.34 17.66l-1.41 1.41"></path><path d="M19.07 4.93l-1.41 1.41"></path></svg><span class="sr-only">SOL</span></button>
<button aria-label="Set LUNAR mode" data-active="false" id="modeLunar" type="button"><svg aria-hidden="true" fill="none" height="14" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" viewbox="0 0 24 24" width="14"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg><span class="sr-only">LUNAR</span></button>
</div>
<button class="iconbtn" id="diceBtn" title="Shuffle SKY (random colourway)" type="button">
<svg fill="none" height="16" viewbox="0 0 24 24" width="16">
<path d="M7 3h10a4 4 0 0 1 4 4v10a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V7a4 4 0 0 1 4-4z" stroke="currentColor" stroke-width="1.6"></path>
<path d="M8.5 8.5h.01M15.5 8.5h.01M12 12h.01M8.5 15.5h.01M15.5 15.5h.01" stroke="currentColor" stroke-linecap="round" stroke-width="2.4"></path>
</svg>
</button>
<button aria-label="Toggle animations" aria-pressed="false" class="iconbtn" id="fxBtn" title="Animations: OFF" type="button">
<svg aria-hidden="true" fill="none" height="16" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" viewbox="0 0 24 24" width="16">
<path d="M12 2l1.6 5.2L19 9l-5.4 1.8L12 16l-1.6-5.2L5 9l5.4-1.8L12 2z"></path>
<path d="M5 14l.9 2.8L9 18l-3.1 1.2L5 22l-.9-2.8L1 18l3.1-1.2L5 14z"></path>
</svg>
</button>
<button aria-label="Toggle live preview" aria-pressed="true" class="iconbtn" id="previewToggle" title="Preview: ON" type="button">
<svg aria-hidden="true" fill="none" height="16" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" viewbox="0 0 24 24" width="16">
<path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7S2 12 2 12z"></path>
<circle cx="12" cy="12" r="3"></circle>
</svg>
<span class="sr-only">Preview <span id="previewState">ON</span></span>
</button>
<button aria-label="Toggle glass clarity" aria-pressed="false" class="iconbtn" id="glassToggle" title="Glass: Frosted" type="button">
<svg aria-hidden="true" fill="none" height="16" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" viewbox="0 0 24 24" width="16">
<path d="M3 7h18"></path>
<path d="M6 7l1.2 14h9.6L18 7"></path>
<path d="M9 7V5a3 3 0 0 1 6 0v2"></path>
</svg>
<span class="sr-only">Glass <span id="glassState">Frosted</span></span>
</button>
</div>
<div aria-label="Utilities row 2" class="utilities-row row2">
<!-- Lite-safe utilities: CSS :target popups (no engine JS dependency) -->
<a class="pillbtn vh util-pill" href="#modal-how" id="howLink" role="button" title="How MirrorFlow works + shortcuts">How it works</a>
<a class="pillbtn vh util-pill" href="#modal-dict" id="dictLink" role="button" title="Open dictionaries">Dictionaries</a>
<a class="pillbtn vh util-pill" href="#modal-dev" id="devLink" role="button" title="Dev Lab: manage hidden/ignored lists">Dev Lab</a>
<button class="pillbtn vh checker-pill" id="checkerBtn" title="Toggle counters on/off" type="button">CHECKER: <span id="checkerState">ON</span></button>
<div aria-label="Sky colourways" class="swatches">
<button aria-label="Colourway 1" class="swatch" id="sw0" type="button"></button>
<button aria-label="Colourway 2" class="swatch" id="sw1" type="button"></button>
<button aria-label="Colourway 3" class="swatch" id="sw2" type="button"></button>
<button aria-label="Colourway 4" class="swatch" id="sw3" type="button"></button>
</div>
<span class="mini themeLabel" id="themeLabel" title="Current theme">Skyglass</span>
</div>
</div>
<div aria-label="Phone text size controls" class="textsize">
<span class="label">Text size</span>
<button aria-label="Small text" class="tsbtn" data-size="0" id="ts0" type="button">A</button>
<button aria-label="Normal text" class="tsbtn" data-size="1" id="ts1" type="button">A</button>
<button aria-label="Large text" class="tsbtn" data-size="2" id="ts2" type="button">A</button>
<button aria-label="Extra large text" class="tsbtn" data-size="3" id="ts3" type="button">A</button>
</div>
</div>
</div>
</div>
</section>
<!-- PHONE -->
<section aria-label="Portal+" class="panel" data-panel="phone">
<div class="panel-header portal-header">
<div class="panel-title">
<span aria-hidden="true" class="dot" style="background: var(--accent2); box-shadow: 0 0 0 3px rgba(185,139,255,.14);"></span>
            Portal+
          </div>
<div aria-label="App name" class="mf-appname">MirrorFlow</div>
<div class="chips">
<button aria-label="Exit focus mode" class="btn focus-exit" id="exitFocusBtnPhone" type="button">Exit focus</button>
<button aria-label="Focus the phone preview" class="iconbtn focusicon" id="focusPhoneBtn" title="Focus phone" type="button"><svg aria-hidden="true" fill="none" height="16" viewbox="0 0 24 24" width="16"><path d="M9 5H5v4M15 19h4v-4M5 15v4h4M19 9V5h-4" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg><span class="sr-only">Focus phone</span></button>
</div>
</div>
<div aria-label="Phone preview body" class="phone-panel-body">
<div aria-label="Phone frame" class="phone-wrap" data-shell="clean">
<div class="phone-inner">
<div aria-label="Status bar" class="statusbar">
<div class="status-left">
<span aria-label="Time" class="phone-time" id="timeNow">--:--</span>
<span aria-label="Online status" class="status-online">
<span aria-hidden="true" class="status-dot"></span>
<span class="status-text">Online</span>
</span>
</div>
<div aria-hidden="true" class="status-right">
<div aria-hidden="true" class="signal-bars"><span></span><span></span><span></span><span></span></div>
<div aria-hidden="true" class="battery"><div class="battery-level"></div></div>
</div>
</div>
<div aria-label="Chat header" class="chathead">
<div class="chathead-left">
<div aria-hidden="true" class="avatar">CS</div>
<div class="chatmeta">
<div class="title">Customer Support</div>
<div class="sub">Typically replies within an hour</div>
</div>
</div>
<div class="chathead-right">
<span aria-hidden="true" class="dotlive"></span>
<span id="chatCount">Interactions: 0</span>
</div>
</div>
<div aria-label="Chat transcript" class="chat" id="chatList"></div>
<div aria-label="Phone input bar" class="phone-input">
<div aria-label="Rolling agent tips" class="tipline" id="phoneTipline">
<span class="tip-text" id="agentTipTicker"></span>
</div>
<button aria-label="Next tip" class="send-dot" id="phoneSendBtn" type="button">
<svg fill="none" height="16" viewbox="0 0 24 24" width="16">
<path d="M3 11.5L21 3l-8.5 18-1.8-7.1L3 11.5z" stroke="currentColor" stroke-linejoin="round" stroke-width="1.8"></path>
</svg>
</button>
</div>
<div aria-label="Gesture safe area" class="gesture"></div>
</div>
</div>
</div>
</section>
<!-- INSIGHTS -->
<section aria-label="CX Insights" class="panel" data-cxmode="writer" data-panel="insights">
<div class="panel-header">
<div class="panel-title">
<span aria-hidden="true" class="dot" style="background:#FF74D4; box-shadow: 0 0 0 3px rgba(255,116,212,.14);"></span>
            CX Insights
          </div>
<div class="chips">
<span class="chip"><strong>P1b</strong> dock + phone fix</span>
</div>
</div>
<div class="panel-body">
<div aria-label="CX Insights modes" class="insights-modes" role="tablist">
<button aria-selected="true" class="chip chipbtn modebtn" data-cxmode="writer" id="cxTab_writer" role="tab" tabindex="0" type="button">Writer</button>
<button aria-selected="false" class="chip chipbtn modebtn" data-cxmode="ukus" id="cxTab_ukus" role="tab" tabindex="-1" type="button">UK/US</button>
<button aria-selected="false" class="chip chipbtn modebtn" data-cxmode="jargon" id="cxTab_jargon" role="tab" tabindex="-1" type="button">Jargon</button>
<button aria-selected="false" class="chip chipbtn modebtn" data-cxmode="experience" id="cxTab_experience" role="tab" tabindex="-1" type="button">Experience</button>
<button aria-selected="false" class="chip chipbtn modebtn" data-cxmode="compose" id="cxTab_compose" role="tab" tabindex="-1" type="button">Compose <span class="badge" id="composeCount">0</span></button>
</div>
<div class="cards">
<div aria-label="Writer insights" aria-labelledby="cxTab_writer" class="card" data-cx="writer" id="cxPanel_writer" role="tabpanel">
<div class="card-head">
<div class="mini-pills">
<span class="pill" title="US spellings detected">UK/US <b id="writerUKUSN">0</b></span>
<span class="pill" title="Character count in agent draft">Chars <b id="charCount">0</b></span>
<span class="pill" title="Jargon terms detected">Jargon <b id="writerJargonN">0</b></span>
<span class="pill" title="Clarity flags">Clarity <b id="writerClarityN">0</b></span>
<span class="pill" title="Tone flags">Tone <b id="writerToneN">0</b></span>
</div>
</div>
<div class="insight-body">
<div aria-live="polite" class="insight-list" id="writerList"></div>
</div>
</div><div aria-label="UK/US insights" class="card" data-cx="ukus"><div class="card-head"><div class="mini-pills"><span class="pill" title="US spellings detected">Issues <b id="writerUKUSN2">0</b></span><button class="btn-mini" id="btnUkusApplyAll" title="Apply all UK spellings in the draft" type="button">Apply all</button><button class="btn-mini" id="btnUkusJumpPrev" title="Jump to previous flag" type="button">◀</button><button class="btn-mini" id="btnUkusJumpNext" title="Jump to next flag" type="button">▶</button></div></div><div class="insight-body"><div aria-live="polite" class="insight-list" id="ukusList"></div></div></div><div aria-label="Jargon insights" class="card" data-cx="jargon"><div class="card-head"><div class="mini-pills"><span class="pill" title="Jargon terms detected">Issues <b id="writerJargonN2">0</b></span><button class="btn-mini" id="btnJargonJumpPrev" title="Jump to previous flag" type="button">◀</button><button class="btn-mini" id="btnJargonJumpNext" title="Jump to next flag" type="button">▶</button></div></div><div class="insight-body"><div aria-live="polite" class="insight-list" id="jargonList"></div></div></div>
<div aria-label="Experience insights" class="card" data-cx="experience">
<div class="card-head">
<div class="mini-pills">
<span class="pill" title="Mentions of money/costs/excess">Money <b id="expMoneyN">0</b></span>
<span class="pill" title="Signs of customer worry/pressure">Stress <b id="expStressN">0</b></span>
<span class="pill" title="Gentle vulnerability cues">Vuln <b id="expVulnN">0</b></span>
</div>
</div>
<div class="insight-body">
<div aria-live="polite" class="insight-list" id="expList"></div>
</div>
</div>
<div aria-label="Compose" aria-labelledby="cxTab_compose" class="card" data-cx="compose" hidden="" id="cxPanel_compose" role="tabpanel">
<div class="card-head">
<div class="mini-pills">
<span class="pill" title="Blocks queued in Compose">Blocks <b id="composeBlocksN">0</b></span>
<button aria-pressed="false" class="pill chipbtn" id="composeKeepToggle" title="Keep blocks after committing to draft" type="button">Keep <b id="composeKeepState">OFF</b></button>
</div>
</div>
<div class="insight-body">
<div id="composePanelMount"></div>
</div>
</div>
</div>
</div>
</section>
</div>
</div>
<script>
(() => {
  "use strict";

  // === MirrorFlow Engine Data (Classic export) — Phase 1 ===
  // Source of truth: mirrorflow_classic_all_ukus_jargon_export.json (embedded for offline use)
  const ENGINE_BUNDLE = {"meta": {"source": "MirrorFlow_Classic.html", "exportedAt": "2026-02-05T02:36:53.747795", "counts": {"jargon_rules": 81, "ukus_pairs_engine": 80, "jargon_dictionary": 14, "ukus_pairs_simple": 33}}, "engine": {"jargon_rules": [{"id": "jargon_001", "term": "NCD", "pattern": "\\bNCD\\b", "flags": "gi", "suggestion": "no claims discount (NCD)", "notes": "NCD = No Claims Discount – the discount you earn for claim-free years. Spell it out the first time you use it."}, {"id": "jargon_002", "term": "NCB", "pattern": "\\bNCB\\b", "flags": "gi", "suggestion": "no claims discount (also called no claims bonus)", "notes": "NCB = No Claims Bonus – another way of saying no claims discount. Explain briefly the first time."}, {"id": "jargon_003", "term": "FNOL", "pattern": "\\bFNOL\\b", "flags": "gi", "suggestion": "when you first told us about the incident", "notes": "FNOL = First Notification of Loss – internal shorthand. Avoid using the acronym with customers; describe the event instead."}, {"id": "jargon_004", "term": "QNOL", "pattern": "\\bQNOL\\b", "flags": "gi", "suggestion": "when you first told us about the incident", "notes": "QNOL = Quick Notification of Loss – internal shorthand. Avoid this term with customers; describe the process in normal language."}, {"id": "jargon_005", "term": "TPO", "pattern": "\\bTPO\\b", "flags": "gi", "suggestion": "third party only cover", "notes": "TPO = Third Party Only – cover for damage you cause to other people and their property. Briefly explain what is and isn’t covered."}, {"id": "jargon_006", "term": "TPFT", "pattern": "\\bTPFT\\b", "flags": "gi", "suggestion": "third party, fire and theft cover", "notes": "TPFT = Third Party, Fire and Theft – cover for others, plus fire and theft on your car. Spell it out at least once."}, {"id": "jargon_007", "term": "TPPD", "pattern": "\\bTPPD\\b", "flags": "gi", "suggestion": "damage to someone else’s property", "notes": "TPPD = Third Party Property Damage – damage to someone else’s property. Prefer the plain explanation."}, {"id": "jargon_008", "term": "jargon_8", "pattern": "\\bT\\/?L\\b", "flags": "gi", "suggestion": "total loss (written off)", "notes": "T/L = Total Loss – when the car is written off or uneconomical to repair. Add ‘written off’ or similar plain language."}, {"id": "jargon_009", "term": "LEI", "pattern": "\\bLEI\\b", "flags": "gi", "suggestion": "legal expenses cover", "notes": "LEI = Legal Expenses Insurance – cover for certain legal costs after an incident. Say ‘legal expenses cover’ and briefly explain what it helps with."}, {"id": "jargon_010", "term": "MLEI", "pattern": "\\bMLEI\\b", "flags": "gi", "suggestion": "motor legal expenses cover", "notes": "MLEI = Motor Legal Expenses Insurance – legal cover linked to a motor policy. Spell it out the first time."}, {"id": "jargon_011", "term": "PH", "pattern": "\\bPH\\b", "flags": "gi", "suggestion": "the policyholder", "notes": "PH = Policyholder – the person who owns the policy. With customers, say ‘you’ or ‘the policyholder’ rather than ‘PH’."}, {"id": "jargon_012", "term": "ND", "pattern": "\\bND\\b", "flags": "gi", "suggestion": "named driver", "notes": "ND = Named Driver – a driver listed on the policy who isn’t the main policyholder. Use ‘named driver’ in full."}, {"id": "jargon_013", "term": "TP", "pattern": "\\bTP\\b", "flags": "gi", "suggestion": "the other driver / the other person", "notes": "TP = Third Party – the other person involved in the incident. Say ‘the other driver’ or ‘the other person’ instead of ‘the TP’."}, {"id": "jargon_014", "term": "TPI", "pattern": "\\bTPI\\b", "flags": "gi", "suggestion": "the other driver’s insurer (TPI)", "notes": "TPI = Third Party Insurer – the other driver’s insurance company. Spell it out once, then you can shorten it."}, {"id": "jargon_015", "term": "V5C", "pattern": "\\bV5C\\b", "flags": "gi", "suggestion": "your V5C logbook (vehicle registration document)", "notes": "V5C is the vehicle registration document (logbook). Saying ‘V5C logbook’ once usually avoids confusion."}, {"id": "jargon_016", "term": "Cat", "pattern": "\\bCat(?:egory)?\\s*S\\b", "flags": "gi", "suggestion": "Category S (structural damage)", "notes": "Category S means structural damage. The vehicle can be repaired and returned to the road, but will be recorded as previously written off."}, {"id": "jargon_017", "term": "Cat", "pattern": "\\bCat(?:egory)?\\s*N\\b", "flags": "gi", "suggestion": "Category N (non‑structural damage)", "notes": "Category N means non‑structural damage. The vehicle can be repaired and returned to the road, but will be recorded as previously written off."}, {"id": "jargon_018", "term": "MTA", "pattern": "\\bMTA\\b", "flags": "gi", "suggestion": "a change to your policy (mid-term adjustment)", "notes": "MTA = Mid-Term Adjustment – a change made to the policy during the year. Spell it out at least once."}, {"id": "jargon_019", "term": "SOP", "pattern": "\\bSOP\\b", "flags": "gi", "suggestion": "our internal guidelines", "notes": "SOP = Standard Operating Procedure – our internal process guide. Avoid mentioning SOPs; explain the outcome, not the internal process."}, {"id": "jargon_020", "term": "MID", "pattern": "\\bMID\\b", "flags": "gi", "suggestion": "the Motor Insurance Database (MID)", "notes": "MID = Motor Insurance Database – the national database of insured vehicles. Say ‘the national Motor Insurance Database (MID)’ the first time."}, {"id": "jargon_021", "term": "VRN", "pattern": "\\bVRN\\b", "flags": "gi", "suggestion": "your car’s registration number (VRN)", "notes": "VRN = Vehicle Registration Number – the car’s number plate. Spell it out the first time."}, {"id": "jargon_022", "term": "DVLA", "pattern": "\\bDVLA\\b", "flags": "gi", "suggestion": "the DVLA (the UK body that looks after vehicle and driver records)", "notes": "DVLA = Driver and Vehicle Licensing Agency – the UK body that looks after vehicle and driver records. Add a short explanation once."}, {"id": "jargon_023", "term": "DPA", "pattern": "\\bDPA\\b", "flags": "gi", "suggestion": "data protection law (Data Protection Act)", "notes": "DPA = Data Protection Act – law that protects how we use personal data. Link it to ‘data protection law’ when mentioned."}, {"id": "jargon_024", "term": "CiVC", "pattern": "\\bCiVC\\b", "flags": "gi", "suggestion": "customers in vulnerable circumstances", "notes": "CiVC = Customers in Vulnerable Circumstances – internal label. Describe the support you can offer, not the internal flag name."}, {"id": "jargon_025", "term": "AMC", "pattern": "\\bAMC\\b", "flags": "gi", "suggestion": "our accident management company (who arrange repairs and hire cars)", "notes": "AMC = Accident Management Company – helps manage repairs, recovery and hire cars. Briefly explain who they are and what they do."}, {"id": "jargon_026", "term": "policyholder", "pattern": "\\bpolicyholder\\b", "flags": "gi", "suggestion": "policyholder (the person who owns the policy)", "notes": "Policyholder – the person who owns the insurance policy. Use ‘you’ where possible and ‘policyholder’ only when needed for clarity."}, {"id": "jargon_027", "term": "named", "pattern": "\\bnamed driver\\b", "flags": "gi", "suggestion": "named driver (someone listed on the policy who can drive the car)", "notes": "Named driver – someone listed on the policy who is allowed to drive the car but does not own the policy. Explain the difference from the main policyholder if it matters."}, {"id": "jargon_028", "term": "multi", "pattern": "\\bmulti[- ]car account\\b", "flags": "gi", "suggestion": "an account with more than one car or policy", "notes": "Multi car account – one account that holds more than one car or policy. Say ‘your account with more than one car/policy’."}, {"id": "jargon_029", "term": "comprehensive", "pattern": "\\bcomprehensive cover\\b", "flags": "gi", "suggestion": "comprehensive cover (the widest level of cover, including your own car)", "notes": "Comprehensive cover – the widest level of cover, usually including damage to your own car and others. Briefly list what is covered."}, {"id": "jargon_030", "term": "excess", "pattern": "\\bexcess\\b", "flags": "gi", "suggestion": "the first part of a claim you pay yourself (your excess)", "notes": "Excess – the first part of a claim you pay yourself. Say ‘the first £X of any claim, called your excess’."}, {"id": "jargon_031", "term": "premium", "pattern": "\\bpremium\\b", "flags": "gi", "suggestion": "your insurance price (premium)", "notes": "Premium – the price you pay for your insurance. You can say ‘your insurance price (premium)’ once, then ‘premium’ alone is fine."}, {"id": "jargon_032", "term": "endorsement", "pattern": "\\bendorsement\\b", "flags": "gi", "suggestion": "a special rule on your policy (called an endorsement)", "notes": "Endorsement – a special rule or change added to the policy. Prefer plain language and explain briefly."}, {"id": "jargon_033", "term": "exclusion", "pattern": "\\bexclusion\\b", "flags": "gi", "suggestion": "something your policy does not cover (an exclusion)", "notes": "Exclusion – something the policy does not cover. Add a short explanation of what is excluded."}, {"id": "jargon_034", "term": "fault", "pattern": "\\bfault claim\\b", "flags": "gi", "suggestion": "a claim where we can’t recover all costs from someone else’s insurer (fault claim)", "notes": "Fault claim – a claim where the insurer cannot recover all costs from someone else’s insurer. Explain that ‘fault’ is about who pays, not about blame."}, {"id": "jargon_035", "term": "non", "pattern": "\\bnon[- ]fault claim\\b", "flags": "gi", "suggestion": "a claim where we can recover costs from another insurer (non-fault claim)", "notes": "Non-fault claim – a claim where costs can be recovered from another insurer. Clarify that it can still affect price."}, {"id": "jargon_036", "term": "total", "pattern": "\\btotal loss\\b", "flags": "gi", "suggestion": "total loss (written off)", "notes": "Total loss / write-off – when the car is so badly damaged we pay its value instead of repairing it. Add ‘written off’ or similar."}, {"id": "jargon_037", "term": "write", "pattern": "\\bwrite[- ]off\\b", "flags": "gi", "suggestion": "written off (total loss)", "notes": "Write-off – common shorthand for a total loss. Make clear that we pay the car’s value instead of repairing it."}, {"id": "jargon_038", "term": "pre-accident", "pattern": "\\bpre-accident value\\b", "flags": "gi", "suggestion": "the value of your car just before the accident (pre-accident value)", "notes": "Pre-accident value – what the car was worth just before the incident. Spell this out in simple language."}, {"id": "jargon_039", "term": "settlement", "pattern": "\\bsettlement\\b", "flags": "gi", "suggestion": "the payment we make to you (settlement)", "notes": "Settlement – the amount paid to settle a claim. Say ‘the payment we make to you (settlement)’."}, {"id": "jargon_040", "term": "liability", "pattern": "\\bliability\\b", "flags": "gi", "suggestion": "who is legally responsible for the costs (liability)", "notes": "Liability – who is legally responsible for the costs of the incident. Explain it in that way."}, {"id": "jargon_041", "term": "indemnify", "pattern": "\\bindemnify\\b", "flags": "gi", "suggestion": "put you back, as closely as possible, in the position you were in before the loss", "notes": "Indemnify / indemnity – legal term for putting you back, as closely as possible, in the position you were in before the loss. Prefer the plain explanation."}, {"id": "jargon_042", "term": "indemnity", "pattern": "\\bindemnity\\b", "flags": "gi", "suggestion": "put you back, as closely as possible, in the position you were in before the loss", "notes": "Indemnity – legal term for putting you back in the position you were in before the loss. Prefer the plain explanation instead of the word."}, {"id": "jargon_043", "term": "underwriting", "pattern": "\\bunderwriting\\b", "flags": "gi", "suggestion": "our pricing and risk team (underwriting)", "notes": "Underwriting – how the insurer assesses risk and decides prices and terms for cover. Say ‘our pricing and risk team (underwriting)’ if you mention it."}, {"id": "jargon_044", "term": "wear", "pattern": "\\bwear and tear\\b", "flags": "gi", "suggestion": "natural wear and tear over time", "notes": "Wear and tear – natural ageing or deterioration of the vehicle over time. You can add a small example, e.g. tyres wearing down."}, {"id": "jargon_045", "term": "log", "pattern": "\\blog a claim\\b", "flags": "gi", "suggestion": "start a claim for you", "notes": "‘Log a claim’ is internal shorthand. Say ‘start a claim for you’ instead."}, {"id": "jargon_046", "term": "raise", "pattern": "\\braise a claim\\b", "flags": "gi", "suggestion": "open a claim for you", "notes": "‘Raise a claim’ is internal shorthand. Say ‘open a claim’ or ‘start a claim’ instead."}, {"id": "jargon_047", "term": "close", "pattern": "\\bclose the claim\\b", "flags": "gi", "suggestion": "finish working on your claim and close it on our system", "notes": "Internal process phrase. Explain that you’ll finish working on the claim and close it on the system."}, {"id": "jargon_048", "term": "reopen", "pattern": "\\breopen the claim\\b", "flags": "gi", "suggestion": "reopen your claim on our system", "notes": "Internal process phrase. Say ‘we can reopen your claim on our system if needed’."}, {"id": "jargon_049", "term": "claim", "pattern": "\\bclaim costs\\b", "flags": "gi", "suggestion": "the total amount we pay because of this claim", "notes": "Claim costs – internal phrase for the total amount paid because of the claim. Prefer a plainer explanation."}, {"id": "jargon_050", "term": "incident", "pattern": "\\bincident date\\b", "flags": "gi", "suggestion": "the date it happened (incident date)", "notes": "Incident date – internal term for the date the event happened. You can say ‘the date it happened (incident date)’."}, {"id": "jargon_051", "term": "third", "pattern": "\\bthird[- ]party vehicle\\b", "flags": "gi", "suggestion": "the other driver’s car", "notes": "Third-party vehicle – the other person’s car involved in the incident. Prefer ‘the other driver’s car’."}, {"id": "jargon_052", "term": "third", "pattern": "\\bthird[- ]party insurer\\b", "flags": "gi", "suggestion": "the other driver’s insurer", "notes": "Third-party insurer – the insurance company of the other person involved in the incident. Say ‘the other driver’s insurer’."}, {"id": "jargon_053", "term": "engineer", "pattern": "\\bengineer report\\b", "flags": "gi", "suggestion": "a vehicle engineer’s report about the damage", "notes": "Engineer report – report from a vehicle engineer assessing the damage and repair options. Explain it in simple terms."}, {"id": "jargon_054", "term": "recovery", "pattern": "\\brecovery department\\b", "flags": "gi", "suggestion": "our team that recovers costs from the other insurer", "notes": "Recovery department – the team that tries to claim money back from other insurers. Use plain language to describe them."}, {"id": "jargon_055", "term": "approved", "pattern": "\\bapproved repairer\\b", "flags": "gi", "suggestion": "a garage we’ve approved to do the repairs", "notes": "Approved repairer – a garage we’ve checked and agreed to work with. Make that clear to the customer."}, {"id": "jargon_056", "term": "own", "pattern": "\\bown repairer\\b", "flags": "gi", "suggestion": "a repairer you choose yourself", "notes": "Own repairer – a repairer the customer chooses themselves. Say ‘a repairer you choose yourself’."}, {"id": "jargon_057", "term": "escalat", "pattern": "\\bescalat(e|ion)\\b", "flags": "gi", "suggestion": "ask a specialist or manager to review this", "notes": "Escalate / escalation – internal wording for sending the case to a more senior or specialist team. Say ‘we’ll ask a specialist/manager to review this’."}, {"id": "jargon_058", "term": "claim", "pattern": "\\bclaim registration\\b", "flags": "gi", "suggestion": "setting up your claim on our system", "notes": "Claim registration – process of setting up the claim on the system. Explain this in plain English."}, {"id": "jargon_059", "term": "draft", "pattern": "\\bdraft claim\\b", "flags": "gi", "suggestion": "a claim that’s been started but not fully completed or submitted", "notes": "Draft claim – a claim started but not fully completed or submitted. Avoid the phrase; instead explain what’s missing or what happens next."}, {"id": "jargon_060", "term": "subrogation", "pattern": "\\bsubrogation\\b", "flags": "gi", "suggestion": "recovering costs from another insurer (subrogation)", "notes": "Subrogation – recovering costs from another insurer or party. Explain that we try to claim money back on your behalf."}, {"id": "jargon_061", "term": "uninsured", "pattern": "\\buninsured loss recovery\\b", "flags": "gi", "suggestion": "help recovering out-of-pocket costs (uninsured loss recovery)", "notes": "Uninsured loss recovery – cover that helps reclaim costs not covered by the main policy (excess, travel, etc.). Say this plainly."}, {"id": "jargon_062", "term": "credit", "pattern": "\\bcredit hire\\b", "flags": "gi", "suggestion": "a hire car provided on credit (credit hire)", "notes": "Credit hire – a replacement car provided on credit while costs are claimed back. Explain that it depends on recovery from another insurer."}, {"id": "jargon_063", "term": "credit", "pattern": "\\bcredit repair\\b", "flags": "gi", "suggestion": "repairs arranged on credit while we recover costs", "notes": "Credit repair – repairs arranged on credit while the insurer seeks recovery. Spell out that charges may depend on liability."}, {"id": "jargon_064", "term": "courtesy", "pattern": "\\bcourtesy car\\b", "flags": "gi", "suggestion": "a temporary car we provide while yours is repaired (courtesy car)", "notes": "Courtesy car – a temporary car while repairs happen. Clarify if it’s guaranteed, like-for-like, or subject to availability."}, {"id": "jargon_065", "term": "replacement", "pattern": "\\breplacement vehicle\\b", "flags": "gi", "suggestion": "a temporary hire car (replacement vehicle)", "notes": "Replacement vehicle – usually a hired car while yours is off the road. Say ‘temporary hire car’ and set expectations."}, {"id": "jargon_066", "term": "betterment", "pattern": "\\bbetterment\\b", "flags": "gi", "suggestion": "an improvement beyond pre-incident condition (betterment)", "notes": "Betterment – when a repair would leave the vehicle better than before. Explain any customer contribution clearly."}, {"id": "jargon_067", "term": "diminution", "pattern": "\\bdiminution of value\\b", "flags": "gi", "suggestion": "any loss in value after repairs (diminution of value)", "notes": "Diminution of value – potential drop in value after repairs. Explain simply and state if the policy covers it."}, {"id": "jargon_068", "term": "salvage", "pattern": "\\bsalvage\\b", "flags": "gi", "suggestion": "what happens to the vehicle after a write-off (salvage)", "notes": "Salvage – what happens to the vehicle after a write-off. Explain options (we keep it, or you keep it with a reduced payout)."}, {"id": "jargon_069", "term": "schedule", "pattern": "\\bschedule of insurance\\b", "flags": "gi", "suggestion": "your policy schedule (summary of cover)", "notes": "Schedule of insurance – the document that summarises cover, limits and endorsements. Say ‘your policy schedule’ and what it shows."}, {"id": "jargon_070", "term": "certificate", "pattern": "\\bcertificate of (motor )?insurance\\b", "flags": "gi", "suggestion": "your certificate of insurance (proof you’re insured)", "notes": "Certificate of insurance – proof that you’re insured. Mention it’s your evidence of cover, often needed for authorities."}, {"id": "jargon_071", "term": "policy", "pattern": "\\bpolicy schedule\\b", "flags": "gi", "suggestion": "your policy schedule (summary of what’s covered)", "notes": "Policy schedule – summary of what’s covered, limits and endorsements. Use plain wording about what it lists."}, {"id": "jargon_072", "term": "renewal", "pattern": "\\brenewal (notice|invite)?\\b", "flags": "gi", "suggestion": "your renewal notice (offer for the next year)", "notes": "Renewal notice/invite – the offer for next year’s cover. Say it’s the renewal offer and call out key changes."}, {"id": "jargon_073", "term": "lapse", "pattern": "\\blapse(d)? policy\\b", "flags": "gi", "suggestion": "a policy that has ended because it wasn’t renewed", "notes": "Lapsed policy – a policy that ended because it wasn’t renewed. State that cover stops after the lapse date."}, {"id": "jargon_074", "term": "no", "pattern": "\\bno claims (bonus|discount) protection\\b", "flags": "gi", "suggestion": "protection for your no claims discount", "notes": "No claims bonus/discount protection – cover that shields your discount after certain claims. Explain limits and when it applies."}, {"id": "jargon_075", "term": "excess", "pattern": "\\bexcess protection\\b", "flags": "gi", "suggestion": "cover that refunds your excess after a claim", "notes": "Excess protection – cover that can refund the excess after a claim (subject to terms). Spell that out in plain language."}, {"id": "jargon_076", "term": "personal", "pattern": "\\bpersonal accident cover\\b", "flags": "gi", "suggestion": "personal accident cover (a payout for certain injuries)", "notes": "Personal accident cover – pays a set amount for certain injuries. Briefly note what types of injuries/events are covered."}, {"id": "jargon_077", "term": "public", "pattern": "\\bpublic liability\\b", "flags": "gi", "suggestion": "public liability cover (injury or damage to others)", "notes": "Public liability – cover for injury or damage to other people or property. Phrase it that way for clarity."}, {"id": "jargon_078", "term": "product", "pattern": "\\bproduct liability\\b", "flags": "gi", "suggestion": "product liability cover (if a product causes harm)", "notes": "Product liability – cover if a product you supply causes injury or damage. Explain it plainly."}, {"id": "jargon_079", "term": "professional", "pattern": "\\bprofessional indemnity\\b", "flags": "gi", "suggestion": "professional indemnity cover (for mistakes in your work)", "notes": "Professional indemnity – cover for mistakes in professional work that cause loss. Explain in simple terms."}, {"id": "jargon_080", "term": "business", "pattern": "\\bbusiness interruption\\b", "flags": "gi", "suggestion": "business interruption cover (lost income if you can’t trade)", "notes": "Business interruption – cover for lost income if you cannot trade after an insured event. Say it in plain language."}, {"id": "jargon_081", "term": "cooling", "pattern": "\\bcooling[- ]off period\\b", "flags": "gi", "suggestion": "the time you can cancel shortly after buying", "notes": "Cooling-off period – the short window when you can cancel after buying. State the number of days and any fees."}], "ukus_pairs": [{"id": "ukus_realise_realize", "uk": "realise", "us": "realize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_realisation_realization", "uk": "realisation", "us": "realization", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_recognise_recognize", "uk": "recognise", "us": "recognize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_authorise_authorize", "uk": "authorise", "us": "authorize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_apologise_apologize", "uk": "apologise", "us": "apologize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_specialise_specialize", "uk": "specialise", "us": "specialize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_capitalise_capitalize", "uk": "capitalise", "us": "capitalize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_organise_organize", "uk": "organise", "us": "organize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_finalise_finalize", "uk": "finalise", "us": "finalize", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_analyse_analyze", "uk": "analyse", "us": "analyze", "type": "ise/ize", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_colour_color", "uk": "colour", "us": "color", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_flavour_flavor", "uk": "flavour", "us": "flavor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_honour_honor", "uk": "honour", "us": "honor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_labour_labor", "uk": "labour", "us": "labor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_valour_valor", "uk": "valour", "us": "valor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_favour_favor", "uk": "favour", "us": "favor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_behaviour_behavior", "uk": "behaviour", "us": "behavior", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_neighbour_neighbor", "uk": "neighbour", "us": "neighbor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_odour_odor", "uk": "odour", "us": "odor", "type": "our/or", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_travelling_traveling", "uk": "travelling", "us": "traveling", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_travelled_traveled", "uk": "travelled", "us": "traveled", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_cancelled_canceled", "uk": "cancelled", "us": "canceled", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_counselling_counseling", "uk": "counselling", "us": "counseling", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_revelled_reveled", "uk": "revelled", "us": "reveled", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_enrolment_enrollment", "uk": "enrolment", "us": "enrollment", "type": "double-l", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_centre_center", "uk": "centre", "us": "center", "type": "re/er", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_metre_meter", "uk": "metre", "us": "meter", "type": "re/er", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_theatre_theater", "uk": "theatre", "us": "theater", "type": "re/er", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_defence_defense", "uk": "defence", "us": "defense", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_licence_license", "uk": "licence", "us": "license", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_offence_offense", "uk": "offence", "us": "offense", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_cheque_check", "uk": "cheque", "us": "check", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_aeroplane_airplane", "uk": "aeroplane", "us": "airplane", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_tyre_tire", "uk": "tyre", "us": "tire", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_grey_gray", "uk": "grey", "us": "gray", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_kerb_curb", "uk": "kerb", "us": "curb", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_programme_program", "uk": "programme", "us": "program", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_catalogue_catalog", "uk": "catalogue", "us": "catalog", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_aluminium_aluminum", "uk": "aluminium", "us": "aluminum", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_mould_mold", "uk": "mould", "us": "mold", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_focussed_focused", "uk": "focussed", "us": "focused", "type": "variants", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_focussing_focusing", "uk": "focussing", "us": "focusing", "type": "variants", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_modelled_modeled", "uk": "modelled", "us": "modeled", "type": "variants", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_modelling_modeling", "uk": "modelling", "us": "modeling", "type": "variants", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_repair_centre_repair_center", "uk": "repair centre", "us": "repair center", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_hire_car_rental_car", "uk": "hire car", "us": "rental car", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_petrol_gasoline", "uk": "petrol", "us": "gasoline", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_postcode_zip_code", "uk": "postcode", "us": "zip code", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_motorway_highway", "uk": "motorway", "us": "highway", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_roundabout_traffic_circle", "uk": "roundabout", "us": "traffic circle", "type": "claims-phrases", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_practise_practice_manual", "uk": "practise", "us": "practice", "type": "manual", "badge": "MANUAL", "notes": "Manual check - context sensitive"}, {"id": "ukus_licence_license_manual", "uk": "licence", "us": "license", "type": "manual", "badge": "MANUAL", "notes": "Manual check - noun vs verb"}, {"id": "ukus_defence_defense_manual", "uk": "defence", "us": "defense", "type": "manual", "badge": "MANUAL", "notes": "Manual check - context sensitive"}, {"id": "ukus_programme_program_manual", "uk": "programme", "us": "program", "type": "manual", "badge": "MANUAL", "notes": "Manual check - TV vs software"}, {"id": "ukus_litre_liter", "uk": "litre", "us": "liter", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_fibre_fiber", "uk": "fibre", "us": "fiber", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_jewellery_jewelry", "uk": "jewellery", "us": "jewelry", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_manoeuvre_maneuver", "uk": "manoeuvre", "us": "maneuver", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_plough_plow", "uk": "plough", "us": "plow", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_ageing_aging", "uk": "ageing", "us": "aging", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_cosy_cozy", "uk": "cosy", "us": "cozy", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_learnt_learned", "uk": "learnt", "us": "learned", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_spelt_spelled", "uk": "spelt", "us": "spelled", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_dreamt_dreamed", "uk": "dreamt", "us": "dreamed", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_burnt_burned", "uk": "burnt", "us": "burned", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_smelt_smelled", "uk": "smelt", "us": "smelled", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_leapt_leaped", "uk": "leapt", "us": "leaped", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_fitted_fit", "uk": "fitted", "us": "fit", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_got_gotten", "uk": "got", "us": "gotten", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_whilst_while", "uk": "whilst", "us": "while", "type": "misc", "badge": "AUTO", "notes": "Engine canonical UK->US pair"}, {"id": "ukus_favourite_favorite", "uk": "favourite", "us": "favorite", "type": "our/or", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_favourites_favorites", "uk": "favourites", "us": "favorites", "type": "our/or", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_jewellery_jewelry2", "uk": "jewellery", "us": "jewelry", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_manoeuvre_maneuver2", "uk": "manoeuvre", "us": "maneuver", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_dialogue_dialog", "uk": "dialogue", "us": "dialog", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_catalogue_catalog", "uk": "catalogue", "us": "catalog", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_analogue_analog", "uk": "analogue", "us": "analog", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_prologue_prolog", "uk": "prologue", "us": "prolog", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_monologue_monolog", "uk": "monologue", "us": "monolog", "type": "misc", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}, {"id": "ukus_sombrE_somber", "uk": "sombre", "us": "somber", "type": "re/er", "badge": "AUTO", "notes": "Expanded canonical UK->US pair"}]}, "legacy_ui_lists": {"jargon_dictionary": [{"term": "Claimant", "severity": "HIGH", "expansion": "The person making a claim under an insurance policy.", "notes": "Used in all claim-based scenarios.", "examples": ["The claimant reported the incident to the insurer."]}, {"term": "Policyholder", "severity": "HIGH", "expansion": "The individual or entity that owns an insurance policy.", "notes": "Refers to the person or company who has purchased insurance coverage.", "examples": ["The policyholder is responsible for paying the premium."]}, {"term": "Premium", "severity": "HIGH", "expansion": "The amount paid for an insurance policy.", "notes": "Usually paid monthly or annually.", "examples": ["The premium for the car insurance was increased due to a claim."]}, {"term": "Excess", "severity": "MED", "expansion": "The amount the policyholder must pay before the insurance policy pays out.", "notes": "A higher excess typically lowers the premium.", "examples": ["The excess on this policy is £500."]}, {"term": "Indemnity", "severity": "HIGH", "expansion": "Compensation for damages or loss.", "notes": "Commonly used in liability insurance.", "examples": ["The insurance company offered indemnity for the damages caused during the accident."]}, {"term": "Liability", "severity": "HIGH", "expansion": "Responsibility for something, often involving legal responsibility.", "notes": "Typically refers to legal obligations to compensate for damage or injury.", "examples": ["The company assumed liability for the faulty product."]}, {"term": "Underwriting", "severity": "MED", "expansion": "The process of evaluating and approving insurance policies.", "notes": "Underwriters assess risk before issuing an insurance policy.", "examples": ["The underwriter approved the policy after assessing the applicant's risk profile."]}, {"term": "Coverage", "severity": "HIGH", "expansion": "The extent of protection provided by an insurance policy.", "notes": "Defines what is and isn’t covered under the policy.", "examples": ["The policy provides coverage for fire, theft, and vandalism."]}, {"term": "Claim", "severity": "HIGH", "expansion": "A request for payment under an insurance policy.", "notes": "The formal process of asking the insurance company to compensate for a loss.", "examples": ["The homeowner filed a claim after the storm caused significant damage."]}, {"term": "Deductible", "severity": "MED", "expansion": "The amount the insured must pay before the insurance policy pays out.", "notes": "A higher deductible can lower your premium but increases your out-of-pocket costs.", "examples": ["The deductible on the auto policy is $1,000."]}, {"term": "Surcharge", "severity": "MED", "expansion": "An additional charge added to the premium due to increased risk.", "notes": "Common with high-risk policies.", "examples": ["The insurer added a surcharge for the increased risk of flooding."]}, {"term": "Settlement", "severity": "HIGH", "expansion": "The process of resolving a claim, often through payment.", "notes": "May involve negotiations between the insurer and the policyholder.", "examples": ["The claim was settled for £5,000 after mediation."]}, {"term": "Recovery", "severity": "MED", "expansion": "The act of regaining something, like lost property or funds.", "notes": "Common in scenarios where property or money was lost.", "examples": ["The recovery of stolen goods was handled by the insurer."]}, {"term": "Loss Adjuster", "severity": "MED", "expansion": "A person who assesses the damage after an insurance claim.", "notes": "Loss adjusters determine the payout amount for a claim.", "examples": ["A loss adjuster will visit the property to assess the damage."]}], "ukus_pairs_simple": [{"uk": "realise", "us": "realize", "type": "ise/ize"}, {"uk": "organise", "us": "organize", "type": "ise/ize"}, {"uk": "recognise", "us": "recognize", "type": "ise/ize"}, {"uk": "analyses", "us": "analyze", "type": "ise/ize"}, {"uk": "maximise", "us": "maximize", "type": "ise/ize"}, {"uk": "theorise", "us": "theorize", "type": "ise/ize"}, {"uk": "authorise", "us": "authorize", "type": "ise/ize"}, {"uk": "realisation", "us": "realization", "type": "ise/ize"}, {"uk": "apologise", "us": "apologize", "type": "ise/ize"}, {"uk": "specialise", "us": "specialize", "type": "ise/ize"}, {"uk": "capitalise", "us": "capitalize", "type": "ise/ize"}, {"uk": "colour", "us": "color", "type": "our/or"}, {"uk": "flavour", "us": "flavor", "type": "our/or"}, {"uk": "honour", "us": "honor", "type": "our/or"}, {"uk": "labour", "us": "labor", "type": "our/or"}, {"uk": "valour", "us": "valor", "type": "our/or"}, {"uk": "favour", "us": "favor", "type": "our/or"}, {"uk": "behaviour", "us": "behavior", "type": "our/or"}, {"uk": "neighbour", "us": "neighbor", "type": "our/or"}, {"uk": "odour", "us": "odor", "type": "our/or"}, {"uk": "travelling", "us": "traveling", "type": "double-l"}, {"uk": "cancelled", "us": "canceled", "type": "double-l"}, {"uk": "counselling", "us": "counseling", "type": "double-l"}, {"uk": "revelled", "us": "reveled", "type": "double-l"}, {"uk": "enrolment", "us": "enrollment", "type": "double-l"}, {"uk": "defence", "us": "defense", "type": "misc"}, {"uk": "licence", "us": "license", "type": "misc"}, {"uk": "offence", "us": "offense", "type": "misc"}, {"uk": "cheque", "us": "check", "type": "misc"}, {"uk": "centre", "us": "center", "type": "misc"}, {"uk": "theatre", "us": "theater", "type": "misc"}, {"uk": "aeroplane", "us": "airplane", "type": "misc"}, {"uk": "tyre", "us": "tire", "type": "misc"}]}};
  // ===============================
  // MFCX LITE PACK (v1) — embedded
  // ===============================
  const MFCX_ENGINE_CONTRACT = {
    version: "mfcx-lite-engine-1.0",
    inputs: { customerText: "string", agentDraftText: "string", callNotesText: "string (optional)" },
    outputs: { writer: {}, experience: {} }
  };

  const MFCX_CONTENT = {
    version: "mfcx-lite-content-1.0",
    locale: "UK",
    power_phrases: {
      openers: [
        "Hi [name] — thanks for getting in touch.",
        "Hi [name] — I’m here to help.",
        "Thanks for the update, [name].",
        "Thanks for your patience, [name]."
      ],
      empathy: [
        "I can hear how frustrating this has been.",
        "I’m sorry this has been such a hassle.",
        "That’s completely understandable — I’d feel the same.",
        "I know this is stressful — I’ll keep this as clear and quick as I can."
      ],
      ownership: [
        "I’ll take ownership of this and keep you updated.",
        "Let me check this now and come back to you with the next step.",
        "I’ll make sure we move this forward today.",
        "I’ll confirm what’s happening and what you can expect next."
      ],
      clarifiers: [
        "Just to confirm — is the vehicle currently drivable and safe?",
        "Can you confirm the best contact number and availability today?",
        "Do you have any photos of the damage you can share?",
        "Can you confirm the date and location of the incident?"
      ],
      expectations: [
        "I’ll set out the next steps below so it’s easy to follow.",
        "I’ll keep updates to clear milestones — so you’re not left guessing.",
        "If anything changes, I’ll let you know straight away.",
        "I’ll confirm timelines once the garage/engineer has updated us."
      ],
      money_clarity: [
        "I’ll explain any costs clearly before anything is agreed.",
        "If an excess applies, I’ll confirm the amount and when it’s payable.",
        "I’ll break down what’s covered vs what isn’t in plain language.",
        "If there are options to reduce costs, I’ll outline them."
      ],
      closing: [
        "If you reply here with the details above, I’ll pick this up straight away.",
        "I’ll update you again by [time] today, even if it’s just to confirm progress.",
        "Anything else you’re worried about right now?"
      ]
    },
    reply_blocks: [
      {
        id: "rb_nextsteps_generic",
        title: "Next steps (generic)",
        tags: ["next-steps","structure"],
        text:
`Here’s what will happen next:

1) I’ll review the details and confirm cover.

2) If repairs are needed, we’ll arrange inspection/estimate and confirm an approved repair route.

3) Once agreed, we’ll confirm the timeline and keep you updated at key milestones.

If you can share any photos and confirm whether the vehicle is drivable, I can move this on straight away.`
      },
      {
        id: "rb_repairs_timeline",
        title: "Repairs + timeline (set expectations)",
        tags: ["repairs","timeline"],
        text:
`On repairs, timings can vary depending on parts availability and the garage schedule.

What I can do now is: confirm the repair route, get the estimate/authorisation moving, and give you a realistic ETA once the garage confirms their next available slot.

I’ll keep you updated at clear milestones so you’re not left chasing.`
      },
      {
        id: "rb_hire_car",
        title: "Hire / courtesy car (plain language)",
        tags: ["mobility","hire-car"],
        text:
`If you need a replacement vehicle, I can check what’s available under your policy and what the options are.

To keep things clear: I’ll confirm whether it’s a courtesy car (garage-provided) or hire car (separate provider), and any conditions/limits that apply.

If you tell me your immediate transport needs, I’ll prioritise the best route.`
      },
      {
        id: "rb_excess_costs",
        title: "Excess / costs explanation",
        tags: ["money","excess"],
        text:
`On costs: I’ll confirm any excess that applies and when it would be payable.

If there are any charges outside cover (for example, optional upgrades), I’ll flag those up before anything is agreed so there are no surprises.

If you’re worried about affordability, tell me — I’ll outline the available options.`
      },
      {
        id: "rb_total_loss_valuation",
        title: "Written-off / valuation basics",
        tags: ["settlement","valuation"],
        text:
`If the vehicle is deemed a total loss, the settlement is typically based on the vehicle’s market value at the time of the incident.

What I’ll do is explain how the valuation was reached, what evidence was used, and what you can send if you think something important is missing (for example, recent receipts or comparable examples).

I’ll keep this in plain language and step-by-step.`
      },
      {
        id: "rb_docs_request",
        title: "Request documents (friendly + clear)",
        tags: ["documents","evidence"],
        text:
`To move this forward, please share:

• Photos of the damage (if you have them)
• Any relevant receipts/invoices (if applicable)
• Your preferred contact number and best time to reach you

Once I have that, I’ll confirm the next step and timeline.`
      },
      {
        id: "rb_apology_delay",
        title: "Delay apology + control",
        tags: ["delay","tone"],
        text:
`I’m sorry you’ve had to wait — that’s not the experience we want.

What I can do now is confirm exactly where things are, what’s blocking progress (if anything), and the next action we’re taking today.

I’ll update you again by [time] so you’re not left in the dark.`
      },
      {
        id: "rb_escalation_complaint",
        title: "Complaint / escalation route",
        tags: ["complaint","routing"],
        text:
`If you’d like to raise this as a complaint, I can help with that.

I’ll record your concerns accurately, confirm what will happen next, and make sure it goes to the right team.

If you tell me the key outcome you want (for example: faster timeline, clearer costs, or a decision review), I’ll include that explicitly.`
      }
    ],
    suggestion_templates: [
      {
        id: "sg_money_clarity",
        title: "Money clarity (reduce surprises)",
        tags: ["money","clarity"],
        insert:
"Quick cost clarity so there are no surprises: if an excess applies, I’ll confirm the amount and when it’s payable, and I’ll flag anything outside cover before anything is agreed."
      },
      {
        id: "sg_next_steps",
        title: "Next steps (make it concrete)",
        tags: ["next-steps","structure"],
        insert:
"Next steps: I’ll confirm cover/route today, arrange the next action (inspection/estimate if needed), and then I’ll send you a clear timeline once the garage/engineer confirms availability."
      },
      {
        id: "sg_empathy_short",
        title: "Empathy opener (short + UK-safe)",
        tags: ["tone","empathy"],
        insert:
"I can hear how stressful this is — I’ll keep this clear and I’ll tell you exactly what happens next."
      },
      {
        id: "sg_clarifier_topq",
        title: "Answer the top question directly",
        tags: ["intent","clarifier"],
        insert:
"On your question about [TOP_QUESTION], here’s what I can confirm right now: [ANSWER]. If anything is still unknown, I’ll tell you what I’m checking and when I’ll update you."
      }
    ]
  };

  // -------------------------------
  // Helpers (safe, deterministic)
  // -------------------------------
  function MF_nowHM(){
    try{
      const d = new Date();
      return String(d.getHours()).padStart(2,"0")+":"+String(d.getMinutes()).padStart(2,"0");
    }catch(e){ return "today"; }
  }

  function MF_guessName(customerText){
    const s = String(customerText||"");
    let m = s.match(/\b(?:i\s*am|i['’]m|this\s+is|my\s+name\s+is)\s+([A-Z][a-z]{1,20})\b/);
    if (m && m[1]) return m[1];
    m = s.match(/\b(?:hi|hello)\s+([A-Z][a-z]{1,20})\b/);
    if (m && m[1]) return m[1];
    return "there";
  }

  function MF_tokenReplace(text, ctx){
    const name = (ctx && ctx.name) ? ctx.name : "there";
    const time = (ctx && ctx.time) ? ctx.time : MF_nowHM();
    const topQ = (ctx && ctx.topQuestion) ? ctx.topQuestion : "your question";
    const ans  = (ctx && ctx.answer) ? ctx.answer : "[Answer]";

    return String(text||"")
      .replace(/\[name\]/gi, name)
      .replace(/\[time\]/gi, time)
      .replace(/\[TOP_QUESTION\]/gi, topQ)
      .replace(/\[ANSWER\]/gi, ans);
  }

  function MF_smartPad(textarea, snippet){
    const v = String(textarea && textarea.value ? textarea.value : "");
    const start = (textarea && typeof textarea.selectionStart === "number") ? textarea.selectionStart : v.length;
    const before = v.slice(0,start);
    const after  = v.slice(start);

    let s = String(snippet||"");

    const beforeHasText = before.trim().length > 0;
    const afterHasText  = after.trim().length > 0;

    const beforeEndsWithGap = /\n\s*\n$/.test(before) || before.endsWith("\n");
    const afterStartsWithGap = /^\s*\n/.test(after);

    if (beforeHasText && !beforeEndsWithGap && !s.startsWith("\n")) s = "\n\n" + s;
    if (afterHasText && !afterStartsWithGap && !s.endsWith("\n")) s = s + "\n\n";

    if (!beforeHasText) s = s.replace(/^\n+/, "");
    return s;
  }

  function MF_insertIntoAgentDraft(template, ctx, opts){
    if (!el.agentDraft) return;
    const o = opts || {};
    const raw = (o.raw === true) ? String(template || "") : MF_tokenReplace(String(template || ""), ctx || {});
    const txt = String(raw || "");
    if (!txt.trim()) return;

    const ta = el.agentDraft;
    const before = ta.value || "";
    try{ histPush(before); }catch(e){}

    const isEmpty = !before.trim();
    const forceReplace = !!o.forceReplace;

    if (forceReplace || isEmpty){
      const cleaned = txt.replace(/^\s+/, "").replace(/\s+$/, "");
      ta.value = cleaned;
      try{ ta.setSelectionRange(ta.value.length, ta.value.length); }catch(e){}
    } else {
      const smartPad = MF_smartPad(ta, txt);
      insertAtCursor(ta, smartPad);
    }

    state.drafts.agent = ta.value;
    state.lastEdited = "agent";
    try{ histPush(state.drafts.agent); }catch(e){}

    try{ scheduleRender(); }catch(e){ try{ render(); }catch(err){} }
    try{ if (state.previewOn) render(); }catch(e){}
    try{ ta.focus(); }catch(e){}
  }

  function MF_buildAutoDraft(customerText, pack, ctx){
    const c = String(customerText || "").trim();
    if (!c) return "";

    const exp = (pack && pack.experience) ? pack.experience : {};
    const topQ = (exp.topQuestions && exp.topQuestions[0]) ? exp.topQuestions[0] : "";

    const ctx2 = Object.assign({}, ctx || {}, {
      name: ((ctx && ctx.name) ? ctx.name : (MF_guessName(c) || "there")),
      time: ((ctx && ctx.time) ? ctx.time : MF_nowHM()),
      topQuestion: topQ
    });

    const signals = exp.signals || listExperienceSignals(c);
    const intents = exp.intentLadder || extractIntentsRankedCustomer(c);

    const hasStress = Array.isArray(signals) && signals.some(s => s && (s.id === "stress" || s.id === "vuln"));
    const hasMoney = (Array.isArray(signals) && signals.some(s => s && s.id === "money")) || (intents && intents.tier1 && intents.tier1.some(x => /cost|excess|premium|settlement|payout|valuation/i.test(x)));

    const openerTpl = (window.MFCX_CONTENT && MFCX_CONTENT.power_phrases && MFCX_CONTENT.power_phrases.openers && MFCX_CONTENT.power_phrases.openers[0]) || "Hi [name] — thanks for getting in touch.";
    const empathyTpl = (window.MFCX_CONTENT && MFCX_CONTENT.power_phrases && MFCX_CONTENT.power_phrases.empathy && MFCX_CONTENT.power_phrases.empathy[0]) || "I can hear how frustrating this has been.";
    const closingTpl = (window.MFCX_CONTENT && MFCX_CONTENT.power_phrases && MFCX_CONTENT.power_phrases.closing && MFCX_CONTENT.power_phrases.closing[0]) || "If anything changes or you have more detail, reply here and I’ll pick it up.";

    const lines = [];
    lines.push(MF_tokenReplace(openerTpl, ctx2).replace(/\[name\]/g, ctx2.name || "there"));
    if (hasStress) lines.push(MF_tokenReplace(empathyTpl, ctx2));

    // Summarise the top intents (keep it short)
    const concerns = [];
    try{
      if (intents && Array.isArray(intents.tier1)) concerns.push(...intents.tier1);
      if (intents && Array.isArray(intents.tier2)) concerns.push(...intents.tier2.slice(0, 2));
      if (intents && Array.isArray(intents.tier3) && concerns.length < 3) concerns.push(...intents.tier3.slice(0, 1));
    }catch(e){}

    const cList = concerns.filter(Boolean).slice(0, 3);
    if (cList.length){
      lines.push("From your message, you’re mainly looking for clarity on: " + cList.join(" · ") + ".");
    } else {
      lines.push("Thanks for the detail — I’ll help get this organised and keep things clear.");
    }

    // Top question (process-first, then commitment)
    if (topQ){
      const q = topQ.replace(/\s+/g, " ").trim();
      lines.push("On your question — " + q);
      lines.push("• I’ll confirm what we can authorise/confirm right now.");
      lines.push("• If anything needs approval (e.g., repairer work), I’ll check with the handler and update you.");
    }

    // Pull the first insert from the top experience cards
    const cards = (exp.cards && Array.isArray(exp.cards)) ? exp.cards.slice(0, 3) : [];
    if (cards.length){
      for (const card of cards){
        if (card && card.inserts && card.inserts[0]){
          lines.push(String(card.inserts[0]).trim());
        }
      }
    } else {
      const tpl = (window.MFCX_CONTENT && MFCX_CONTENT.suggestion_templates) ? MFCX_CONTENT.suggestion_templates.find(x => x.id === "sg_next_steps") : null;
      if (tpl && tpl.insert) lines.push(MF_tokenReplace(tpl.insert, ctx2));
    }

    // Add 1–2 extra intent-specific lines
    const tier2 = (intents && intents.tier2) ? intents.tier2 : [];
    const extra = [];
    for (const lab of tier2){
      if (extra.length >= 2) break;
      if (/Repair timing/i.test(lab)) extra.push("I’ll confirm the repair timeline/ETA and come back with the next milestone.");
      else if (/Repairs \/ garage/i.test(lab)) extra.push("If the repairer needs authorisation (including paint/colour correction), I’ll confirm what’s approved and what we need from you/garage.");
      else if (/Hire car/i.test(lab)) extra.push("I’ll confirm courtesy/hire car cover and when it will be booked (or what’s needed to arrange it). ");
    }
    extra.forEach(x => lines.push(x));

    if (hasMoney){
      const moneyTpl = (window.MFCX_CONTENT && MFCX_CONTENT.suggestion_templates) ? MFCX_CONTENT.suggestion_templates.find(x => x.id === "sg_money_clarity") : null;
      if (moneyTpl && moneyTpl.insert && !lines.some(l => /\bexcess\b|\bpremium\b|\bcost\b|\£/i.test(l))){
        lines.push(MF_tokenReplace(moneyTpl.insert, ctx2));
      }
    }

    lines.push(MF_tokenReplace(closingTpl, ctx2));

    const out = lines
      .map(x => String(x || "").trim())
      .filter(Boolean)
      .join("\n\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();

    if (out.length > 1800) return out.slice(0, 1790).trim() + "…";
    return out;
  }


  
  // --------------------------------
  // Compose tray (assemble → commit)
  // --------------------------------
  function MF_composeBlocks(){
    if (!state.composeTray) state.composeTray = { blocks: [], keepAfterCommit: false };
    if (!Array.isArray(state.composeTray.blocks)) state.composeTray.blocks = [];
    return state.composeTray.blocks;
  }

  function MF_composeOutput(){
    const blocks = MF_composeBlocks();
    return blocks
      .map(b => String((b && b.text) ? b.text : "").trim())
      .filter(Boolean)
      .join("\n\n");
  }

  function MF_updateComposeCount(){
    try{
      const n = MF_composeBlocks().length;
      if (el && el.composeCount){
        el.composeCount.textContent = String(n);
        el.composeCount.style.opacity = n ? "1" : "0.55";
      }
      if (el && el.btnCompose){
        el.btnCompose.style.opacity = n ? "1" : "0.92";
      }
    }catch(_e){}
  }

  function MF_addToCompose(snippet, ctx, meta){
    const raw = String(snippet || "");
    if (!raw.trim()) return;

    const cooked = MF_tokenReplace(raw, ctx);
    const blocks = MF_composeBlocks();

    const id = (meta && meta.id) ? String(meta.id) : ("b_" + Date.now() + "_" + Math.random().toString(16).slice(2));
    const title = (meta && meta.title) ? String(meta.title) : "Block";
    const source = (meta && meta.source) ? String(meta.source) : "insert";

    blocks.push({ id, title, source, text: cooked });

    MF_updateComposeCount();
    toast("Added to Compose.", false);
  }

  function MF_removeComposeAt(i){
    const blocks = MF_composeBlocks();
    if (i < 0 || i >= blocks.length) return;
    blocks.splice(i, 1);
    MF_updateComposeCount();
  }

  function MF_moveCompose(i, dir){
    const blocks = MF_composeBlocks();
    const j = i + dir;
    if (i < 0 || i >= blocks.length || j < 0 || j >= blocks.length) return;
    const t = blocks[i]; blocks[i] = blocks[j]; blocks[j] = t;
  }

  function MF_clearCompose(){
    MF_composeBlocks().length = 0;
    MF_updateComposeCount();
  }

  function openComposeTray(anchorBtn){
    closeMenu();

    const r = anchorBtn.getBoundingClientRect();
    const m = document.createElement("div");
    m.id = "mfMenu";
    m.setAttribute("role","dialog");
    m.setAttribute("aria-label","Compose tray");

    const width = 420;
    const left = Math.min(window.innerWidth - (width + 16), Math.max(12, r.left));
    const top = Math.min(window.innerHeight - 520, r.bottom + 10);

    m.style.position = "fixed";
    m.style.left = `${left}px`;
    m.style.top = `${top}px`;
    m.style.width = `${width}px`;
    m.style.borderRadius = "16px";
    m.style.border = "1px solid rgba(255,255,255,.16)";
    m.style.background = "rgba(0,0,0,.66)";
    m.style.backdropFilter = "blur(12px)";
    m.style.boxShadow = "0 18px 55px rgba(0,0,0,.62)";
    m.style.padding = "10px";
    m.style.zIndex = "9998";
    m.style.display = "flex";
    m.style.flexDirection = "column";
    m.style.gap = "10px";

    // Header
    const head = document.createElement("div");
    head.style.display = "flex";
    head.style.alignItems = "center";
    head.style.justifyContent = "space-between";
    head.style.gap = "10px";

    const title = document.createElement("div");
    title.textContent = "Compose Tray";
    title.style.fontSize = "0.78rem";
    title.style.fontWeight = "700";
    title.style.letterSpacing = "0.06em";
    title.style.textTransform = "uppercase";
    title.style.color = "rgba(255,255,255,.88)";

    const x = document.createElement("button");
    x.type = "button";
    x.textContent = "×";
    x.style.width = "28px";
    x.style.height = "28px";
    x.style.borderRadius = "999px";
    x.style.border = "1px solid rgba(255,255,255,.16)";
    x.style.background = "rgba(255,255,255,.06)";
    x.style.color = "rgba(255,255,255,.9)";
    x.style.cursor = "pointer";
    x.style.fontSize = "1.05rem";
    x.onclick = () => closeMenu();

    head.appendChild(title);
    head.appendChild(x);

    // Body split: list + preview
    const body = document.createElement("div");
    body.style.display = "grid";
    body.style.gridTemplateColumns = "1fr";
    body.style.gap = "10px";

    const listWrap = document.createElement("div");
    listWrap.style.border = "1px solid rgba(255,255,255,.10)";
    listWrap.style.borderRadius = "14px";
    listWrap.style.background = "rgba(255,255,255,.04)";
    listWrap.style.padding = "8px";
    listWrap.style.maxHeight = "190px";
    listWrap.style.overflow = "auto";

    const previewWrap = document.createElement("div");
    previewWrap.style.border = "1px solid rgba(255,255,255,.10)";
    previewWrap.style.borderRadius = "14px";
    previewWrap.style.background = "rgba(255,255,255,.04)";
    previewWrap.style.padding = "10px";

    const previewLabel = document.createElement("div");
    previewLabel.textContent = "Preview";
    previewLabel.style.fontSize = "0.70rem";
    previewLabel.style.letterSpacing = "0.06em";
    previewLabel.style.textTransform = "uppercase";
    previewLabel.style.color = "rgba(255,255,255,.68)";
    previewLabel.style.marginBottom = "6px";

    const emptyHint = document.createElement("div");
    emptyHint.textContent = "Add items from Writer/Experience to build a reply here";
    emptyHint.style.fontSize = "0.74rem";
    emptyHint.style.lineHeight = "1.35";
    emptyHint.style.color = "rgba(255,255,255,.62)";
    emptyHint.style.padding = "4px 0";

    const preview = document.createElement("pre");
    preview.style.margin = "0";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.wordBreak = "break-word";
    preview.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    preview.style.fontSize = "0.74rem";
    preview.style.lineHeight = "1.45";
    preview.style.color = "rgba(255,255,255,.88)";
    preview.style.maxHeight = "170px";
    preview.style.overflow = "auto";

    previewWrap.appendChild(previewLabel);
    previewWrap.appendChild(emptyHint);
    previewWrap.appendChild(preview);

    function renderTray(){
      // list
      listWrap.innerHTML = "";
      const blocks = MF_composeBlocks();
      if (!blocks.length){
        listWrap.innerHTML = `<div style="color:rgba(255,255,255,.62);font-size:.74rem;padding:8px;">No items yet.</div>`;
      } else {
        blocks.forEach((b, i) => {
          const row = document.createElement("div");
          row.style.display = "grid";
          row.style.gridTemplateColumns = "1fr auto";
          row.style.gap = "10px";
          row.style.alignItems = "start";
          row.style.padding = "8px";
          row.style.borderRadius = "12px";
          row.style.border = "1px solid rgba(255,255,255,.10)";
          row.style.background = "rgba(255,255,255,.05)";
          row.style.margin = "6px 0";

          const left = document.createElement("div");
          const tt = document.createElement("div");
          tt.textContent = `${i+1}. ${b.title || "Block"}`;
          tt.style.fontSize = "0.74rem";
          tt.style.fontWeight = "700";
          tt.style.color = "rgba(255,255,255,.90)";
          const ss = document.createElement("div");
          ss.textContent = (b.text || "").slice(0, 90) + ((b.text || "").length > 90 ? "…" : "");
          ss.style.fontSize = "0.72rem";
          ss.style.lineHeight = "1.35";
          ss.style.color = "rgba(255,255,255,.68)";
          ss.style.marginTop = "3px";
          left.appendChild(tt);
          left.appendChild(ss);

          const right = document.createElement("div");
          right.style.display = "flex";
          right.style.flexDirection = "column";
          right.style.gap = "6px";

          const mkBtn = (label, onClick, disabled) => {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = label;
            b.style.width = "34px";
            b.style.height = "30px";
            b.style.borderRadius = "10px";
            b.style.border = "1px solid rgba(255,255,255,.14)";
            b.style.background = "rgba(255,255,255,.06)";
            b.style.color = "rgba(255,255,255,.9)";
            b.style.cursor = "pointer";
            b.style.opacity = disabled ? "0.45" : "1";
            b.disabled = !!disabled;
            b.onclick = onClick;
            return b;
          };

          right.appendChild(mkBtn("↑", ()=>{ MF_moveCompose(i, -1); renderTray(); }, i===0));
          right.appendChild(mkBtn("↓", ()=>{ MF_moveCompose(i, +1); renderTray(); }, i===blocks.length-1));
          right.appendChild(mkBtn("×", ()=>{ MF_removeComposeAt(i); renderTray(); }, false));

          row.appendChild(left);
          row.appendChild(right);
          listWrap.appendChild(row);
        });
      }

      const out = MF_composeOutput();
      preview.textContent = out;
      const has = out.trim().length > 0;
      emptyHint.style.display = has ? "none" : "block";
      btnCommit.disabled = !has;
      btnCommit.style.opacity = has ? "1" : "0.55";
      btnCopy.disabled = !has;
      btnCopy.style.opacity = has ? "1" : "0.55";
      btnClear.disabled = !MF_composeBlocks().length;
      btnClear.style.opacity = MF_composeBlocks().length ? "1" : "0.55";
      MF_updateComposeCount();
      return out;
    }

    body.appendChild(listWrap);
    body.appendChild(previewWrap);

    // Actions
    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "10px";
    actions.style.alignItems = "center";
    actions.style.justifyContent = "space-between";
    actions.style.flexWrap = "wrap";

    const leftActions = document.createElement("div");
    leftActions.style.display = "flex";
    leftActions.style.gap = "10px";
    leftActions.style.flex = "1";

    const btnClear = document.createElement("button");
    btnClear.type = "button";
    btnClear.textContent = "Clear";
    btnClear.style.flex = "0 0 auto";
    btnClear.style.padding = "10px 10px";
    btnClear.style.borderRadius = "12px";
    btnClear.style.border = "1px solid rgba(255,255,255,.16)";
    btnClear.style.background = "rgba(255,255,255,.06)";
    btnClear.style.color = "rgba(255,255,255,.85)";
    btnClear.style.cursor = "pointer";

    const btnCopy = document.createElement("button");
    btnCopy.type = "button";
    btnCopy.textContent = "Copy";
    btnCopy.style.flex = "0 0 auto";
    btnCopy.style.padding = "10px 10px";
    btnCopy.style.borderRadius = "12px";
    btnCopy.style.border = "1px solid rgba(255,255,255,.16)";
    btnCopy.style.background = "rgba(255,255,255,.06)";
    btnCopy.style.color = "rgba(255,255,255,.85)";
    btnCopy.style.cursor = "pointer";

    const keepWrap = document.createElement("label");
    keepWrap.style.display = "flex";
    keepWrap.style.alignItems = "center";
    keepWrap.style.gap = "8px";
    keepWrap.style.color = "rgba(255,255,255,.72)";
    keepWrap.style.fontSize = "0.74rem";
    keepWrap.style.userSelect = "none";
    const keepCb = document.createElement("input");
    keepCb.type = "checkbox";
    keepCb.checked = !!state.composeTray.keepAfterCommit;
    keepCb.addEventListener("change", ()=>{ state.composeTray.keepAfterCommit = keepCb.checked; });
    keepWrap.appendChild(keepCb);
    keepWrap.appendChild(document.createTextNode("Keep after commit"));

    leftActions.appendChild(btnClear);
    leftActions.appendChild(btnCopy);
    leftActions.appendChild(keepWrap);

    const btnCommit = document.createElement("button");
    btnCommit.type = "button";
    btnCommit.textContent = "Commit to draft";
    btnCommit.style.flex = "1";
    btnCommit.style.padding = "10px 10px";
    btnCommit.style.borderRadius = "12px";
    btnCommit.style.border = "1px solid rgba(56,189,248,.55)";
    btnCommit.style.background = "rgba(56,189,248,.18)";
    btnCommit.style.color = "rgba(255,255,255,.95)";
    btnCommit.style.cursor = "pointer";
    btnCommit.disabled = true;
    btnCommit.style.opacity = "0.55";

    btnClear.onclick = () => { MF_clearCompose(); renderTray(); toast("Compose cleared.", false); };
    btnCopy.onclick = async () => {
      const out = renderTray();
      if (!out.trim()) return;
      try{ await navigator.clipboard.writeText(out); toast("Copied.", false); }
      catch(e){ toast("Copy failed.", true); }
    };
    btnCommit.onclick = () => {
      const out = renderTray();
      if (!out.trim()) return;
      const padded = MF_smartPad(el.agentDraft, out);
      insertAtCursor(el.agentDraft, padded);
      state.drafts.agent = el.agentDraft.value;
      state.lastEdited = "agent";
      try{ histPush(state.drafts.agent); }catch(_e){}
      try{ scheduleRender(); }catch(e){ try{ render(); }catch(err){} }

      if (!state.composeTray.keepAfterCommit) MF_clearCompose();
      closeMenu();
      toast("Committed to draft.", false);
    };

    actions.appendChild(leftActions);
    actions.appendChild(btnCommit);

    m.appendChild(head);
    m.appendChild(body);
    m.appendChild(actions);

    document.body.appendChild(m);

    renderTray();

    // Close on outside click
    setTimeout(() => window.addEventListener("mousedown", (e)=>{ if(!m.contains(e.target)) closeMenu(); }, { once:true }), 0);
  }


function MF_detectMissing(agentText, customerText, signals, intents, topQuestions){
    const a = String(agentText||"").toLowerCase();
    const c = String(customerText||"");

    const customerHasQ = /\?/.test(c) && (topQuestions && topQuestions.length);
    const agentHasDirectAnswer = /(i can confirm|here['’]s what|what i can do|to keep things clear|in short|the answer is)/i.test(a);

    const missing = {
      next_steps: !/(next steps?|what happens next|here['’]s what will happen|1\)|2\)|3\))/i.test(a),
      money_clarity: !/(excess|cost|charge|fee|payable|covered|not covered|refund|premium)/i.test(a),
      empathy: !/(sorry|i understand|i can hear|that’s understandable|frustrat|stressful)/i.test(a),
      direct_answer: customerHasQ && !agentHasDirectAnswer
    };

    const hasMoneyIntent = intents && Array.isArray(intents.all) && intents.all.includes("Costs / excess");
    const hasMoneySignal = signals && Array.isArray(signals.money) && signals.money.length > 0;
    if (!hasMoneyIntent && !hasMoneySignal) missing.money_clarity = false;

    const hasStress = signals && Array.isArray(signals.stress) && signals.stress.length > 0;
    const hasVuln   = signals && Array.isArray(signals.vuln) && signals.vuln.length > 0;
    if (!hasStress && !hasVuln) missing.empathy = false;

    if (!customerHasQ) missing.direct_answer = false;

    return missing;
  }

  function MF_pickReplyBlockByIntent(intents, customerText){
    const all = intents && Array.isArray(intents.all) ? intents.all : [];
    const c = String(customerText||"").toLowerCase();

    if (/(wait|waiting|no update|chasing|still not|days|weeks)/i.test(c)) return "rb_apology_delay";
    if (all.includes("Costs / excess")) return "rb_excess_costs";
    if (all.includes("Repairs / garage")) return "rb_repairs_timeline";
    if (all.includes("Hire car / mobility")) return "rb_hire_car";
    if (all.includes("Settlement / payout")) return "rb_total_loss_valuation";
    return "rb_nextsteps_generic";
  }

  function MF_buildTopPicks(customerText, agentText, signals, intents, topQs){
    const missing = MF_detectMissing(agentText, customerText, signals, intents, topQs);
    const picks = [];
    const addPick = (id, title, insert, tags, priority) => {
      picks.push({ id, title, insert, tags: Array.isArray(tags)?tags:[], priority: Number(priority||1) });
    };

    if (missing.empathy){
      const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_empathy_short");
      addPick(t.id, t.title, t.insert, t.tags, 1);
    }
    if (missing.money_clarity){
      const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_money_clarity");
      addPick(t.id, t.title, t.insert, t.tags, 2);
    }
    if (missing.next_steps){
      const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_next_steps");
      addPick(t.id, t.title, t.insert, t.tags, 3);
    }
    if (missing.direct_answer){
      const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_clarifier_topq");
      addPick(t.id, t.title, t.insert, t.tags, 4);
    }

    const rbId = MF_pickReplyBlockByIntent(intents, customerText);
    const rb = MFCX_CONTENT.reply_blocks.find(x=>x.id===rbId) || MFCX_CONTENT.reply_blocks[0];
    if (rb){
      addPick(rb.id, rb.title, rb.text, rb.tags || ["reply-block"], 5);
    }

    picks.sort((a,b)=>(a.priority||9)-(b.priority||9));
    return picks.slice(0,6);
  }

  function MF_buildExperienceCards(customerText, agentText, signals, intents, topQs){
    const missing = MF_detectMissing(agentText, customerText, signals, intents, topQs);
    const cards = [];

    const name = MF_guessName(customerText);
    const ctxBase = { name, time: MF_nowHM(), topQuestion: (topQs && topQs[0]) ? topQs[0] : "" };

    if (missing.empathy){
      cards.push({
        title: "Tone reset (empathy)",
        why: "Stress / vulnerability cues detected — a short acknowledgement reduces friction.",
        doNext: ["Acknowledge emotion", "Promise clarity", "Move to next step"],
        inserts: [ MF_tokenReplace(MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_empathy_short").insert, ctxBase) ],
        priority: 1
      });
    }
    if (missing.money_clarity){
      cards.push({
        title: "Cost clarity (no surprises)",
        why: "Money intent/signal present — confirm excess/charges early.",
        doNext: ["Confirm excess", "Explain what’s covered", "Flag any optional costs"],
        inserts: [ MF_tokenReplace(MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_money_clarity").insert, ctxBase) ],
        priority: 2
      });
    }
    if (missing.next_steps){
      cards.push({
        title: "Next steps (concrete)",
        why: "Customers relax when the path is explicit (what you’ll do + when they’ll hear back).",
        doNext: ["Confirm route", "Start the next action", "Commit to a timed update"],
        inserts: [ MF_tokenReplace(MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_next_steps").insert, ctxBase) ],
        priority: 3
      });
    }
    if (missing.direct_answer && topQs && topQs.length){
      cards.push({
        title: "Answer the top question",
        why: "Customer asked a direct question — answer first, then explain what you’re checking.",
        doNext: ["Answer what you can confirm", "Name what’s unknown", "Commit to update time"],
        inserts: [ MF_tokenReplace(MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_clarifier_topq").insert, ctxBase) ],
        priority: 4
      });
    }

    cards.sort((a,b)=>(a.priority||9)-(b.priority||9));
    return cards;
  }

  // -------------------------------
  // MFCX Builder (contract output)
  // -------------------------------
  function buildMFCXLite(customerText, agentText, writerCounts, writerFlags){
    const customer = String(customerText||"");
    const agent = String(agentText||"");

    const signals = listExperienceSignals(customer);
    const intents = extractIntentsRankedCustomer(customer);

    const allQs = extractCustomerQuestionsLite(customer);
    const topQs = pickTopQuestionsLite(allQs);

    const topPicks = MF_buildTopPicks(customer, agent, signals, intents, topQs);
    const cards = MF_buildExperienceCards(customer, agent, signals, intents, topQs);

    const flags = [];
    try{
      const cf = (writerFlags && writerFlags.clarity) ? writerFlags.clarity : [];
      const tf = (writerFlags && writerFlags.tone) ? writerFlags.tone : [];
      for (const it of cf) flags.push({ type:"clarity", label: it.key || "Clarity", evidence: it.val || "", suggestion: "" });
      for (const it of tf) flags.push({ type:"tone", label: it.key || "Tone", evidence: it.val || "", suggestion: "" });
    }catch(e){}

    return {
      version: "mfcx-lite-engine-1.0",
      writer: {
        counts: writerCounts || { ukus:0, jargon:0, clarity:0, tone:0 },
        flags,
        topPicks
      },
      experience: {
        signals,
        intentLadder: intents,
        topQuestions: topQs,
        cards
      }
    };
  }

  // -------------------------------
  // UI render helpers (Writer/Exp)
  // -------------------------------
  function MF_el(tag, cls, text){
    const n = document.createElement(tag);
    if (cls) n.className = cls;
    if (typeof text === "string") n.textContent = text;
    return n;
  }

  function MF_renderTopPicksSection(pack){
    const sec = MF_el("div","mf-sec");
    sec.appendChild(MF_el("div","mf-sec-head","Top Picks"));
    const list = MF_el("div","insight-list");
    const picks = pack && pack.writer && Array.isArray(pack.writer.topPicks) ? pack.writer.topPicks : [];

    if (!picks.length){
      list.innerHTML = `<div class="insight-muted">No picks yet — add a customer message and start drafting.</div>`;
      sec.appendChild(list);
      return sec;
    }

    const name = MF_guessName(state.drafts.customer || "");
    const ctx = { name, time: MF_nowHM(), topQuestion: (pack.experience && pack.experience.topQuestions && pack.experience.topQuestions[0]) ? pack.experience.topQuestions[0] : "" };

    for (const p of picks){
      const row = MF_el("div","insight-item mf-pick");
      row.innerHTML = `<div class="insight-dot"></div>`;
      const col = MF_el("div","insight-col");
      const k = MF_el("div","k", p.title || p.id);
      const v = MF_el("div","v", (p.tags && p.tags.length) ? p.tags.join(" • ") : "Suggested insert");
      col.appendChild(k);
      col.appendChild(v);

      const actions = MF_el("div","mf-actions");

      const bAdd = MF_el("button","btn-mini","Add to Compose");
      bAdd.type="button";
      bAdd.addEventListener("click", ()=> MF_addToCompose(p.insert || "", ctx, { id:p.id, title:(p.title||p.id), source:"top-pick" }));
      actions.appendChild(bAdd);

      const bIns = MF_el("button","btn-mini","Insert now");
      bIns.type="button";
      bIns.addEventListener("click", ()=> MF_insertIntoAgentDraft(p.insert || "", ctx));
      actions.appendChild(bIns);

      const bCopy = MF_el("button","btn-mini","Copy");
      bCopy.type="button";
      bCopy.addEventListener("click", async ()=>{
        try{
          const t = MF_tokenReplace(p.insert||"", ctx);
          await navigator.clipboard.writeText(t);
          toast("Copied.", false);
        }catch(e){ toast("Copy failed.", true); }
      });
      actions.appendChild(bCopy);

      col.appendChild(actions);
      row.appendChild(col);
      list.appendChild(row);
    }

    sec.appendChild(list);
    return sec;
  }

  function MF_renderPhrasesSection(){
    const sec = MF_el("div","mf-sec");
    sec.appendChild(MF_el("div","mf-sec-head","Phrases"));

    const groups = [
      ["Openers","openers"],
      ["Empathy","empathy"],
      ["Ownership","ownership"],
      ["Clarifiers","clarifiers"],
      ["Expectations","expectations"],
      ["Money clarity","money_clarity"],
      ["Closing","closing"]
    ];

    const name = MF_guessName(state.drafts.customer || "");
    const ctx = { name, time: MF_nowHM() };

    for (const [label, key] of groups){
      const details = MF_el("details","mf-block");
      details.open = (key === "openers" || key === "empathy");
      const sum = MF_el("summary","mf-block-sum", label);
      details.appendChild(sum);

      const wrap = MF_el("div","mf-chiprow");
      const arr = (MFCX_CONTENT.power_phrases && MFCX_CONTENT.power_phrases[key]) ? MFCX_CONTENT.power_phrases[key] : [];
      for (const phrase of arr){
        const chip = MF_el("button","chip chipbtn mf-chip", phrase);
        chip.type="button";
        chip.title="Click: insert • Shift+Click: add to Compose";
        chip.addEventListener("click", (e)=>{
          if (e && e.shiftKey) MF_addToCompose(phrase, ctx, { title: label, source: "phrase" });
          else MF_insertIntoAgentDraft(phrase, ctx);
        });
        wrap.appendChild(chip);
      }
      details.appendChild(wrap);
      sec.appendChild(details);
    }

    return sec;
  }

  function MF_renderReplyBlocksSection(){
    const sec = MF_el("div","mf-sec");
    sec.appendChild(MF_el("div","mf-sec-head","Reply Blocks"));

    const name = MF_guessName(state.drafts.customer || "");
    const ctx = { name, time: MF_nowHM() };

    for (const rb of (MFCX_CONTENT.reply_blocks || [])){
      const details = MF_el("details","mf-block");
      const sum = MF_el("summary","mf-block-sum", rb.title || rb.id);
      details.appendChild(sum);

      const meta = MF_el("div","mf-block-meta", (rb.tags && rb.tags.length) ? rb.tags.join(" • ") : "");
      details.appendChild(meta);

      const actions = MF_el("div","mf-actions");

      const bAdd = MF_el("button","btn-mini","Add to Compose");
      bAdd.type="button";
      bAdd.addEventListener("click", ()=> MF_addToCompose(rb.text || "", ctx, { id: rb.id, title:(rb.title||rb.id), source:"reply-block" }));
      actions.appendChild(bAdd);

      const bIns = MF_el("button","btn-mini","Insert now");
      bIns.type="button";
      bIns.addEventListener("click", ()=> MF_insertIntoAgentDraft(rb.text || "", ctx));
      actions.appendChild(bIns);

      const bCopy = MF_el("button","btn-mini","Copy");
      bCopy.type="button";
      bCopy.addEventListener("click", async ()=>{
        try{
          const t = MF_tokenReplace(rb.text||"", ctx);
          await navigator.clipboard.writeText(t);
          toast("Copied.", false);
        }catch(e){ toast("Copy failed.", true); }
      });
      actions.appendChild(bCopy);

      details.appendChild(actions);

      const pre = MF_el("pre","mf-pre", rb.text || "");
      details.appendChild(pre);

      sec.appendChild(details);
    }

    return sec;
  }


  const ENGINE = (() => {
    const B = ENGINE_BUNDLE || {};
    const escapeRe = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    const countMatches = (re, text) => {
      re.lastIndex = 0;
      let c = 0;
      let m;
      while ((m = re.exec(text)) !== null) {
        c++;
        if (m.index === re.lastIndex) re.lastIndex++; // safety for zero-length matches
      }
      return c;
    };

    const engine = (B.engine || {});
    const legacy = (B.legacy_ui_lists || {});

    // NOTE: Classic export uses `ukus_pairs_engine` as the canonical list.
    // Keep a soft fallback for older bundles.
    const ukusPairsRaw = Array.isArray(engine.ukus_pairs_engine)
      ? engine.ukus_pairs_engine
      : (Array.isArray(engine.ukus_pairs) ? engine.ukus_pairs : []);
    const jargonRulesRaw = Array.isArray(engine.jargon_rules) ? engine.jargon_rules : [];

    const ukusPairs = ukusPairsRaw.map(p => {
      const us = String((p && p.us) || "").trim();
      if (!us) return null;
      let re = null;
      try { re = new RegExp(`\\b${escapeRe(us)}\\b`, "gi"); } catch (e) { re = null; }
      if (!re) return null;
      return Object.assign({}, p, { us, re });
    }).filter(Boolean);

    const jargonRules = jargonRulesRaw.map(r => {
      let re = null;
      try { re = new RegExp(r.pattern, r.flags || "gi"); } catch (e) { re = null; }
      if (!re) return null;
      return Object.assign({}, r, { re });
    }).filter(Boolean);

    const jargonDictionary = Array.isArray(legacy.jargon_dictionary) ? legacy.jargon_dictionary : [];
    const jargonDictMap = new Map(
      jargonDictionary.map(d => [String((d && d.term) || "").toLowerCase(), d])
    );

    const ukusPairsSimple = Array.isArray(legacy.ukus_pairs_simple) ? legacy.ukus_pairs_simple : [];

    return {
      meta: B.meta || {},
      ukus: { pairs: ukusPairs, simple: ukusPairsSimple },
      jargon: { rules: jargonRules, dictionary: jargonDictionary, dictMap: jargonDictMap },
      util: { escapeRe, countMatches }
    };
  })();

  const THEMES = {
    sol: [
      { name:"Sunrise", vars:{
        "--bg0":"#1A2A44",
        "--bg1":"#2C5C7A",
        "--accent":"#FFB37C",
        "--accent2":"#8BC6FF",
        "--panelA":"rgba(255,255,255,.075)",
        "--panelB":"rgba(255,255,255,.03)",
        "--card":"rgba(255,255,255,.055)",
        "--card2":"rgba(255,255,255,.075)",
        "--bub-agent":"rgba(255,179,124,.18)",
        "--bub-agent-stroke":"rgba(255,179,124,.34)"
      }, sw:["#FFB37C","#8BC6FF","#7FF2C0","#FFD28C"]},
      { name:"Skyglass", vars:{
        "--bg0":"#162C4E",
        "--bg1":"#284D7A",
        "--accent":"#8BC6FF",
        "--accent2":"#B7A6FF",
        "--panelA":"rgba(255,255,255,.07)",
        "--panelB":"rgba(255,255,255,.028)",
        "--bub-agent":"rgba(139,198,255,.18)",
        "--bub-agent-stroke":"rgba(139,198,255,.34)"
      }, sw:["#8BC6FF","#B7A6FF","#CFE8FF","#8FFFD6"]},
      { name:"Mintday", vars:{
        "--bg0":"#0E2D33",
        "--bg1":"#1B4B4A",
        "--accent":"#7FF2C0",
        "--accent2":"#8BC6FF",
        "--panelA":"rgba(255,255,255,.07)",
        "--panelB":"rgba(255,255,255,.026)",
        "--bub-agent":"rgba(127,242,192,.17)",
        "--bub-agent-stroke":"rgba(127,242,192,.34)"
      }, sw:["#7FF2C0","#8BC6FF","#CFE8FF","#B7FF8F"]},
      { name:"Peach", vars:{
        "--bg0":"#2A2233",
        "--bg1":"#6A4256",
        "--accent":"#FFD28C",
        "--accent2":"#FFB3C7",
        "--panelA":"rgba(255,255,255,.072)",
        "--panelB":"rgba(255,255,255,.028)",
        "--bub-agent":"rgba(255,210,140,.16)",
        "--bub-agent-stroke":"rgba(255,210,140,.32)"
      }, sw:["#FFD28C","#FFB3C7","#8BC6FF","#7FF2C0"]}
    ],
    lunar: [
      { name:"Nighttide", vars:{
        "--bg0":"#04050B","--bg1":"#070A14","--accent":"#7AB4FF","--accent2":"#56F2C2",
        "--panelA":"rgba(255,255,255,.07)","--panelB":"rgba(255,255,255,.03)",
        "--bub-agent":"rgba(122,180,255,.18)","--bub-agent-stroke":"rgba(122,180,255,.34)"
      }, sw:["#7AB4FF","#56F2C2","#C9D2FF","#B98BFF"]},
      { name:"Rift", vars:{
        "--bg0":"#040411","--bg1":"#0A0830","--accent":"#B98BFF","--accent2":"#7AB4FF",
        "--bub-agent":"rgba(185,139,255,.16)","--bub-agent-stroke":"rgba(185,139,255,.32)"
      }, sw:["#B98BFF","#7AB4FF","#FF74D4","#C9D2FF"]},
      { name:"Ember", vars:{
        "--bg0":"#070509","--bg1":"#140A10","--accent":"#FF9A55","--accent2":"#FF74D4",
        "--bub-agent":"rgba(255,154,85,.16)","--bub-agent-stroke":"rgba(255,154,85,.32)"
      }, sw:["#FF9A55","#FF74D4","#B98BFF","#C9D2FF"]},
      { name:"Void", vars:{
        "--bg0":"#030307","--bg1":"#07070E","--accent":"#C9D2FF","--accent2":"#B98BFF",
        "--bub-agent":"rgba(201,210,255,.14)","--bub-agent-stroke":"rgba(201,210,255,.30)"
      }, sw:["#C9D2FF","#B98BFF","#7AB4FF","#56F2C2"]}
    ]
  };

  const STORAGE_KEY = "mirrorflow2_uilock_v1_settings";
  // --- BG Builder presets (Lite) ---
  const MF_BG_PRESETS = {
    lunar: {
      name: "lunar",
      active: { colour: "crown", pattern: "dots", bgmode: "stars" },
      palettes: {
        crown: {
          css: {
            "--bg-c1":"#050816",
            "--bg-c2":"#120a2a",
            "--bg-c3":"#3b82f6",
            "--bg-c4":"#8b5cf6",
            "--poly-op":"0.92",
            "--pat-op":"0.86",
            "--vignette":"0.38",
            "--pat-scale":"1",
            "--pat-weight":"1",
            "--pat-density":"1",
            "--stars-int":"1"
          }
        }
      }
    },
    sol: {
      name: "day",
      active: { colour: "sunburst", pattern: "lines", bgmode: "static" },
      palettes: {
        sunburst: {
          css: {
            "--bg-c1":"#0B1320",
            "--bg-c2":"#10243D",
            "--bg-c3":"#FFB37C",
            "--bg-c4":"#8BC6FF",
            "--poly-op":"0.92",
            "--pat-op":"0.86",
            "--vignette":"0.32",
            "--pat-scale":"1.45",
            "--pat-weight":"0.98",
            "--pat-density":"0.87",
            "--stars-int":"0"
          }
        }
      }
    }
  };

  function mfGetBgPresetForTheme(themeMode){
    const key = (themeMode === "lunar") ? "lunar" : "sol";
    const preset = MF_BG_PRESETS[key];
    const colour = preset.active.colour;
    const pack = preset.palettes[colour] || Object.values(preset.palettes)[0];
    return { themeKey: key, colour, pattern: preset.active.pattern, bgmode: preset.active.bgmode, css: (pack && pack.css) ? pack.css : {} };
  }

  function mfApplyBgPreset(themeMode){
    const p = mfGetBgPresetForTheme(themeMode);
    // dataset flags for CSS
    document.body.dataset.theme = p.themeKey;
    document.body.dataset.colour = p.colour;
    document.body.dataset.poly = "none";
    document.body.dataset.pattern = p.pattern;
    document.body.dataset.bgmode = p.bgmode;

    // map BG builder colours into app theme tokens (so UI tint follows)
    const css = Object.assign({}, p.css);
    css["--bg0"] = css["--bg-c1"] || cssVar("--bg-c1") || cssVar("--bg0");
    css["--bg1"] = css["--bg-c2"] || cssVar("--bg-c2") || cssVar("--bg1");
    css["--accent"] = css["--bg-c3"] || cssVar("--bg-c3") || cssVar("--accent");
    css["--accent2"] = css["--bg-c4"] || cssVar("--bg-c4") || cssVar("--accent2");

    setCSSVars(css);
    syncParticleColours();
    // rebuild particles/stars for new palette + density
    try{ makeParts(); }catch(e){}
    return p;
  }

  

  // Demo customer replies (edit freely). Used by Option 1 rolling-reply mode.
  // Behaviour: only when agent draft is empty, tapping the Phone™ send-dot steps to the next reply.
  const DEMO_CUSTOMER_REPLIES = [
    "Hi — any update on my claim please?",
    "I’m a bit worried about costs. Will I need to pay an excess?",
    "How long will repairs take? I need my car for work.",
    "Can you confirm what happens next, step by step?",
    "Will you provide a courtesy car, or do I need to arrange my own?",
    "I’ve had no texts/emails since yesterday — is everything still on track?",
    "Sorry if I missed it — what documents do you need from me?",
    "Is there anything I should do right now to avoid delays?",
    "Thanks. Just to confirm, when should I expect the next update?",
    "Ok. If anything changes, please message me here.",
  ];

  // Rolling agent tips (Phone input ticker)
  // Adapted from MirrorFlow_TheFallOff tip ticker mechanics (typewriter + fade + advance-on-send when complete).
  const AGENT_TIPS = [
    "One idea per sentence keeps things clear.",
    "Use the customer’s name once — it helps it feel personal.",
    "If you’re not sure, say what you can do next, not what you can’t.",
    "Avoid jargon where possible — plain language wins.",
    "Check names, dates and amounts before sending your reply.",
    "Short paragraphs are easier to read on mobile.",
    "If you’ve made a mistake, own it and fix it quickly.",
    "Summarise long chats in one clear closing message.",
    "Let the customer know what will happen after the chat ends.",
    "Use reassuring phrases like “I’ll keep you updated”.",
    "If you need time to check, tell them what you’re checking.",
    "Match the customer’s tone — calm, steady, and helpful.",
    "If it’s bad news, be clear and kind, not robotic.",
    "If you’ve asked a question, give them space to answer.",
    "Always double-check spelling of names and registration numbers.",
    "If your reply looks like a WhatsApp rant, breathe and rewrite it.",
    "The spellchecker is your co-pilot — you still fly the message.",
  ];


  // --- Lite CX content backbone (Phase 1/2 seed) ---
  // Neutral, composable primitives (no prescriptions, no auto-write).
  const LITE_PHRASE_PRIMITIVES_V1 = {
    empathy_openers: [
      "Thanks for your patience — I know this is stressful.",
      "I’m sorry this has been a hassle.",
      "Thanks for flagging that — I can see why you’d ask.",
      "I understand why you’re concerned."
    ],
    ownership_lines: [
      "I’ll take a look now and update you here.",
      "I’ll keep this moving and let you know what I find.",
      "I’ll come back to you as soon as I’ve checked that."
    ],
    timeline_setters: [
      "Next update: {{NEXT_UPDATE_DAY}} (or sooner if anything changes).",
      "I’m checking {{WHAT_I_AM_CHECKING}} — I’ll update you by {{TIME}}.",
      "If we need anything from you, I’ll message you straight away."
    ],
    cost_framing: [
      "If an excess applies, it’s the first £{{EXCESS}} of the claim — we’ll confirm before anything is authorised.",
      "Right now, costs are still being assessed — I’ll share the next clear figure once we have it.",
      "If we recover costs from the other side later, we’ll keep you updated on what that means for you."
    ],
    vulnerability_safe: [
      "If you need extra support (for example, updates by phone or more time to reply), tell me what works best.",
      "If anything about this process is difficult for you right now, we can adjust how we communicate."
    ],
    clarity_closers: [
      "Just to confirm, here’s what happens next:",
      "If anything changes, I’ll message you here.",
      "Does that make sense, or is there anything you want me to explain differently?"
    ]
  };

  // Reply scaffolds: block structure only (A → E → N), using Lite placeholders.
  const LITE_REPLY_SCAFFOLDS_V1 = [
    {
      id: "AEN_update_basic",
      title: "A → E → N (safe update)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: {{WHAT_WE_KNOW_NOW}}",
        "E: {{WHAT_WE_ARE_DOING_NEXT}}",
        "N: {{NEXT_STEP_FOR_CUSTOMER}}",
        "N: {{NEXT_UPDATE_PROMISE}}"
      ]
    },
    {
      id: "repairs_delay",
      title: "Repairs delay (parts / garage queue)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: Repairs are currently delayed due to {{DELAY_REASON}}.",
        "E: The latest estimated timing is {{ETA_WINDOW}}.",
        "N: I’ll update you on {{NEXT_UPDATE_DAY}} — sooner if we get movement.",
        "N: If you have any deadlines (work / travel), tell me and I’ll note it."
      ]
    },
    {
      id: "liability_pending",
      title: "Liability pending (still being assessed)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: Liability hasn’t been confirmed yet — we’re still reviewing {{EVIDENCE_ITEMS}}.",
        "E: Until that’s confirmed, some steps may stay on hold (to avoid you being out of pocket).",
        "N: Next update by {{TIME}} on {{NEXT_UPDATE_DAY}}.",
        "N: If you have any additional evidence (dashcam / photos), you can send it here."
      ]
    },
    {
      id: "docs_request",
      title: "Documents request (minimal, clear)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: To keep this moving, we still need: {{DOC_LIST}}.",
        "E: You can reply here with photos/scans — just make sure {{DOC_QUALITY_NOTE}}.",
        "N: Once received, we’ll review within {{REVIEW_WINDOW}} and update you.",
        "N: If you can’t access one of these, tell me — we’ll work around it."
      ]
    },
    {
      id: "cost_excess_clarity",
      title: "Cost / excess clarity (no surprises)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: Your excess is £{{EXCESS}} (the first part of the claim you pay).",
        "E: We’ll confirm any payable amount before repairs are authorised.",
        "N: Right now we’re at {{CURRENT_STAGE}} — next step is {{NEXT_STAGE}}.",
        "N: I’ll update you {{NEXT_UPDATE_DAY}} (or sooner)."
      ]
    },
    {
      id: "escalation_safe_update",
      title: "Escalation-safe holding message (calm + accountable)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: I don’t want to guess — I’m checking {{WHAT_I_AM_CHECKING}} now.",
        "E: I’ll update you by {{TIME}} today, even if it’s just to confirm progress.",
        "N: If you’d prefer, I can arrange {{ALTERNATE_CONTACT_OPTION}}.",
        "N: Thank you for your patience — I’ll keep you posted."
      ]
    },
    {
      id: "hire_car_boundaries",
      title: "Hire car / mobility (clear boundaries)",
      blocks: [
        "A: {{EMPATHY_OPENER}}",
        "E: On hire cars: {{HIRE_CAR_POSITION}}.",
        "E: The next thing we need is {{HIRE_CAR_DEPENDENCY}}.",
        "N: If you rely on your car for work or caring responsibilities, tell me — it helps us prioritise.",
        "N: Next update: {{NEXT_UPDATE_DAY}}."
      ]
    },
    {
      id: "complaint_preventive",
      title: "Complaint-preventive clarification (de-escalate)",
      blocks: [
        "A: I hear you — this hasn’t been smooth.",
        "E: Right now the delay is due to {{DELAY_REASON}} (not anything you’ve done).",
        "E: Here’s what’s already completed: {{DONE_LIST}}.",
        "N: Next step is {{NEXT_STEP}} and I’ll update you by {{TIME}}.",
        "N: If you want, I can summarise everything so far in one message."
      ]
    }
  ];


  const PLACEHOLDERS = {
    initialCustomer: "Hi, I need help with my claim.",
    initialAgent: "Hi,\nThanks for reaching out, how can I help?",
    defaultCustomer: "Type the customer's message here…",
    defaultAgent: "Write your message here…"
  };


  function setupAgentTips(){
    const line = el.phoneTipline;
    const ticker = el.agentTipTicker;
    if (!line || !ticker) return;

    let tipIdx = 0;
    let tmo = 0;
    let typing = false;
    let complete = false;
    let advanceOnComplete = false;

    // Human-ish pacing (slower, less distracting)
    const HOLD_MIN = 60_000;   // 1 min
    const HOLD_MAX = 120_000;  // 2 min
    const TYPE_MIN = 55;       // ms per char (base)
    const TYPE_MAX = 110;
    const SPACE_MIN = 35;
    const SPACE_MAX = 90;
    const PUNCT_MIN = 180;
    const PUNCT_MAX = 340;
    const STOP_MIN  = 260;
    const STOP_MAX  = 520;

    // Force "typo then fix" on a few tips (3–4), plus a low random chance on long tips
    const TYPO_TIPS = new Set([1, 6, 10, 15]);

    const rand = (a,b) => a + Math.random() * (b-a);

    function clearTimers(){
      if (tmo) { clearTimeout(tmo); tmo = 0; }
    }

    function fadeOutThen(next){
      line.classList.add("tip-fade-out");
      tmo = setTimeout(() => {
        line.classList.remove("tip-fade-out");
        next();
      }, 260);
    }

    function pickFlourish(text, idx){
      const force = TYPO_TIPS.has(idx);
      const chance = (!force && text.length > 60 && Math.random() < 0.10);
      if (!force && !chance) return null;

      const at = Math.floor(rand(10, Math.min(30, text.length - 6)));
      const wrongChar = String.fromCharCode(97 + Math.floor(Math.random()*26));
      return { at, wrongChar };
    }

    function typeTip(text, idx){
      clearTimers();
      typing = true;
      complete = false;
      advanceOnComplete = false;
      ticker.textContent = "";

      let i = 0;
      const flourish = pickFlourish(text, idx);
      let didFlourish = false;

      function step(){
        // flourish: insert 1 wrong char, pause, then remove and continue
        if (flourish && !didFlourish && i === flourish.at){
          didFlourish = true;
          ticker.textContent = text.slice(0, i) + flourish.wrongChar;
          tmo = setTimeout(() => {
            // "backspace"
            ticker.textContent = text.slice(0, i);
            tmo = setTimeout(step, rand(120, 220));
          }, rand(220, 420));
          return;
        }

        ticker.textContent = text.slice(0, i);
        i++;

        if (i <= text.length){
          const ch = text[i-1] || "";
          let base = rand(TYPE_MIN, TYPE_MAX);

          if (ch === " ") base = rand(SPACE_MIN, SPACE_MAX);
          if (/[.,;:—–-]/.test(ch)) base = rand(PUNCT_MIN, PUNCT_MAX);
          if (/[!?]/.test(ch) || ch === ".") base = rand(STOP_MIN, STOP_MAX);

          // occasional "breath" pause (subtle)
          if (/[—–,]/.test(ch) && Math.random() < 0.12) base += rand(140, 380);

          tmo = setTimeout(step, base);
        } else {
          typing = false;
          complete = true;

          const hold = advanceOnComplete ? rand(220, 360) : rand(HOLD_MIN, HOLD_MAX);
          tmo = setTimeout(() => {
            fadeOutThen(() => nextTip());
          }, hold);
        }
      }

      step();
    }

    function nextTip(){
      clearTimers();
      tipIdx = (tipIdx + 1) % AGENT_TIPS.length;
      typeTip(AGENT_TIPS[tipIdx], tipIdx);
    }

    // Click send dot: advance once the current tip is complete
    function nudgeNextTip(){
      if (!complete) { advanceOnComplete = true; return; }
      clearTimers();
      fadeOutThen(() => nextTip());
    }

    window.__MF_TIP_NUDGE = nudgeNextTip;

    // Start
    tipIdx = 0;
    typeTip(AGENT_TIPS[tipIdx], tipIdx);
  }

  const state = {
    messages: [],
    drafts: { agent: "", customer: "" },
    composeTray: { blocks: [], keepAfterCommit: false },
    motionOn: false,
    checkerOn: true,
    themeMode: "lunar",
    themeIndex: 1,
    textSize: 1,
    previewOn: true,
    glassMode: "frosted",
    lastEdited: "agent",
    hasCommitted: false,
    placeholdersMode: "initial",


    // Phase-F analysis caches (single truth → many views)
    analysis: {
      writer: {
        text: "",
        matchesRaw: [],
        matchesEffective: [],
        issues: [],
        counts: { ukus: 0, jargon: 0, clarity: 0, tone: 0 },
        flags: { clarity: [], tone: [] }
      }
    },

    // Ignore policies (Lite): ignore-once (this match) + ignore-rule (this term/rule)
    ignore: {
      once: new Set(),
      rules: new Set(),
      hidden: new Set()
    },
  // Option 1 rolling customer replies
    demoCustomerIndex: 0,
    customerTyping: false,
  };

  const el = {
    customerMsg: document.getElementById("customerMsg"),
    agentDraft: document.getElementById("agentDraft"),
  agentDraftOverlay: document.getElementById("agentDraftOverlay"),
  agentDraftTip: document.getElementById("agentDraftTip"),
    addCustomerBtn: document.getElementById("addCustomerBtn"),
    sendAgentBtn: document.getElementById("sendAgentBtn"),
    clearBtn: document.getElementById("clearBtn"),
charCount: document.getElementById("charCount"),
    ukusCount: document.getElementById("ukusCount"),
    jargonCount: document.getElementById("jargonCount"),
    checkerBtn: document.getElementById("checkerBtn"),
    checkerState: document.getElementById("checkerState"),
    pasteBtn: document.getElementById("pasteBtn"),
    copyBtn: document.getElementById("copyBtn"),

    modeSol: document.getElementById("modeSol"),
    modeLunar: document.getElementById("modeLunar"),
    sw: [document.getElementById("sw0"),document.getElementById("sw1"),document.getElementById("sw2"),document.getElementById("sw3")],
    diceBtn: document.getElementById("diceBtn"),
    fxBtn: document.getElementById("fxBtn"),
    themeLabel: document.getElementById("themeLabel"),

    chatList: document.getElementById("chatList"),
    phoneTipline: document.getElementById("phoneTipline"),
    agentTipTicker: document.getElementById("agentTipTicker"),
    timeNow: document.getElementById("timeNow"),
    chatCount: document.getElementById("chatCount"),
    phoneSendBtn: document.getElementById("phoneSendBtn"),

    wordCount: document.getElementById("wordCount"),

    focusPhoneBtn: document.getElementById("focusPhoneBtn"),
    previewToggle: document.getElementById("previewToggle"),
    previewState: document.getElementById("previewState"),
    glassToggle: document.getElementById("glassToggle"),
    glassState: document.getElementById("glassState"),
    focusEditorBtn: document.getElementById("focusEditorBtn"),
    exitFocusBtnPhone: document.getElementById("exitFocusBtnPhone"),
    exitFocusBtnDraft: document.getElementById("exitFocusBtnDraft"),

    btnBold: document.getElementById("btnBold"),
    btnItalic: document.getElementById("btnItalic"),
    btnUnderline: document.getElementById("btnUnderline"),
    btnStrike: document.getElementById("btnStrike"),
    btnQuote: document.getElementById("btnQuote"),
    btnChecklist: document.getElementById("btnChecklist"),
    btnCode: document.getElementById("btnCode"),
    btnLink: document.getElementById("btnLink"),
    btnBullets: document.getElementById("btnBullets"),
btnIndent: document.getElementById("btnIndent"),
    btnOutdent: document.getElementById("btnOutdent"),
    btnUndo: document.getElementById("btnUndo"),
    btnRedo: document.getElementById("btnRedo"),
    btnHighlight: document.getElementById("btnHighlight"),
    btnClearFmt: document.getElementById("btnClearFmt"),
    btnRule: document.getElementById("btnRule"),
    btnPasteTop: document.getElementById("btnPasteTop"),
    btnCopyTop: document.getElementById("btnCopyTop"),
    btnClearTop: document.getElementById("btnClearTop"),
    btnClean: document.getElementById("btnClean"),
    btnReplies: document.getElementById("btnReplies"),
    btnPhrases: document.getElementById("btnPhrases"),
    btnCompose: document.getElementById("cxTab_compose"),
    composeCount: document.getElementById("composeCount"),

    composeBlocksN: document.getElementById("composeBlocksN"),
    composeKeepToggle: document.getElementById("composeKeepToggle"),
    composeKeepState: document.getElementById("composeKeepState"),
    composePanelMount: document.getElementById("composePanelMount"),

    ts: [document.getElementById("ts0"),document.getElementById("ts1"),document.getElementById("ts2"),document.getElementById("ts3")],

    canvas: document.getElementById("bgParticles"),

    writerUKUSN: document.getElementById("writerUKUSN"),
    writerJargonN: document.getElementById("writerJargonN"),
    writerUKUSN2: document.getElementById("writerUKUSN2"),
    writerJargonN2: document.getElementById("writerJargonN2"),
    writerClarityN: document.getElementById("writerClarityN"),
    writerToneN: document.getElementById("writerToneN"),
    writerList: document.getElementById("writerList"),
    ukusList: document.getElementById("ukusList"),
    jargonList: document.getElementById("jargonList"),
    expMoneyN: document.getElementById("expMoneyN"),
    expStressN: document.getElementById("expStressN"),
    expVulnN: document.getElementById("expVulnN"),
    expList: document.getElementById("expList"),
  };

  // Cache key panels (Lite-safe)
  el.insightsPanel = document.querySelector('.panel[data-panel="insights"]');

  const nowHM = () => {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  };

  const wordCount = (s) => {
    const t = (s || "").trim();
    if (!t) return 0;
    return t.split(/\\s+/).filter(Boolean).length;
  };

  const safeText = (s) => (s || "").replace(/\\r\\n/g, "\\n");
  const scrollToBottom = () => { el.chatList.scrollTop = el.chatList.scrollHeight + 9999; };

  function applyInputPlaceholders(mode){
    const m = mode || state.placeholdersMode || "initial";
    const isInitial = (m === "initial");
    el.customerMsg.placeholder = isInitial ? PLACEHOLDERS.initialCustomer : PLACEHOLDERS.defaultCustomer;
    // Newlines in placeholder are supported in modern browsers; keep it readable
    el.agentDraft.placeholder = isInitial ? PLACEHOLDERS.initialAgent : PLACEHOLDERS.defaultAgent;
    state.placeholdersMode = isInitial ? "initial" : "default";
  }

  function getActivePreview(){
    if (!state.previewOn) return null;
    const a = (state.drafts.agent || "").trim();
    const c = (state.drafts.customer || "").trim();
    // Prefer the field the user is actively editing
    if (state.lastEdited === "customer" && c) return { role: "customer", text: c };
    if (state.lastEdited === "agent" && a) return { role: "agent", text: a };
    // Fallback: whichever has content
    if (a) return { role: "agent", text: a };
    if (c) return { role: "customer", text: c };
    return null;
  }

  function bindChatflowDnD(){
    let dragFrom = null;
    const list = el.chatList;
    if (!list) return;

    list.addEventListener("dragstart", (e) => {
      const b = e.target && e.target.closest && e.target.closest(".bubble.draggable");
      if (!b) return;
      dragFrom = Number(b.dataset.idx);
      b.classList.add("dragging");
      try{
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", String(dragFrom));
      }catch(_){}
    });

    list.addEventListener("dragover", (e) => {
      // allow drop
      if (dragFrom === null) return;
      e.preventDefault();
      const b = e.target && e.target.closest && e.target.closest(".bubble.draggable");
      if (b) b.classList.add("drop-target");
    });

    list.addEventListener("dragleave", (e) => {
      const b = e.target && e.target.closest && e.target.closest(".bubble.draggable");
      if (b) b.classList.remove("drop-target");
    });

    list.addEventListener("drop", (e) => {
      if (dragFrom === null) return;
      e.preventDefault();

      const targetBubble = e.target && e.target.closest && e.target.closest(".bubble.draggable");
      let to = targetBubble ? Number(targetBubble.dataset.idx) : state.messages.length;

      const from = dragFrom;
      dragFrom = null;

      if (Number.isNaN(from) || Number.isNaN(to) || from === to) { render(); return; }
      if (from < 0 || from >= state.messages.length) { render(); return; }
      if (to < 0) to = 0;
      if (to > state.messages.length) to = state.messages.length;

      // move item (adjust index when moving downward)
      const item = state.messages.splice(from, 1)[0];
      const adjTo = (from < to) ? Math.max(0, to - 1) : to;
      state.messages.splice(adjTo, 0, item);
      render();
    });

    list.addEventListener("dragend", () => {
      dragFrom = null;
      list.querySelectorAll(".dragging").forEach(n => n.classList.remove("dragging"));
      list.querySelectorAll(".drop-target").forEach(n => n.classList.remove("drop-target"));
    });
  }


  function setCSSVars(vars){
    const root = document.documentElement.style;
    for (const k in vars) root.setProperty(k, vars[k]);
  }

  function toast(msg, isWarn=false){
    let t = document.getElementById("mfToast");
    if (!t){
      t = document.createElement("div");
      t.id = "mfToast";
      t.style.position = "fixed";
      t.style.left = "50%";
      t.style.bottom = "18px";
      t.style.transform = "translateX(-50%)";
      t.style.padding = "10px 12px";
      t.style.borderRadius = "12px";
      t.style.border = "1px solid rgba(255,255,255,.16)";
      t.style.background = "rgba(0,0,0,.55)";
      t.style.color = "rgba(255,255,255,.92)";
      t.style.fontSize = "12.5px";
      t.style.boxShadow = "0 10px 30px rgba(0,0,0,.45)";
      t.style.zIndex = "9999";
      t.style.backdropFilter = "blur(10px)";
      t.style.opacity = "0";
      t.style.transition = "opacity .12s ease";
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.borderColor = isWarn ? "rgba(255,120,120,.35)" : "rgba(122,180,255,.28)";
    t.style.opacity = "1";
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { t.style.opacity = "0"; }, 1100);
  }

  function persistPayload() {
    // UI-lock v1: persist only UI/settings (never drafts/transcript)
    return {
      themeMode: state.themeMode,
      themeIndex: state.themeIndex,
      motionOn: state.motionOn,
      checkerOn: state.checkerOn,
      textSize: state.textSize,
    };
  }

  function persistSave(silent=false) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(persistPayload()));
      if (!silent) toast("Saved");
    } catch (e) {
      if (!silent) toast("Save failed (storage blocked)", true);
    }
  }

  function persistLoad() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const data = JSON.parse(raw);
      if (!data || typeof data !== "object") return;

      if (typeof data.themeMode === "string") state.themeMode = data.themeMode;
      if (Number.isFinite(data.themeIndex)) state.themeIndex = data.themeIndex;
      if (typeof data.motionOn === "boolean") state.motionOn = data.motionOn;
      if (typeof data.checkerOn === "boolean") state.checkerOn = data.checkerOn;
      if (Number.isFinite(data.textSize)) state.textSize = data.textSize;
    } catch (e) {}
  }

  
function paintSkySwatches(){
  const list = THEMES[state.themeMode] || [];
  // paint the 5 sky theme swatches so they’re visually distinct (no default-white buttons)
  el.sw.forEach((b,i)=>{
    const t = list[i] || list[0];
    if(!t) return;
    b.style.setProperty("--sw1", (t.sw && t.sw.sky && t.sw.sky[0]) ? t.sw.sky[0] : "#ffffff");
    b.style.setProperty("--sw2", (t.sw && t.sw.sky && t.sw.sky[1]) ? t.sw.sky[1] : "#000000");
    b.title = t.name || ("Theme " + (i+1));
    b.setAttribute("aria-label", t.name || ("Theme " + (i+1)));
  });
}

function applyTheme(opts={}){
    const animate = (opts.animate != null) ? !!opts.animate : !!state.motionOn;
    const user = (opts.user !== false);

    const mode = state.themeMode;
    document.body.dataset.tmode = mode;
    paintSkySwatches();
    const idx = Math.max(0, Math.min((THEMES[mode].length-1), state.themeIndex|0));
    state.themeIndex = idx;

    el.modeSol.dataset.active = (mode === "sol");
    el.modeLunar.dataset.active = (mode === "lunar");
    el.sw.forEach((b,i)=> b.dataset.active = (i === idx));

    const theme = THEMES[mode][idx];
    el.themeLabel.textContent = theme.name;

    const vars = Object.assign({}, theme.vars, {
      "--custBubble": theme.sw.cust,
      "--agentBubble": theme.sw.agent
    });

    // BG Builder preset overrides (background + accent mapping)
    // This keeps Lite backgrounds deterministic, and swaps only by Sol/Lunar mode.
    const __bgPreset = mfGetBgPresetForTheme(mode);
    document.body.dataset.theme = __bgPreset.themeKey;
    document.body.dataset.colour = __bgPreset.colour;
    document.body.dataset.poly = "none";
    document.body.dataset.pattern = __bgPreset.pattern;
    document.body.dataset.bgmode = __bgPreset.bgmode;

    Object.assign(vars, __bgPreset.css, {
      "--bg0": __bgPreset.css["--bg-c1"] || vars["--bg0"],
      "--bg1": __bgPreset.css["--bg-c2"] || vars["--bg1"],
      "--accent": __bgPreset.css["--bg-c3"] || vars["--accent"],
      "--accent2": __bgPreset.css["--bg-c4"] || vars["--accent2"]
    });

    // If animations are ON, keep panels a touch more translucent so background FX are visible
    if(state.motionOn){
      if(vars["--panelA"]) vars["--panelA"] = scaleAlpha(vars["--panelA"], 0.55);
      if(vars["--panelB"]) vars["--panelB"] = scaleAlpha(vars["--panelB"], 0.55);
      if(vars["--stroke"]) vars["--stroke"] = scaleAlpha(vars["--stroke"], 0.85);
      vars["--shadow"] = "rgba(0,0,0,.52)";
    }

    if(animate){
      tweenCSSVars(vars, 1200, () => syncParticleColours());
      try{ if(P.running){ resizeCanvas(); makeParts(); } }catch(_){ }
    } else {
      setCSSVars(vars);
      syncParticleColours();
      try{ if(P.running){ resizeCanvas(); makeParts(); } }catch(_){ }
    }

    // If user changed theme while motion is on, reset auto-shuffle timer
    if(user && state.motionOn) touchThemeShuffleTimer();
  }

  function applyTextSize(){
    const scale = [0.92, 1.0, 1.08, 1.16][Math.max(0, Math.min(3, state.textSize|0))];
    document.documentElement.style.setProperty("--phone-font-scale", String(scale));
    el.ts.forEach((b, i) => b.dataset.active = (i === state.textSize) ? "true" : "false");
  }


// --- P1d: Phone scaling (fit without stretch) ---
function updatePhoneScale(){
  const wrap = document.querySelector('.panel[data-panel="phone"] .phone-wrap');
  const body = document.querySelector('.panel[data-panel="phone"] .phone-panel-body');
  if(!wrap || !body) return;

  // available space inside phone panel body (minus padding)
  const pad = 24; // approx body padding * 2
  let availW = Math.max(0, body.clientWidth - pad);
  let availH = Math.max(0, body.clientHeight - pad);

  // subtract any footer controls that sit under the phone (e.g., text size row)
  const textSizeRow = body.querySelector('.textsize');
  if(textSizeRow) availH = Math.max(0, availH - (textSizeRow.offsetHeight + 10));

  const baseW = 380, baseH = 760;
  const s = Math.min(1, availW / baseW, availH / baseH);
  document.documentElement.style.setProperty('--phone-scale', String(isFinite(s) ? s : 1));
}

// --- Theme tween helpers (smooth blending) ---

  // --- Rich-text (lightweight) rendering for Phone™ bubbles ---
  // Toolbars insert lightweight markers (e.g. **bold**, *italic*, ==highlight==).
  // We render those markers as formatting in the phone preview, while keeping the draft plain.
  function escapeHTML(s){
    return String(s ?? "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }
  function renderRichInline(text){
    let out = escapeHTML(text);
    // Strong, em, highlight (simple non-nested)
    out = out.replace(/\*\*([^\n]+?)\*\*/g, "<strong>$1</strong>");
    out = out.replace(/\*([^\n]+?)\*/g, "<em>$1</em>");
    out = out.replace(/==([^\n]+?)==/g, "<mark>$1</mark>");
    // Links: [text](https://...)
    out = out.replace(/\[([^\]]+?)\]\((https?:\/\/[^\s)]+)\)/g,
      '<a href="$2" target="_blank" rel="noopener">$1</a>');
    // Newlines
    out = out.replace(/\n/g, "<br>");
    return out;
  }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function parseColor(str){
  if(!str) return null;
  const s = String(str).trim();
  const hex = s.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if(hex){
    let h = hex[1];
    if(h.length === 3) h = h.split("").map(ch=>ch+ch).join("");
    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
    return {r,g,b,a:1};
  }
  const rgba = s.match(/^rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)$/i);
  if(rgba){
    const r = +rgba[1], g = +rgba[2], b = +rgba[3];
    const a = rgba[4] == null ? 1 : +rgba[4];
    if([r,g,b,a].some(v=>Number.isNaN(v))) return null;
    return {r,g,b,a};
  }
  return null;
}
function rgbaStr(c){
  const r = Math.round(c.r), g = Math.round(c.g), b = Math.round(c.b);
  const a = Math.round(c.a*1000)/1000;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
function blendColor(a,b,t){
  const tt = clamp01(t);
  return { r: a.r + (b.r-a.r)*tt, g: a.g + (b.g-a.g)*tt, b: a.b + (b.b-a.b)*tt, a: a.a + (b.a-a.a)*tt };
}
function scaleAlpha(col, factor){
  const c = parseColor(col);
  if(!c) return col;
  return rgbaStr({r:c.r,g:c.g,b:c.b,a: clamp01(c.a*factor)});
}
function tweenCSSVars(targetVars, duration=1200, onFrame){
  const root = document.documentElement;
  const cs = getComputedStyle(root);
  const keys = Object.keys(targetVars||{});
  const colorKeys = [];
  const from = {};
  const to = {};
  keys.forEach(k=>{
    const v = (targetVars[k] ?? "").toString().trim();
    const pc = parseColor(v);
    if(pc){
      const current = cs.getPropertyValue(k).trim();
      const cc = parseColor(current) || pc;
      colorKeys.push(k);
      from[k] = cc;
      to[k] = pc;
    } else {
      root.style.setProperty(k, v);
    }
  });
  if(!colorKeys.length) return;
  const t0 = performance.now();
  function step(now){
    const t = clamp01((now - t0) / duration);
    colorKeys.forEach(k=>{
      root.style.setProperty(k, rgbaStr(blendColor(from[k], to[k], t)));
    });
    if(typeof onFrame === "function") onFrame(t);
    if(t < 1) requestAnimationFrame(step);
    else colorKeys.forEach(k=> root.style.setProperty(k, (targetVars[k] ?? "").toString().trim()));
  }
  requestAnimationFrame(step);
}


  function setFocus(mode){
    document.body.dataset.focus = mode; // none | phone | editor
    if (mode === "editor") setTimeout(() => el.agentDraft.focus(), 0);
  
  updatePhoneScale();
}

  function normaliseWhitespace(text){
    let t = safeText(text);
    t = t.split("\\n").map(line => line.replace(/[ \\t]+$/g, "")).join("\\n");
    t = t.replace(/\\n{3,}/g, "\\n\\n");
    return t.trim();
  }

  function wrapSelection(textarea, left, right){
    const v = textarea.value;
    const start = textarea.selectionStart ?? 0;
    const end = textarea.selectionEnd ?? 0;
    const selected = v.slice(start, end);
    const next = v.slice(0, start) + left + selected + right + v.slice(end);
    textarea.value = next;
    const cursor = start + left.length + selected.length + right.length;
    textarea.setSelectionRange(cursor, cursor);


function insertMarkdownLink(textarea){
  const v = textarea.value || "";
  const start = textarea.selectionStart ?? 0;
  const end = textarea.selectionEnd ?? 0;
  const selected = v.slice(start, end);

  const label = selected || (window.prompt("Link text:", "") || "").trim();
  if (!label) return;
  const url = (window.prompt("URL (include https://):", "https://") || "").trim();
  if (!url) return;

  const md = `[${label}](${url})`;
  textarea.value = v.slice(0, start) + md + v.slice(end);
  const cursor = start + md.length;
  textarea.setSelectionRange(cursor, cursor);
  textarea.focus();
}

    textarea.focus();
  }

  function addListPrefix(textarea, mode){
    const v = textarea.value;
    const start = textarea.selectionStart ?? 0;
    const end = textarea.selectionEnd ?? 0;

    const before = v.slice(0, start);
    const after = v.slice(end);

    const lineStart = before.lastIndexOf("\\n") + 1;
    const endIdx = (() => {
      const p = after.indexOf("\\n");
      return (p === -1) ? v.length : (end + p + 1);
    })();

    const block = v.slice(lineStart, endIdx);
    const lines = block.split("\\n");

    const out = lines.map((ln, i) => {
      const trimmed = ln.replace(/^\\s+/, "");
      if (!trimmed) return ln;
            if (mode === "bullets") return `- ${trimmed}`;
      if (mode === "quote") return `> ${trimmed}`;
      if (mode === "check") return `- [ ] ${trimmed}`;
      return `${i+1}. ${trimmed}`;
    }).join("\\n");

    const next = v.slice(0, lineStart) + out + v.slice(endIdx);
    textarea.value = next;
    textarea.setSelectionRange(lineStart, lineStart + out.length);
    textarea.focus();
  }

  const hist = { stack: [], idx: -1, locked: false };
  function histPush(value){
    if (hist.locked) return;
    const v = value ?? "";
    const last = hist.stack[hist.idx];
    if (last === v) return;
    hist.stack = hist.stack.slice(0, hist.idx + 1);
    hist.stack.push(v);
    hist.idx = hist.stack.length - 1;
  }
  function histUndo(){
    if (hist.idx <= 0) return;
    hist.idx -= 1;
    hist.locked = true;
    el.agentDraft.value = hist.stack[hist.idx] ?? "";
    state.drafts.agent = el.agentDraft.value;
    hist.locked = false;
    render();
  }
  function histRedo(){
    if (hist.idx >= hist.stack.length - 1) return;
    hist.idx += 1;
    hist.locked = true;
    el.agentDraft.value = hist.stack[hist.idx] ?? "";
    state.drafts.agent = el.agentDraft.value;
    hist.locked = false;
    render();
  }

  function countUKUS(text){
    const t = (text || "");
    let n = 0;
    for (const p of ENGINE.ukus.pairs){
      n += ENGINE.util.countMatches(p.re, t);
    }
    return n;
  }
  function countJargon(text){
    const t = (text || "");
    let n = 0;
    for (const r of ENGINE.jargon.rules){
      n += ENGINE.util.countMatches(r.re, t);
    }
    return n;
  }



  function listUKUSFindings(text){
    const t = (text || "");
    const out = [];
    for (const p of ENGINE.ukus.pairs){
      const c = ENGINE.util.countMatches(p.re, t);
      if (c) out.push({ id: p.id, us: p.us, uk: p.uk, n: c, type: p.type, badge: p.badge, notes: p.notes });
    }
    out.sort((a,b)=>b.n-a.n);
    return out;
  }
  function listJargonFindings(text){
    const t = (text || "");
    const out = [];
    for (const r of ENGINE.jargon.rules){
      const c = ENGINE.util.countMatches(r.re, t);
      if (c) out.push({ id: r.id, term: r.term, n: c, suggestion: r.suggestion, notes: r.notes });
    }
    out.sort((a,b)=>b.n-a.n);
    return out;
  }

  // === Writer Insights: action centre (Jump / Apply / Ignore) — RESTORED ===

  function _normTerm(s) {
      return String(s || "").toLowerCase();
    }

  function _makeIgnoreKey(kind, ruleId, text) {
      const rid = ruleId ? String(ruleId) : "";
      return `${kind}:${rid}:${_normTerm(text)}`;
    }

  function _priorityForKind(kind) {
      // Overlap policy (simple, deterministic): higher wins; no nesting.
      // You can expand this later to severity stacking / segment splitting.
      if (kind === "jargon") return 30;
      if (kind === "ukus") return 20;
      return 10;
    }

  function _findAllMatches(re, text) {
      const out = [];
      if (!re || !text) return out;
      // Ensure global search
      const flags = re.flags.includes("g") ? re.flags : re.flags + "g";
      const rx = new RegExp(re.source, flags);
      let m;
      while ((m = rx.exec(text)) !== null) {
        // Avoid infinite loops on zero-length matches
        if (m.index === rx.lastIndex) rx.lastIndex++;
        out.push({ start: m.index, end: m.index + m[0].length, text: m[0] });
      }
      return out;
    }

  function buildDraftMatchListRaw(text) {
      const t = String(text || "");
      const matches = [];
  
      // UK/US
      for (const p of ENGINE.ukus.pairs) {
        const spots = _findAllMatches(p.re, t);
        for (const s of spots) {
          const id = `${p.id}@${s.start}-${s.end}`;
          matches.push({
            id,
            kind: "ukus",
            start: s.start,
            end: s.end,
            text: s.text,
            ruleId: p.id,
            detectorId: "det_ukus_v1",
            severity: "warn",
            priority: _priorityForKind("ukus"),
            ignoreKey: _makeIgnoreKey("ukus", p.id, s.text),
            suggestions: [{
              id: "use_uk_spelling",
              label: "Use UK spelling",
              replacement: p.uk,
              reason: `UK spelling preferred for "${s.text}".`
            }],
            tooltip: `UK spelling: ${s.text} → ${p.uk}`,
          });
        }
      }
  
      // Jargon
      for (const r of ENGINE.jargon.rules) {
        const rx = new RegExp(r.pattern, r.flags.includes("g") ? r.flags : r.flags + "g");
        const spots = _findAllMatches(rx, t);
        for (const s of spots) {
          const id = `${r.id}@${s.start}-${s.end}`;
          matches.push({
            id,
            kind: "jargon",
            start: s.start,
            end: s.end,
            text: s.text,
            ruleId: r.id,
            detectorId: "det_jargon_v1",
            severity: "warn",
            priority: _priorityForKind("jargon"),
            ignoreKey: _makeIgnoreKey("jargon", r.id, s.text),
            suggestions: [{
              id: "use_plain_english",
              label: "Use plain English",
              replacement: r.suggestion || "",
              reason: r.notes || "Consider a plain-English alternative."
            }],
            tooltip: r.notes || "Consider a plain-English alternative.",
          });
        }
      }
  
      return matches;
    }

  function isIgnoredMatch(m) {
      try {
        if (state.ignore && state.ignore.once && state.ignore.once.has(m.id)) return true;
        if (state.ignore && state.ignore.rules && state.ignore.rules.has(m.ignoreKey)) return true;
      } catch (e) {}
      return false;
    }

  function resolveDraftMatchesEffective(raw) {
      const list = (raw || []).filter(m => !isIgnoredMatch(m));
  
      // Overlap policy: highest priority wins, no nesting.
      // Sort by start asc; for ties, higher priority first; then longer match first.
      list.sort((a, b) =>
        (a.start - b.start) ||
        ((b.priority || 0) - (a.priority || 0)) ||
        ((b.end - b.start) - (a.end - a.start))
      );
  
      const out = [];
      let lastEnd = -1;
  
      for (const m of list) {
        if (out.length === 0 || m.start >= lastEnd) {
          out.push(m);
          lastEnd = m.end;
          continue;
        }
        // overlap with last accepted
        const prev = out[out.length - 1];
        const prevPri = prev.priority || 0;
        const curPri = m.priority || 0;
  
        if (curPri > prevPri) {
          out[out.length - 1] = m;
          lastEnd = m.end;
        }
        // else: keep prev, drop current
      }
      return out;
    }

  function _classifyUkusCategory(fromWord, toWord) {
      const a = String(fromWord || "").toLowerCase();
      const b = String(toWord || "").toLowerCase();
      if (!a || !b || a === b) return "variant";
  
      // Common UK/US patterns (label shows US→UK style change)
      if (a.endsWith("or") && b.endsWith("our")) return "or→our";
      if (a.endsWith("ize") && b.endsWith("ise")) return "ize→ise";
      if (a.endsWith("yze") && b.endsWith("yse")) return "yze→yse";
      if (a.endsWith("er") && b.endsWith("re")) return "er→re";
      if (a.endsWith("ense") && b.endsWith("ence")) return "ense→ence";
      if (a.endsWith("se") && b.endsWith("ce")) return "se→ce";
      if (a.endsWith("og") && b.endsWith("ogue")) return "og→ogue";
  
      // Double consonant before suffix (traveling→travelling, canceled→cancelled)
      if (b.length === a.length + 1) {
        // crude check: one extra repeated letter in UK form
        for (let i = 0; i < b.length - 1; i++) {
          if (b[i] === b[i + 1]) {
            const b2 = b.slice(0, i) + b.slice(i + 1);
            if (b2 === a) return "double consonant";
          }
        }
      }
  
      // Aluminium / aeroplane-type insertions
      if (a.includes("um") && b.includes("ium") && b.replace("ium", "um") === a) return "ium insertion";
      if (a.includes("air") && b.includes("aero")) return "aero variant";
  
      return "variant";
    }

  function deriveWriterIssues(matchesEffective) {
      const eff = matchesEffective || [];
      const map = new Map();
      for (const m of eff) {
        const key = m.ignoreKey || m.ruleId || m.id;
        let it = map.get(key);
        if (!it) {
          const rep = (m.suggestions && m.suggestions[0] && m.suggestions[0].replacement) ? m.suggestions[0].replacement : "";
          it = {
            id: key,
            kind: m.kind,
            ruleId: m.ruleId || "",
            term: m.text,
            severity: m.severity || "info",
            priority: m.priority || 0,
            ignoreKey: m.ignoreKey || "",
            suggestions: m.suggestions || [],
            occurrences: [],
            // Extra context for Insights (Lite-safe, derived only)
            category: (m.kind === "ukus") ? _classifyUkusCategory(m.text, rep) : "",
            explain: (m.kind === "jargon")
              ? (m.tooltip || (m.suggestions && m.suggestions[0] && m.suggestions[0].reason) || "")
              : "",
            plainEnglish: (m.kind === "jargon") ? rep : "",
            title:
              m.kind === "ukus" ? `UK spelling: ${m.text} → ${rep}` :
              m.kind === "jargon" ? `Jargon: ${m.text}${rep ? ` → ${rep}` : ""}` :
              `${m.kind}: ${m.text}`,
            tooltip: m.tooltip || ""
          };
          map.set(key, it);
        }
        it.occurrences.push({ id: m.id, start: m.start, end: m.end, text: m.text });
      }
      const sevRank = { blocker: 4, risk: 3, warn: 2, info: 1 };
      const arr = Array.from(map.values());
      arr.sort((a, b) =>
        ((sevRank[b.severity] || 0) - (sevRank[a.severity] || 0)) ||
        ((b.priority || 0) - (a.priority || 0)) ||
        ((b.occurrences.length || 0) - (a.occurrences.length || 0)) ||
        (a.title || "").localeCompare(b.title || "")
      );
      return arr;
    }

  function _groupBy(arr, keyFn) {
      const m = new Map();
      for (const x of (arr || [])) {
        const k = keyFn(x);
        if (!m.has(k)) m.set(k, []);
        m.get(k).push(x);
      }
      return m;
    }


  // --- D-4C: Issue Contract Helpers (safe + additive) ---
  function _safeStr(x, fallback="") { return (typeof x === "string") ? x : fallback; }

  function _safeDomId(s){
    return String(s||"").replace(/[^a-zA-Z0-9\-_.:]/g, "_");
  }

  function _classifyJargonCategory(term, plain, ruleId){
    const t = (_safeStr(term,"")).toLowerCase();
    const p = (_safeStr(plain,"")).toLowerCase();
    const r = (_safeStr(ruleId,"")).toLowerCase();

    // Systems / Databases
    if (t === "mid" || t.includes("dvla") || p.includes("database") || p.includes("records")) return "Systems & Databases";

    // People / Roles
    if (t.includes("policyholder") || t.includes("named driver") || t.includes("insured") || t.includes("claimant")) return "People & Roles";

    // Damage / Repair
    if (t.includes("category s") || t.includes("category n") || t.includes("structural") || t.includes("write-off") || t.includes("salvage")) return "Damage & Repair";

    // Money / Charges
    if (t.includes("excess") || t.includes("premium") || t.includes("surcharge") || t.includes("settlement") || t.includes("payout")) return "Money & Charges";

    // Process / Journey
    if (t.includes("fnol") || t.includes("liability") || t.includes("indemnity") || t.includes("total loss") || t.includes("repair")) return "Process & Journey";

    // Documents
    if (t.includes("report") || t.includes("summary") || t.includes("invoice") || t.includes("estimate")) return "Documents";

    if (r.includes("jargon")) return "General";
    return "General";
  }

  function _jargonWhy(term, category){
    const c = _safeStr(category, "General");
    if (c === "Systems & Databases") return "Customers may not know what this system is — add a quick explanation.";
    if (c === "People & Roles") return "Role labels can confuse customers — clarify who the person is and what they do.";
    if (c === "Damage & Repair") return "Repair categories affect outcomes — explain what it means for the customer.";
    if (c === "Money & Charges") return "Money language can trigger concern — clarify costs and what happens next.";
    if (c === "Process & Journey") return "Process terms can feel vague — translate into clear next steps.";
    if (c === "Documents") return "Document terms can be unclear — say what it is and why it matters.";
    return "Jargon can reduce clarity — consider a plain-language version.";
  }

  /** Normalize a writer issue to a contract-safe object. Never throws. */
  function _normalizeIssue(issue){
    const kind = _safeStr(issue && issue.kind, "");
    const term = _safeStr(issue && issue.term, "");
    const suggestions = (issue && Array.isArray(issue.suggestions)) ? issue.suggestions : [];
    const occurrences = (issue && Array.isArray(issue.occurrences)) ? issue.occurrences : [];
    const count = occurrences.length;

    const sug0 = suggestions[0] || null;
    const rep = (sug0 && typeof sug0.replacement === "string") ? sug0.replacement : "";
    const plain = _safeStr(issue && (issue.plainEnglish || issue.plain), rep || "");
    const explain = _safeStr(issue && (issue.explain || issue.tooltip), "");

    let category = _safeStr(issue && issue.category, "");
    let why = _safeStr(issue && issue.why, "");
    if (kind === "ukus") {
      if (!category) category = "Spelling (UK preference)";
      if (!why) why = "Keeps spelling consistent for UK customers and docs.";
    } else if (kind === "jargon") {
      if (!category) category = _classifyJargonCategory(term, plain || rep, _safeStr(issue && issue.ruleId, ""));
      if (!why) why = _jargonWhy(term, category);
    } else {
      if (!category) category = "General";
    }

    return {
      id: _safeStr(issue && issue.id, `${kind}:${term}`),
      kind,
      term,
      count,
      category,
      plain,
      why,
      explain,
      severity: _safeStr(issue && issue.severity, "info"),
      title: _safeStr(issue && issue.title, `${kind}: ${term}`),
      suggestions,
      occurrences,
      hidden: (!!(issue && issue.hidden)) || (state.ignore && state.ignore.hidden && state.ignore.hidden.has(_safeStr(issue && issue.id, `${kind}:${term}`))),
      __raw: issue
    };
  }

  function scrollTextareaToPos(ta, pos) {
      if (!ta) return;
      const value = ta.value || "";
      const p = Math.max(0, Math.min(pos, value.length));
  
      // Mirror div technique (safe + predictable)
      const cs = getComputedStyle(ta);
      const div = document.createElement("div");
      div.style.position = "absolute";
      div.style.visibility = "hidden";
      div.style.pointerEvents = "none";
      div.style.whiteSpace = "pre-wrap";
      div.style.wordBreak = "break-word";
      div.style.overflowWrap = "break-word";
      div.style.boxSizing = cs.boxSizing;
      div.style.width = ta.clientWidth + "px";
  
      // Copy text metrics
      div.style.font = cs.font;
      div.style.lineHeight = cs.lineHeight;
      div.style.letterSpacing = cs.letterSpacing;
      div.style.padding = cs.padding;
  
      const before = value.slice(0, p);
      const at = value.slice(p, p + 1) || " ";
      div.textContent = before;
  
      const marker = document.createElement("span");
      marker.textContent = at;
      div.appendChild(marker);
  
      document.body.appendChild(div);
  
      const markerTop = marker.offsetTop;
      const markerBottom = markerTop + marker.offsetHeight;
  
      document.body.removeChild(div);
  
      const viewTop = ta.scrollTop;
      const viewBottom = viewTop + ta.clientHeight;
  
      // Nudge into view (prefer centering a bit)
      if (markerTop < viewTop + 8) {
        ta.scrollTop = Math.max(0, markerTop - 12);
      } else if (markerBottom > viewBottom - 8) {
        ta.scrollTop = Math.max(0, markerBottom - ta.clientHeight + 24);
      }
    }

  function _ensureIssueCursor() {
      state.ui = state.ui || {};
      state.ui.issueCursor = state.ui.issueCursor || Object.create(null);
      return state.ui.issueCursor;
    }

  function jumpToIssue(issue) {
      if (!issue || !issue.occurrences || !issue.occurrences.length) return;
      const cursor = _ensureIssueCursor();
      const idx = (cursor[issue.id] || 0) % issue.occurrences.length;
      cursor[issue.id] = (idx + 1) % issue.occurrences.length;
  
      const occ = issue.occurrences[idx];
      try {
        // Set selection then ensure it is visible (textarea remains truth)
        el.agentDraft.setSelectionRange(occ.start, occ.end);
        el.agentDraft.focus();
        scrollTextareaToPos(el.agentDraft, occ.start);
      } catch (e) {}
  
      toast(`Jumped (${idx + 1}/${issue.occurrences.length})`);
    }

  function ignoreOnceIssue(issue) {
      if (!issue || !issue.occurrences || !issue.occurrences.length) return;
      const cursor = _ensureIssueCursor();
      const idx = (cursor[issue.id] || 0) % issue.occurrences.length;
      const occ = issue.occurrences[idx];
      cursor[issue.id] = (idx + 1) % issue.occurrences.length;
  
      if (occ && occ.id) {
        state.ignore.once.add(occ.id);
        scheduleRender();
        toast("Hidden once.");
      }
    }

  

// D-4F — Ignore/Hide persistence + Card↔Draft Apply parity (additive, gated)
const D4F_LS_IGNORE_RULES = "mf_lite_ignore_rules_v1";
const D4F_LS_HIDDEN_ISSUES = "mf_lite_hidden_issues_v1";

function d4fLoadSet(key){
  try{
    const raw = localStorage.getItem(key);
    if(!raw) return new Set();
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return new Set();
    return new Set(arr.filter(Boolean).map(String));
  }catch(e){ return new Set(); }
}

function d4fSaveSet(key, setLike){
  try{
    const arr = Array.from(setLike || []).map(String);
    localStorage.setItem(key, JSON.stringify(arr));
  }catch(e){}
}

function ignoreRulesLoad(){
  try{
    if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
    state.ignore.rules = d4fLoadSet(D4F_LS_IGNORE_RULES);
  }catch(e){}
}

function ignoreRulesSave(){
  try{ if(state.ignore && state.ignore.rules) d4fSaveSet(D4F_LS_IGNORE_RULES, state.ignore.rules); }catch(e){}
}

function hiddenIssuesLoad(){
  try{
    if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
    state.ignore.hidden = d4fLoadSet(D4F_LS_HIDDEN_ISSUES);
  }catch(e){}
}

function hiddenIssuesSave(){
  try{ if(state.ignore && state.ignore.hidden) d4fSaveSet(D4F_LS_HIDDEN_ISSUES, state.ignore.hidden); }catch(e){}


// D-4G — Dev Lab Visibility Manager (additive; no CX panel changes)
function d4gParseSetFromLS(key){
  const out = { set: new Set(), ok: true, raw: null };
  try{
    const raw = localStorage.getItem(key);
    out.raw = raw;
    if(!raw) return out;
    const parsed = JSON.parse(raw);
    if(Array.isArray(parsed)){
      out.set = new Set(parsed.filter(Boolean).map(String));
      return out;
    }
    // support legacy object-map
    if(parsed && typeof parsed === "object"){
      const keys = Object.keys(parsed).filter(k => parsed[k]);
      out.set = new Set(keys.map(String));
      return out;
    }
    // unknown shape
    out.ok = false;
    return out;
  }catch(e){
    out.ok = false;
    return out;
  }
}

function d4gSafeCopy(text){
  const t = String(text || "");
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(t);
      return true;
    }
  }catch(e){}
  try{
    const ta = document.createElement("textarea");
    ta.value = t;
    ta.style.position="fixed";
    ta.style.left="-9999px";
    ta.style.top="-9999px";
    document.body.appendChild(ta);
    ta.focus(); ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return true;
  }catch(e){
    return false;
  }
}

function d4gRenderVisibilityManager(){
  const host = document.getElementById("mfDevVisibility");
  if(!host) return;

  // Pull from state (authoritative), but also check raw LS health for warnings.
  const lsIgnore = d4gParseSetFromLS(D4F_LS_IGNORE_RULES);
  const lsHidden = d4gParseSetFromLS(D4F_LS_HIDDEN_ISSUES);

  const ignoreSet = (state.ignore && state.ignore.rules) ? new Set(state.ignore.rules) : new Set(lsIgnore.set);
  const hiddenSet = (state.ignore && state.ignore.hidden) ? new Set(state.ignore.hidden) : new Set(lsHidden.set);

  const ignoreArr = Array.from(ignoreSet).sort((a,b)=>String(a).localeCompare(String(b)));
  const hiddenArr = Array.from(hiddenSet).sort((a,b)=>String(a).localeCompare(String(b)));

  const emptyRow = (label)=> `<div class="mf-devRow"><div class="mf-devKey" style="opacity:.75;">${label}</div></div>`;

  const card = (title, meta, listHtml, actionsHtml, warnHtml="") => `
    <div class="mf-devCard">
      <div class="mf-devMeta">
        <div>
          <h3>${title}</h3>
          <div class="mini">${meta}</div>
        </div>
      </div>
      <div class="mf-devList">${listHtml}</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
        ${actionsHtml}
      </div>
      ${warnHtml}
    </div>
  `;

  const hiddenList = hiddenArr.length
    ? hiddenArr.map(id => `
        <div class="mf-devRow">
          <div class="mf-devKey" title="${esc(id)}">${esc(id)}</div>
          <div class="mf-devBtns">
            <button class="mf-devBtn" type="button" data-d4g="unhide" data-id="${esc(id)}">Unhide</button>
            <button class="mf-devBtn" type="button" data-d4g="copy" data-copy="${esc(id)}">Copy</button>
          </div>
        </div>
      `).join("")
    : emptyRow("No hidden cards.");

  const ignoreList = ignoreArr.length
    ? ignoreArr.map(k => `
        <div class="mf-devRow">
          <div class="mf-devKey" title="${esc(k)}">${esc(k)}</div>
          <div class="mf-devBtns">
            <button class="mf-devBtn" type="button" data-d4g="unignore" data-key="${esc(k)}">Unignore</button>
            <button class="mf-devBtn" type="button" data-d4g="copy" data-copy="${esc(k)}">Copy</button>
          </div>
        </div>
      `).join("")
    : emptyRow("No ignored rules.");

  const hiddenActions = `
    <button class="mf-devBtn" type="button" data-d4g="copylist" data-list="hidden">Copy list</button>
    <button class="mf-devBtn danger" type="button" data-d4g="clearlist" data-list="hidden">Unhide all</button>
  `;

  const ignoreActions = `
    <button class="mf-devBtn" type="button" data-d4g="copylist" data-list="ignore">Copy list</button>
    <button class="mf-devBtn danger" type="button" data-d4g="clearlist" data-list="ignore">Unignore all</button>
  `;

  const warnHidden = (!lsHidden.ok && lsHidden.raw)
    ? `<div class="mf-devWarn"><b>Heads up:</b> stored Hidden list looks corrupted/unknown shape. You can reset just this list without wiping all storage. <button class="mf-devBtn danger" type="button" data-d4g="resetraw" data-raw="hidden" style="margin-left:8px;">Reset hidden list</button></div>`
    : "";

  const warnIgnore = (!lsIgnore.ok && lsIgnore.raw)
    ? `<div class="mf-devWarn"><b>Heads up:</b> stored Ignore list looks corrupted/unknown shape. You can reset just this list without wiping all storage. <button class="mf-devBtn danger" type="button" data-d4g="resetraw" data-raw="ignore" style="margin-left:8px;">Reset ignore list</button></div>`
    : "";

  host.innerHTML =
    card("Hidden cards", `${hiddenArr.length} item(s)`, hiddenList, hiddenActions, warnHidden)
    + card("Ignored rules", `${ignoreArr.length} item(s)`, ignoreList, ignoreActions, warnIgnore);

  // Bind once (event delegation)
  if(host.dataset.bound === "true") return;
  host.dataset.bound = "true";

  host.addEventListener("click", (e)=>{
    const btn = e.target && e.target.closest ? e.target.closest("button[data-d4g]") : null;
    if(!btn) return;
    const act = btn.getAttribute("data-d4g");

    const rerender = () => { try{ d4gRenderVisibilityManager(); }catch(_){} };
    const rescan = () => { try{ scheduleRender && scheduleRender(); }catch(_){} };

    if(act === "copy"){
      const v = btn.getAttribute("data-copy") || "";
      d4gSafeCopy(v);
      try{ toast && toast("Copied."); }catch(_){}
      return;
    }

    if(act === "copylist"){
      const which = btn.getAttribute("data-list");
      const arr = (which === "hidden") ? Array.from(hiddenSet) : Array.from(ignoreSet);
      d4gSafeCopy(arr.sort().join("\n"));
      try{ toast && toast("List copied."); }catch(_){}
      return;
    }

    if(act === "clearlist"){
      const which = btn.getAttribute("data-list");
      if(which === "hidden"){
        if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
        state.ignore.hidden = new Set();
        d4fSaveSet(D4F_LS_HIDDEN_ISSUES, state.ignore.hidden);
        rerender(); rescan();
        try{ toast && toast("Hidden list cleared."); }catch(_){}
        return;
      }
      if(which === "ignore"){
        if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
        state.ignore.rules = new Set();
        d4fSaveSet(D4F_LS_IGNORE_RULES, state.ignore.rules);
        rerender(); rescan();
        try{ toast && toast("Ignore list cleared."); }catch(_){}
        return;
      }
    }

    if(act === "resetraw"){
      const which = btn.getAttribute("data-raw");
      if(which === "hidden"){
        localStorage.removeItem(D4F_LS_HIDDEN_ISSUES);
        hiddenIssuesLoad();
        rerender(); rescan();
        try{ toast && toast("Hidden list reset."); }catch(_){}
        return;
      }
      if(which === "ignore"){
        localStorage.removeItem(D4F_LS_IGNORE_RULES);
        ignoreRulesLoad();
        rerender(); rescan();
        try{ toast && toast("Ignore list reset."); }catch(_){}
        return;
      }
    }

    if(act === "unhide"){
      const id = btn.getAttribute("data-id") || "";
      if(!id) return;
      if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
      if(!state.ignore.hidden) state.ignore.hidden = new Set();
      state.ignore.hidden.delete(id);
      hiddenIssuesSave();
      rerender(); rescan();
      return;
    }

    if(act === "unignore"){
      const k = btn.getAttribute("data-key") || "";
      if(!k) return;
      if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
      if(!state.ignore.rules) state.ignore.rules = new Set();
      state.ignore.rules.delete(k);
      ignoreRulesSave();
      rerender(); rescan();
      return;
    }
  });
}

// Render when Dev Lab popup opens (hash-based)
(function(){
  const maybeRender = () => {
    if(location.hash === "#modal-dev"){
      try{ d4gRenderVisibilityManager(); }catch(e){}
    }
  };
  window.addEventListener("hashchange", maybeRender);
  // If user refreshes while modal-dev is open
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", maybeRender, { once:true });
  }else{
    maybeRender();
  }
})();

}

function hideIssue(issue){
  if(!issue) return;
  const id = String(issue.id || issue.issueId || issue.term || "").trim();
  if(!id) return;
  try{
    issue.hidden = true;
    if(!state.ignore) state.ignore = { once:new Set(), rules:new Set(), hidden:new Set() };
    if(!state.ignore.hidden) state.ignore.hidden = new Set();
    state.ignore.hidden.add(id);
    hiddenIssuesSave();
  }catch(e){}
}

function d4fPickOccurrenceForIssue(issue){
  try{
    const text = (state.drafts && state.drafts.agent) ? state.drafts.agent : "";
    const occs = (issue && issue.occurrences) ? issue.occurrences : [];
    if(!text || !occs || !occs.length) return null;

    const cur = el.agentDraft ? (el.agentDraft.selectionStart || 0) : 0;

    // Prefer occurrence that contains cursor
    for(const o of occs){
      if(!o) continue;
      if(typeof o.start==="number" && typeof o.end==="number" && cur>=o.start && cur<=o.end) return o;
    }

    // Else pick the next occurrence after cursor; otherwise the first (stable)
    const sorted = occs.slice().filter(Boolean).sort((a,b)=> (a.start-b.start) || (a.end-b.end));
    for(const o of sorted){
      if(typeof o.start==="number" && o.start>=cur) return o;
    }
    return sorted[0] || null;
  }catch(e){ return null; }
}

function d4fBuildSegFromIssueOcc(issue, occ){
  if(!issue || !occ) return null;
  const kind = String(issue.kind || "").trim();
  const start = occ.start, end = occ.end;
  if(typeof start!=="number" || typeof end!=="number" || end<=start) return null;

  let plain = "";
  if(kind === "ukus"){
    const sug = issue.suggestions && issue.suggestions[0] ? issue.suggestions[0] : null;
    plain = (sug && typeof sug.replacement==="string") ? sug.replacement : "";
  } else if(kind === "jargon"){
    plain = String(issue.plainEnglish || issue.plain || "").trim();
  }

  return {
    kind,
    start,
    end,
    issueId: String(issue.id || ""),
    term: String(issue.term || ""),
    plain,
    category: String(issue.category || ""),
    why: String(issue.why || ""),
    explain: String(issue.explain || "")
  };
}

function d4fApplyFromCard(issue){
  try{
    if(!issue || !el.agentDraft) return;
    const occ = d4fPickOccurrenceForIssue(issue);
    if(!occ) return toast("No occurrence found for this item.", true);

    const seg = d4fBuildSegFromIssueOcc(issue, occ);
    if(!seg) return toast("Could not apply — position mismatch.", true);

    // align selection to this occurrence for determinism + visibility
    try{ el.agentDraft.focus(); el.agentDraft.setSelectionRange(seg.start, seg.end); }catch(e){}

    // Set focus seg so tooltip+apply use identical logic
    state.__draftFocusSeg = seg;
    state.__draftFocusIssueId = seg.issueId || "";
    showDraftTip(seg);

    // Reuse D-4E apply logic (single occurrence)
    if(typeof d4eApplyFocused === "function") d4eApplyFocused();
    else toast("Apply function not available.", true);
  }catch(e){ toast("Could not apply from card.", true); }
}

function ignoreIssue(issue) {
      if (!issue || !issue.ignoreKey) return;
      state.ignore.rules.add(issue.ignoreKey);
      try{ if (typeof ignoreRulesSave==="function") ignoreRulesSave(); }catch(e){}
    scheduleRender();
      toast("Ignored.");
    }

  function applyIssue(issue) {
      if (!issue) return;
      const sug = issue.suggestions && issue.suggestions[0] ? issue.suggestions[0] : null;
      const rep = sug && typeof sug.replacement === "string" ? sug.replacement : "";
      if (!rep) return toast("No replacement available for this item.");
  
      const t = state.drafts.agent || "";
      const occs = (issue.occurrences || []).slice().sort((a, b) => b.start - a.start);
      let out = t;
  
      for (const occ of occs) {
        out = out.slice(0, occ.start) + rep + out.slice(occ.end);
      }
  
      state.drafts.agent = out;
      if (el.agentDraft) el.agentDraft.value = out;
      try { histPush(out); } catch (e) {}
  
      scheduleRender();
      toast("Applied.");
    }

  function applyAllUkus() {
      const w = state.analysis && state.analysis.writer ? state.analysis.writer : null;
      if (!w) return;
      const ms = (w.matchesEffective || []).filter(m => m.kind === "ukus");
      if (!ms.length) return toast("No UK/US spellings to apply.");
  
      ms.sort((a, b) => b.start - a.start);
  
      let out = state.drafts.agent || "";
      for (const m of ms) {
        const rep = m.suggestions && m.suggestions[0] ? (m.suggestions[0].replacement || "") : "";
        if (!rep) continue;
        out = out.slice(0, m.start) + rep + out.slice(m.end);
      }
  
      state.drafts.agent = out;
      if (el.agentDraft) el.agentDraft.value = out;
      try { histPush(out); } catch (e) {}
  
      scheduleRender();
      toast("Applied all UK spellings.");
    }

  
  function renderWriterIssues() {
      // Writer issues are sourced from state.analysis.writer.issues (kind: "ukus" | "jargon")
      const targets = {
        writer: el.writerList,
        ukus: el.ukusList,
        jargon: el.jargonList
      };

      // Safe: if DOM mounts are missing, exit quietly
      if (!targets.writer) return;

      const curMode = (state.cxMode || (el.insightsPanel && el.insightsPanel.dataset.cxmode) || "writer");

      const w = state.analysis && state.analysis.writer ? state.analysis.writer : null;
      const txt = w ? (w.text || "") : "";
      const issues = (w && w.issues) ? w.issues : [];

      // Actionable list renderer (D-4C: issue contract + category grouping + top offenders)
      const renderInto = (box, kinds, allowApplyAll)=>{
        if (!box) return;
        box.innerHTML = "";

        if (!state.checkerOn) {
          box.innerHTML = `<div class="insight-muted">Checker is OFF.</div>`;
          return;
        }
        if (!txt.trim()) {
          box.innerHTML = `<div class="insight-muted">Start typing in the Agent draft to see checks.</div>`;
          return;
        }

        const kindsArr = Array.isArray(kinds) ? kinds : [];
        const kindSet = new Set(kindsArr);

        let renderedAny = false;

        const sortIssuesStable = (a, b)=>{
          // deterministic: count desc, severity desc, term asc, id asc
          const sevRank = { blocker: 4, risk: 3, warn: 2, info: 1 };
          return (
            ((b.count || 0) - (a.count || 0)) ||
            ((sevRank[b.severity] || 0) - (sevRank[a.severity] || 0)) ||
            (_safeStr(a.term,"").localeCompare(_safeStr(b.term,""))) ||
            (_safeStr(a.id,"").localeCompare(_safeStr(b.id,"")))
          );
        };

        for (const kind of kindsArr) {
          const raw = (issues || []).filter(x => x && x.kind === kind && !x.hidden);
          if (!raw.length) continue;
          renderedAny = true;

          const arr = raw.map(_normalizeIssue).sort(sortIssuesStable);

          // Main header for this kind (only when rendering multiple kinds in one view)
          if ((kindsArr && kindsArr.length > 1)) {
            const header = document.createElement("div");
            header.className = "insight-group";
            const label = document.createElement("div");
            label.className = "t";
            label.textContent = (kind === "ukus") ? "UK/US spellings" : (kind === "jargon" ? "Jargon" : kind);
            header.appendChild(label);
            box.appendChild(header);
          }
          // Top offenders chips (most frequent) — minimisable
          const top = arr.slice(0, 5);
          if (top.length) {
            const details = document.createElement("details");
            details.className = "insight-disclosure";
            details.open = true;

            const summary = document.createElement("summary");
            summary.textContent = "Quick jumps";
            const right = document.createElement("span");
            right.className = "sum-right";
            right.textContent = top.length ? (top.length + " items") : "";
            summary.appendChild(right);
            details.appendChild(summary);

            const chipRow = document.createElement("div");
            chipRow.className = "insight-chiprow";

            top.forEach(it=>{
              const chip = document.createElement("div");
              chip.className = "insight-chip";
              const name = document.createElement("span");
              name.textContent = it.term || it.title || "Item";
              const n = document.createElement("span");
              n.className = "insight-cat";
              n.textContent = String(it.count || 0);
              chip.appendChild(name);
              chip.appendChild(n);

              const cardId = "issue-" + _safeDomId(it.id || it.term || it.title || "");
              chip.addEventListener("click", ()=>{
                const card = document.getElementById(cardId);
                if (card && card.scrollIntoView) {
                  try { card.scrollIntoView({ behavior: "smooth", block: "nearest" }); } catch(e){ card.scrollIntoView(); }
                }
              });

              chipRow.appendChild(chip);
            });

            details.appendChild(chipRow);
            box.appendChild(details);
          }

          // Category grouping

          const byCat = _groupBy(arr, x => _safeStr(x.category, "General") || "General");
          const cats = Array.from(byCat.entries()).map(([cat, list])=>({
            cat,
            list: (list || []).slice().sort(sortIssuesStable),
            total: (list || []).reduce((s, x)=> s + (x.count || 0), 0)
          }));

          cats.sort((a, b)=> (b.total - a.total) || _safeStr(a.cat,"").localeCompare(_safeStr(b.cat,"")));

          for (const g of cats) {
            const gh = document.createElement("div");
            gh.className = "insight-group";
            const gt = document.createElement("div");
            gt.className = "t";
            gt.textContent = g.cat || "General";
            const badge = document.createElement("span");
            badge.className = "insight-cat";
            badge.textContent = String(g.total || 0);
            gh.appendChild(gt);
            gh.appendChild(badge);
            box.appendChild(gh);

            for (const it of (g.list || [])) {
              const rawIssue = it.__raw || it;

              const row = document.createElement("div");
              row.className = "insight-item issue";
              row.id = "issue-" + _safeDomId(it.id || it.term || it.title || "");

              const dot = document.createElement("div");
              dot.className = "insight-dot";

              const col = document.createElement("div");
              col.style.flex = "1";

              const k = document.createElement("div");
              k.className = "k";
              k.textContent = (kind === "ukus") ? "UK spelling" : (kind === "jargon" ? "Jargon" : "Issue");

              const v = document.createElement("div");
              v.className = "v";
              if (kind === "jargon") {
                v.textContent = it.plain ? `${it.term} → ${it.plain}` : it.term;
              } else if (kind === "ukus") {
                const rep = (it.suggestions && it.suggestions[0] && typeof it.suggestions[0].replacement === "string") ? it.suggestions[0].replacement : "";
                v.textContent = rep ? `${it.term} → ${rep}` : it.term;
              } else {
                v.textContent = it.title || it.term || "";
              }

              const meta = document.createElement("div");
              meta.className = "meta";
              meta.appendChild(document.createTextNode(`Found ${it.count || 0} time(s) • `));
              const pill = document.createElement("span");
              pill.className = "insight-cat";
              pill.textContent = it.category || "General";
              meta.appendChild(pill);

              if (!((state.cxMode==="ukus" && kind==="ukus") || (state.cxMode==="jargon" && kind==="jargon"))) {
                col.appendChild(k);
              }
              col.appendChild(v);
              col.appendChild(meta);

              if (kind === "jargon" && !it.plain) {
                const miss = document.createElement("div");
                miss.className = "meta meta2";
                const b = document.createElement("b");
                b.textContent = "Note: ";
                miss.appendChild(b);
                miss.appendChild(document.createTextNode("No plain-language mapping available yet."));
                col.appendChild(miss);
              }

              if (it.why) {
                const why = document.createElement("div");
                why.className = "meta meta2";
                const b = document.createElement("b");
                b.textContent = "Why: ";
                why.appendChild(b);
                why.appendChild(document.createTextNode(it.why));
                col.appendChild(why);
              }

              if (it.explain) {
                const ex = document.createElement("div");
                ex.className = "meta meta2";
                const b = document.createElement("b");
                b.textContent = "Meaning: ";
                ex.appendChild(b);
                ex.appendChild(document.createTextNode(it.explain));
                col.appendChild(ex);
              }

              // Controls row (Jump / Hide / Ignore, optional Apply for UK/US only)
              const actions = document.createElement("div");
              actions.className = "issue-actions";

              const bJump = document.createElement("button");
              bJump.className = "btn-mini";
              bJump.textContent = "Jump";
              bJump.addEventListener("click", ()=>{ try{ jumpToIssue(rawIssue); }catch(e){} });
              actions.appendChild(bJump);

              const bHide = document.createElement("button");
              bHide.className = "btn-mini";
              bHide.textContent = "Hide";
              bHide.addEventListener("click", ()=>{
                hideIssue(rawIssue);
                scheduleRender();
              });
              actions.appendChild(bHide);

              if (kind === "ukus") {
                const rep = (rawIssue.suggestions && rawIssue.suggestions[0] && typeof rawIssue.suggestions[0].replacement === "string") ? rawIssue.suggestions[0].replacement : "";
                if (allowApplyAll && rep) {
                  const bApply = document.createElement("button");
                  bApply.className = "btn-mini";
                  bApply.textContent = "Apply";
                  bApply.addEventListener("click", ()=>{ try{ d4fApplyFromCard(rawIssue); }catch(e){} });
                  actions.appendChild(bApply);
                }
              }

              const bIgnore = document.createElement("button");
              bIgnore.className = "btn-mini danger";
              bIgnore.textContent = "Ignore";
              bIgnore.addEventListener("click", ()=>{ try{ ignoreIssue(rawIssue); }catch(e){} });
              actions.appendChild(bIgnore);

              col.appendChild(actions);

              row.appendChild(dot);
              row.appendChild(col);

              box.appendChild(row);
            }
          }
        }

        if (!renderedAny) {
          const kindLabel = (kindsArr && kindsArr.length===1) ? kindsArr[0] : "items";
          const msg = (kindLabel === "ukus") ? "No UK/US spelling issues detected." : (kindLabel === "jargon" ? "No jargon matches detected." : "No items detected.");
          box.innerHTML = `<div class="insight-muted">${msg}</div>`;
        }
      };

      // --- WRITER TAB (Pass 2: Agent audit only; Customer Signals moved to Experience) ---
      if (curMode === "writer" && targets.writer) {

        // Agent audit chips (Option B, Pass 1/2): chips always compute; details intentionally gated
        const audit = buildAgentAuditD4B(String(state.drafts.agent||""), String(state.drafts.customer||""));
        const wrap = document.createElement("div");
        wrap.className = "cx-writer";

        const auditWrap = document.createElement("div");
        auditWrap.className = "cx-audit";

        const ah = document.createElement("div");
        ah.className = "insight-subhead";
        ah.textContent = "Agent audit";
        auditWrap.appendChild(ah);

        const chipRow = document.createElement("div");
        chipRow.className = "audit-chips";
        const order = ["acknowledgement","nextSteps","moneyClarity","clarifier","support"];
        order.forEach(k=>{
          const it = (audit && audit[k]) ? audit[k] : null;
          if (!it) return;
          const c = document.createElement("span");
          c.className = "chip";
          const label = it.title || it.label || k;
          c.textContent = label + ": " + (it.state==="present" ? "✓ Present" : (it.state==="not_needed" ? "— Not needed" : "• Missing"));
          chipRow.appendChild(c);
        });
        auditWrap.appendChild(chipRow);

        wrap.appendChild(auditWrap);
        // --- MFCX Writer Pack UI (Top Picks + Phrases + Reply Blocks) ---
        const pack = (state.mfcx || buildMFCXLite(
          String(state.drafts.customer||""),
          String(state.drafts.agent||""),
          (state.analysis && state.analysis.writer && state.analysis.writer.counts) ? state.analysis.writer.counts : null,
          (state.analysis && state.analysis.writer && state.analysis.writer.flags) ? state.analysis.writer.flags : null
        ));

        wrap.appendChild(MF_renderTopPicksSection(pack));
        wrap.appendChild(MF_renderPhrasesSection());
        wrap.appendChild(MF_renderReplyBlocksSection());


        targets.writer.innerHTML = "";
        targets.writer.appendChild(wrap);
      }

      // --- EXPERIENCE TAB (Pass 2: Customer Signals preview; deeper weighting deferred) ---
      if (curMode === "experience" && targets.experience) {
        const cust = String(state.drafts.customer || "");
        const lens = buildCustomerLensD4A(cust);

        const wrap = document.createElement("div");
        wrap.className = "cx-exp";

        const h = document.createElement("div");
        h.className = "insight-subhead";
        h.textContent = "Customer signals";
        wrap.appendChild(h);

        const box0 = document.createElement("div");
        box0.className = "insight-box";
        if (!cust.trim()){
          box0.innerHTML = '<div class="insight-muted">Add a customer message to see customer-signal insights.</div>';
          wrap.appendChild(box0);
        } else {
          const list0 = document.createElement("div");
          list0.className = "insight-list";
          const row0 = document.createElement("div");
          row0.className = "insight-item";
          row0.innerHTML = '<div class="insight-dot"></div><div class="insight-col"><div class="k">Primary focus</div><div class="v">' + (lens.primarySummary || '') + '</div></div>';
          list0.appendChild(row0);
          box0.appendChild(list0);
          wrap.appendChild(box0);

          const box1 = document.createElement("div");
          box1.className = "insight-box";
          setList(box1, [{ key:"Chars", val: String(lens.chars || 0) }]);
          wrap.appendChild(box1);

          const box2 = document.createElement("div");
          box2.className = "insight-box";
          if (!lens.questionsPicked || !lens.questionsPicked.length){
            box2.innerHTML = '<div class="insight-muted">Key questions: none detected.</div>';
          } else {
            setList(box2, lens.questionsPicked.map(q => ({ key:"Question", val:q })));
          }
          wrap.appendChild(box2);

          const box3 = document.createElement("div");
          box3.className = "insight-box";
          if (!lens.visibleIntents || !lens.visibleIntents.length){
            box3.innerHTML = '<div class="insight-muted">Context: no clear focus areas detected yet.</div>';
          } else {
            setList(box3, lens.visibleIntents.map(x => ({ key:"Context", val:x })));
          }
          wrap.appendChild(box3);

          // Lightweight experience cues (no scoring) — keeps Experience tab useful without overreach
          const sig = listExperienceSignals(cust);
          const hasAny = (sig.money && sig.money.length) || (sig.stress && sig.stress.length) || (sig.vuln && sig.vuln.length);
          const box4 = document.createElement("div");
          box4.className = "insight-box";
          if (!hasAny){
            box4.innerHTML = '<div class="insight-muted">No strong money / stress / vulnerability cues detected.</div>';
          } else {
            const items = [];
            (sig.money||[]).forEach(v=>items.push({ key:"Money", val:v }));
            (sig.stress||[]).forEach(v=>items.push({ key:"Stress", val:v }));
            (sig.vuln||[]).forEach(v=>items.push({ key:"Vulnerability", val:v }));
            setList(box4, items);
          }
          wrap.appendChild(box4);

          const note = document.createElement("div");
          note.className = "insight-muted";
          note.style.margin = "6px 6px 0";
          note.textContent = lens.note || "Showing highest-impact concerns only.";
          wrap.appendChild(note);
        }

        targets.experience.innerHTML = "";
        targets.experience.appendChild(wrap);
      } else if (targets.experience) {
        targets.experience.innerHTML = "";
      }

      // --- UK/US TAB (actionable only here) --- (actionable only here) ---
      if (curMode === "ukus" && targets.ukus) {
        renderInto(targets.ukus, ["ukus"], true);
      } else if (targets.ukus) {
        targets.ukus.innerHTML = "";
      }

      // --- JARGON TAB (actionable only here) ---
      if (curMode === "jargon" && targets.jargon) {
        renderInto(targets.jargon, ["jargon"], false);
      } else if (targets.jargon) {
        targets.jargon.innerHTML = "";
      }

      // Ensure writer list isn't overwritten by legacy calls
      return;
    }


function listClarityFlags(text){
    const t = (text || "").trim();
    if (!t) return [];
    const flags = [];
    // long sentence heuristic
    const sentences = t.split(/(?<=[.!?])\s+/);
    const long = sentences.filter(s=>s.length>180);
    if (long.length) flags.push({ key:"Long sentence", val:`${long.length} sentence(s) over 180 characters. Consider splitting for mobile.` });
    // blocks
    const paras = t.split(/\n{2,}/);
    const dense = paras.filter(p=>p.replace(/\s+/g,' ').length>420);
    if (dense.length) flags.push({ key:"Dense paragraph", val:`${dense.length} paragraph(s) very dense. Short paragraphs read better on phone.` });
    // punctuation intensity
    if ((t.match(/!{2,}/g)||[]).length) flags.push({ key:"Too many !", val:"Multiple exclamation marks can read as intense. One is usually enough." });
    // all caps words
    const caps = (t.match(/\b[A-Z]{4,}\b/g)||[]);
    if (caps.length) flags.push({ key:"ALL CAPS", val:`Found ${caps.length} ALL-CAPS word(s). Customers often read this as shouting.` });
    return flags;
  }
  function listToneFlags(text){
    const t = (text || "").toLowerCase();
    const flags = [];
    const bad = [
      {w:"unfortunately", s:"Try: “What I can do is…”"},
      {w:"can't", s:"Try: “What I can do next is…”"},
      {w:"won't", s:"Try: “What will happen next is…”"},
      {w:"as per", s:"Try: “According to…” / “Based on…”"},
      {w:"kindly", s:"Often reads cold in UK CX; use “please” instead."}
    ];
    for (const b of bad){
      if (t.includes(b.w)) flags.push({ key:`Tone word: “${b.w}”`, val:b.s });
    }
    return flags;
  }
  function listExperienceSignals(text){
    const t = (text || "").toLowerCase();
    const money = [];
    const stress = [];
    const vuln = [];
    const moneyRe = /(£\s?\d+[\d,]*(?:\.\d{1,2})?)|(excess)|(costs?)|(pay)|(charge)|(fee)|(refund)|(premium)/g;
    const stressRe = /(worried)|(anxious)|(upset)|(frustrat)|(stress)|(angry)|(concern)|(panic)/g;
    const vulnRe = /(struggling)|(can\'t cope)|(can\'?t manage)|(hard time)|(i\s+need\s+help)|(desperate)|(overwhelmed)/g;
    if (moneyRe.test(t)) money.push("Money / cost sensitivity detected (e.g., excess, costs, £ amounts).");
    if (stressRe.test(t)) stress.push("Stress / pressure language detected (worried, upset, frustrated).");
    if (vulnRe.test(t)) vuln.push("Possible vulnerability cues detected (struggling / overwhelmed).");
    return { money, stress, vuln };
  }

  // D-4A: Customer signals ranking + trimming (moved to Experience)
  function extractIntentsRankedCustomer(t){
    const s = String(t || "");
    if (!s.trim()) return { tier1:[], tier2:[], tier3:[], all:[] };

    const rules = [
      // Tier 1 (Primary impact)
      { tier: 1, label: "Costs / excess", re: /(excess|premium|cost|charge|fee|price|afford|refund|£)/i },
      { tier: 1, label: "Settlement / payout", re: /(settlement|payout|pay out|payment|total loss|written off|write[- ]?off|valuation|market value)/i },

      // Tier 2 (Resolution pressure)
      { tier: 2, label: "Repair timing", re: /(when|how long|eta|timeline|update|delay|waiting)/i },
      { tier: 2, label: "Repairs / garage", re: /(repair|garage|workshop|bodyshop|estimate|authoris|approve|book(ed)?\b)/i },
      { tier: 2, label: "Hire car", re: /(courtesy car|hire car|replacement car|mobility)/i },

      // Tier 3 (Informational / clarification)
      { tier: 3, label: "Responsibility", re: /(liability|fault|responsible|third party|tp\b)/i },
      { tier: 3, label: "Documents", re: /(document|proof|photo|invoice|receipt|v5c|bank|evidence|report)/i },
    ];

    const tier1 = [];
    const tier2 = [];
    const tier3 = [];

    for (const r of rules){
      if (r.re.test(s)){
        if (r.tier === 1 && !tier1.includes(r.label)) tier1.push(r.label);
        if (r.tier === 2 && !tier2.includes(r.label)) tier2.push(r.label);
        if (r.tier === 3 && !tier3.includes(r.label)) tier3.push(r.label);
      }
    }

    const all = [...tier1, ...tier2, ...tier3];
    return { tier1, tier2, tier3, all };
  }

  function extractCustomerQuestionsLite(t){
    const s = String(t || "").trim();
    if (!s) return [];
    const raw = s.split(/\?/g).map(x=>x.trim()).filter(Boolean);
    const out = [];
    for (const seg of raw){
      if (out.length >= 8) break;
      if (/(can|could|would|will|when|what|why|how|do|did|is|are)\b/i.test(seg)) out.push(seg + "?");
    }
    return out;
  }

  function questionTierLite(q){
    const s = String(q || "");
    if (/(£|excess|premium|cost|charge|fee|refund|payment|settlement|payout|write[- ]?off|valuation|market value)/i.test(s)) return 1;
    if (/(when|how long|eta|timeline|update|delay|repair|garage|hire car|courtesy|replacement car|mobility)/i.test(s)) return 2;
    if (/(liability|fault|third party|responsible|documents?|proof|photo|invoice|receipt|v5c|bank|evidence|report)/i.test(s)) return 3;
    return 3;
  }

  function pickTopQuestionsLite(allQs){
    const qs = Array.isArray(allQs) ? allQs.slice() : [];
    if (!qs.length) return [];

    const byTier = { 1: [], 2: [], 3: [] };
    for (const q of qs){
      const t = questionTierLite(q);
      byTier[t].push(q);
    }

    const tiersPresent = [1,2,3].filter(t => byTier[t].length > 0);
    const picked = [];
    const counts = { 1:0, 2:0, 3:0 };
    const capPerTier = (t) => (tiersPresent.length > 1 ? 2 : 3);

    const take = (t) => {
      for (const q of byTier[t]){
        if (picked.length >= 3) break;
        if (counts[t] >= capPerTier(t)) continue;
        picked.push(q);
        counts[t] += 1;
      }
    };

    take(1); take(2); take(3);
    return picked.slice(0,3);
  }

  function buildCustomerLensD4A(customerText){
    const cText = String(customerText || "");
    const chars = cText.length;
    const allQs = extractCustomerQuestionsLite(cText);
    const intents = extractIntentsRankedCustomer(cText);
    const visibleIntents = [...intents.tier1, ...intents.tier2, ...intents.tier3].slice(0, 4);
    const questionsPicked = pickTopQuestionsLite(allQs);

    let primarySummary = "";
    if (intents.tier1.length){
      primarySummary = "Primary concern appears to be: " + intents.tier1.slice(0,2).join(" · ") + ".";
    } else if (cText.trim() && visibleIntents.length){
      primarySummary = "No high-impact cost/settlement signals detected — focus is likely operational.";
    } else if (cText.trim()){
      primarySummary = "No clear priority yet — insights will sharpen as more detail is added.";
    }

    return {
      chars,
      primarySummary,
      visibleIntents,
      questionsPicked,
      note: "Showing highest-impact concerns only."
    };
  }
  // D-4B: Agent Audit gates (Option B) — deterministic, UI-only, Phase-F safe
  // Output is used for chips (always compute). Missing detail rows are rendered later (Pass 3 UI).
  function buildAgentAuditD4B(agentText, customerText){
    const a = String(agentText || "");
    const c = String(customerText || "");
    const t = a.toLowerCase();
    const ct = c.toLowerCase();

    const out = {
      acknowledgement: { state: "present", title: "Acknowledgement", detail: "✓ Present" },
      nextSteps:       { state: "present", title: "Next steps",       detail: "✓ Present" },
      moneyClarity:    { state: "not_needed", title: "Money clarity", detail: "— Not needed", missingParts: [] },
      clarifier:       { state: "present", title: "Clarifier",        detail: "✓ Present" },
      support:         { state: "present", title: "Support",          detail: "✓ Present" }
    };

    if (!a.trim()){
      // With no draft, keep chips computed but calm
      out.acknowledgement = { state:"missing", title:"Acknowledgement", detail:"• Missing", msgTitle:"No acknowledgement yet", msgBody:"The customer’s situation isn’t directly acknowledged in this reply." };
      out.nextSteps       = { state:"missing", title:"Next steps",       detail:"• Missing", msgTitle:"Next steps not stated", msgBody:"The message doesn’t explain what happens after this." };
      out.clarifier       = { state:"missing", title:"Clarifier",        detail:"• Missing", msgTitle:"No clarifying question", msgBody:"If anything is still needed from the customer, it isn’t asked here." };
      out.support         = { state:"missing", title:"Support",          detail:"• Missing", msgTitle:"No support option offered", msgBody:"Consider offering a simple option or reassurance route if helpful." };
      return out;
    }

    // Acknowledgement
    const ACK = ["sorry","i understand","understand this","appreciate","thanks for","i know this","i'm sorry","we're sorry"];
    const hasAck = ACK.some(p => t.includes(p));
    if (!hasAck){
      out.acknowledgement = {
        state:"missing", title:"Acknowledgement", detail:"• Missing",
        msgTitle:"No acknowledgement yet",
        msgBody:"The customer’s situation isn’t directly acknowledged in this reply."
      };
    }

    // Next steps / ownership (merged into one chip per Lite)
    const NEXT = ["next","after this","we will update","i will update","within","today","tomorrow","once this","you'll get an update","you will get an update","i'll update","i will contact","we will contact"];
    const OWN  = ["i'll","i will","we'll","we will","i am checking","i'm checking","we are arranging","i am arranging","i’ve escalated","i've escalated","i am escalating","i'm escalating"];
    const hasNext = NEXT.some(p => t.includes(p));
    const hasOwn  = OWN.some(p => t.includes(p));
    if (!(hasNext || hasOwn)){
      out.nextSteps = {
        state:"missing", title:"Next steps", detail:"• Missing",
        msgTitle:"Next steps not stated",
        msgBody:"The message doesn’t explain what happens after this."
      };
    }

    // Money clarity (2-of-3 rule) — only if money topic exists in either customer or agent text
    const MONEY_KW = ["cost","excess","pay","payment","paid","settlement","price","fee","refund","payout","compensation","deductible"];
    const topicMoney = MONEY_KW.some(k => t.includes(k)) || MONEY_KW.some(k => ct.includes(k));
    if (topicMoney){
      const hasAmount  = /£|\$|€|\b\d{2,6}\b/.test(t);
      const hasPayer   = /(we('| )?ll pay|you('| )?ll pay|covered|not covered|we will cover|we can cover|you will need to pay)/.test(t);
      const hasContext = /(for|towards|relates to|covers|in relation to)/.test(t);
      const parts = [
        (!hasAmount ? "amount" : null),
        (!hasPayer ? "who pays" : null),
        (!hasContext ? "what it relates to" : null)
      ].filter(Boolean);

      out.moneyClarity = { state:"present", title:"Money clarity", detail:"✓ Present", missingParts: parts };

      // 2-of-3 rule: missing if fewer than 2 present
      const presentCount = (hasAmount?1:0) + (hasPayer?1:0) + (hasContext?1:0);
      if (presentCount < 2){
        out.moneyClarity = {
          state:"missing", title:"Money clarity", detail:"• Missing", missingParts: parts,
          msgTitle:"Cost mentioned without full detail",
          msgBody:"A cost is referenced, but not all the usual details are present."
        };
      }
    }

    // Clarifier question
    const hasQM = t.includes("?");
    const isGeneric = t.includes("let me know if you have questions");
    const hasLead = /(could you|can you|please confirm|please let us know|just to check)/.test(t);
    const hasClarifier = ((hasQM || hasLead) && !isGeneric);
    if (!hasClarifier){
      out.clarifier = {
        state:"missing", title:"Clarifier", detail:"• Missing",
        msgTitle:"No clarifying question",
        msgBody:"If anything is still needed from the customer, it isn’t asked here."
      };
    }

    // Optional support option (kept Lite-quiet)
    const SUPPORT = ["if you prefer","option","we can","i can","happy to","please let me know which","either way","no problem"];
    const hasSupport = SUPPORT.some(p => t.includes(p));
    if (!hasSupport){
      out.support = {
        state:"missing", title:"Support", detail:"• Missing",
        msgTitle:"No support option offered",
        msgBody:"Consider offering a simple option or reassurance route if helpful."
      };
    }

    return out;
  }




  function setList(container, items){
    if (!container) return;
    container.innerHTML = "";
    if (!items || !items.length){
      const d = document.createElement("div");
      d.className = "insight-muted";
      d.textContent = "Nothing to flag yet — keep drafting.";
      container.appendChild(d);
      return;
    }
    for (const it of items){
      const row = document.createElement("div");
      row.className = "insight-item issue";
      const dot = document.createElement("div");
      dot.className = "insight-dot";
      const col = document.createElement("div");
      const k = document.createElement("div");
      k.className = "k";
      k.textContent = it.key;
      const v = document.createElement("div");
      v.className = "v";
      const raw = String(it.val || "").replace(/\s+/g," ").trim();
      v.textContent = raw.length > 170 ? (raw.slice(0, 170) + "…") : raw;
      col.appendChild(k); col.appendChild(v);
      row.appendChild(dot); row.appendChild(col);
      container.appendChild(row);
    }
  }


  

// ---------------------------------------------------------------------
// D-4D — Inline flagging in Agent Draft (Lite-safe)
// - Underline/highlight UK/US + Jargon inside the Agent draft textarea
// - Uses a mirrored overlay layer (NO contenteditable), gated + deterministic
// - Click (caret) on a flagged term syncs CX Insights and jumps to the card
// ---------------------------------------------------------------------

const D4D_OVERLAY_MAX_CHARS = 9000;   // perf guard
const D4D_OVERLAY_MAX_MARKS = 420;    // perf guard

let __draftOverlaySegments = [];
let __draftOverlayCacheKey = "";
let __draftOverlayCacheHTML = "";

function _d4dEscapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, (ch) => {
    switch (ch) {
      case "&": return "&amp;";
      case "<": return "&lt;";
      case ">": return "&gt;";
      case "\"": return "&quot;";
      case "'": return "&#39;";
      default: return ch;
    }
  });
}

// Fast content hash to ensure overlay refreshes even when text length/counts stay the same.
// Uses a small sample of the string for speed (head + tail) and FNV-1a 32-bit.
function _d4dFastTextHash(s){
  const str = String(s || "");
  const n = str.length;
  if (!n) return "0";
  const take = 2000;
  const head = str.slice(0, take);
  const tail = (n > take) ? str.slice(Math.max(0, n - take)) : "";
  const sample = head + "\u0000" + tail;
  let h = 0x811c9dc5;
  for (let i = 0; i < sample.length; i++){
    h ^= sample.charCodeAt(i);
    // 32-bit FNV-1a prime: 16777619
    h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
  }
  return h.toString(16);
}

function _d4dOverlap(a, b) {
  return a.start < b.end && a.end > b.start;
}

function _d4dPickNonOverlapping(segments) {
  // deterministic + stable: pick JARGON first, then UK/US, both sorted by start/end
  const j = segments.filter(s => s.kind === "jargon").sort((a,b)=> (a.start-b.start) || (b.end-a.end));
  const u = segments.filter(s => s.kind === "ukus").sort((a,b)=> (a.start-b.start) || (b.end-a.end));

  const chosen = [];
  const addIfClear = (seg) => {
    for (const c of chosen) { if (_d4dOverlap(seg, c)) return; }
    chosen.push(seg);
  };

  for (const seg of j) addIfClear(seg);
  for (const seg of u) addIfClear(seg);

  return chosen.sort((a,b)=> (a.start-b.start) || (b.end-a.end) || (a.kind.localeCompare(b.kind)));
}

function _d4dBuildDraftSegments() {
  const w = state.analysis && state.analysis.writer;
  const issues = (w && Array.isArray(w.issues)) ? w.issues : [];
  const out = [];

  for (const raw of issues) {
    if (!raw || raw.hidden) continue;
    if (raw.kind !== "ukus" && raw.kind !== "jargon") continue;

    const it = _normalizeIssue(raw);
    const occs = Array.isArray(it.occurrences) ? it.occurrences : [];
    const category = it.category || (raw.kind === "ukus" ? "Variant" : "General");

    const replacement =
      (raw.kind === "ukus" && Array.isArray(it.suggestions) && it.suggestions[0] && it.suggestions[0].replacement)
        ? it.suggestions[0].replacement
        : "";

    const plain =
      (raw.kind === "jargon" && it.plain) ? it.plain :
      (raw.kind === "ukus" && replacement) ? replacement :
      "";

    for (const o of occs) {
      if (!o || typeof o.start !== "number" || typeof o.end !== "number") continue;
      if (o.end <= o.start) continue;

      out.push({
        start: o.start,
        end: o.end,
        kind: raw.kind,
        issueId: it.id || "",
        term: it.term || "",
        count: it.count || 1,
        category,
        plain,
        why: it.why || "",
        explain: it.explain || ""
      });
    }
  }

  return out;
}

function renderAgentDraftOverlay() {
  const ta = el.agentDraft;
  const ov = el.agentDraftOverlay;
  if (!ta || !ov) return;
  // Trust pass: keep overlay metrics perfectly aligned with textarea.
  try { syncDraftOverlayMetrics(); } catch(_e){}

  const text = state.drafts.agent || "";
  const w = state.analysis && state.analysis.writer;

  const can =
    !!state.checkerOn &&
    !!w &&
    typeof text === "string" &&
    text.length > 0 &&
    text.length <= D4D_OVERLAY_MAX_CHARS;

  if (!can) {
    ov.style.display = "none";
    __draftOverlaySegments = [];
    __draftOverlayCacheKey = "";
    __draftOverlayCacheHTML = "";
    hideDraftTip();
    return;
  }

  ov.style.display = "block";

  // Build a small deterministic cache key (prevents re-render storms)
  const issues = Array.isArray(w.issues) ? w.issues : [];
  const th = _d4dFastTextHash(text);
  let key = "v2|" + text.length + "|" + th + "|" + (state.__draftFocusIssueId || "");
  // include stable counts per mode so key changes when analysis changes
  for (const raw of issues) {
    if (!raw || raw.hidden) continue;
    if (raw.kind !== "ukus" && raw.kind !== "jargon") continue;
    key += "|" + raw.kind + ":" + (raw.id || "") + ":" + (raw.count || 0);
  }

  if (key === __draftOverlayCacheKey && __draftOverlayCacheHTML) {
    // keep scroll in sync even when HTML is cached
    syncAgentDraftOverlayScroll();
    return;
  }

  const segsAll = _d4dBuildDraftSegments();
  const segsPicked = _d4dPickNonOverlapping(segsAll).slice(0, D4D_OVERLAY_MAX_MARKS);

  __draftOverlaySegments = segsPicked;

  if (!segsPicked.length) {
    __draftOverlayCacheHTML = _d4dEscapeHtml(text);
    __draftOverlayCacheKey = key;
    ov.innerHTML = __draftOverlayCacheHTML;
    syncAgentDraftOverlayScroll();
    return;
  }

  const focusId = state.__draftFocusIssueId || "";
  let html = "";
  let pos = 0;

  for (const s of segsPicked) {
    if (s.start > pos) html += _d4dEscapeHtml(text.slice(pos, s.start));

    const clsBase = (s.kind === "jargon") ? "hl hl-jargon" : "hl hl-ukus";
    const cls = (focusId && s.issueId === focusId) ? (clsBase + " hl-focus") : clsBase;

    html += `<mark class="${cls}" data-kind="${_d4dEscapeHtml(s.kind)}" data-issue="${_d4dEscapeHtml(s.issueId)}">`;
    html += _d4dEscapeHtml(text.slice(s.start, s.end));
    html += `</mark>`;

    pos = s.end;
  }

  if (pos < text.length) html += _d4dEscapeHtml(text.slice(pos));

  __draftOverlayCacheHTML = html;
  __draftOverlayCacheKey = key;
  ov.innerHTML = html;

  syncAgentDraftOverlayScroll();
}

function syncAgentDraftOverlayScroll() {
  const ta = el.agentDraft;
  const ov = el.agentDraftOverlay;
  if (!ta || !ov || ov.style.display === "none") return;
  ov.scrollTop = ta.scrollTop;
  ov.scrollLeft = ta.scrollLeft;
  // Keep tooltip anchored to the highlighted range while scrolling.
  try { positionDraftTipToSeg(state.__draftFocusSeg); } catch(_e){}
}


let __d4dOverlayStyleKey = "";
function syncDraftOverlayMetrics(){
  const ta = el.agentDraft;
  const ov = el.agentDraftOverlay;
  if (!ta || !ov) return;
  const cs = window.getComputedStyle(ta);
  const key = [
    cs.fontSize, cs.lineHeight, cs.fontFamily, cs.fontWeight, cs.letterSpacing,
    cs.paddingTop, cs.paddingRight, cs.paddingBottom, cs.paddingLeft, cs.textIndent, cs.borderRadius
  ].join("|");
  if (key === __d4dOverlayStyleKey) return;
  __d4dOverlayStyleKey = key;

  // Mirror the textarea metrics so highlights stay pinned under any text-size changes.
  ov.style.fontSize = cs.fontSize;
  ov.style.lineHeight = cs.lineHeight;
  ov.style.fontFamily = cs.fontFamily;
  ov.style.fontWeight = cs.fontWeight;
  ov.style.letterSpacing = cs.letterSpacing;
  ov.style.padding = `${cs.paddingTop} ${cs.paddingRight} ${cs.paddingBottom} ${cs.paddingLeft}`;
  ov.style.textIndent = cs.textIndent;
  ov.style.borderRadius = cs.borderRadius;
}

function _d4dCssEscape(s){
  try { return (window.CSS && CSS.escape) ? CSS.escape(String(s||"")) : String(s||"").replace(/[^a-zA-Z0-9_\-]/g, "\\$"); }
  catch(_){ return String(s||""); }
}

function positionDraftTipToSeg(seg){
  const tip = el.agentDraftTip;
  const ov  = el.agentDraftOverlay;
  if (!tip || !ov || !seg || tip.dataset.show !== "true") return;

  const issueId = seg.issueId || state.__draftFocusIssueId || "";
  if (!issueId) return;

  const mark = ov.querySelector(`mark[data-issue="${_d4dCssEscape(issueId)}"]`);
  if (!mark) return;

  const host = ov.closest(".editor-box.agent-box") || ov.parentElement;
  if (!host) return;

  const hostR = host.getBoundingClientRect();
  const markR = mark.getBoundingClientRect();

  // Ensure tip has measurable size
  const tipW = tip.offsetWidth || 240;
  const tipH = tip.offsetHeight || 56;

  const pad = 10;
  let left = (markR.left - hostR.left);
  left = Math.max(pad, Math.min(left, hostR.width - tipW - pad));

  // Prefer above; fall back below if too tight
  let top = (markR.top - hostR.top) - tipH - 10;
  if (top < pad) top = (markR.bottom - hostR.top) + 10;
  top = Math.max(pad, Math.min(top, hostR.height - tipH - pad));

  tip.style.left = `${left}px`;
  tip.style.top = `${top}px`;
  tip.style.bottom = "auto";
}


function _d4dFindSegAtPos(pos) {
  if (typeof pos !== "number") return null;
  for (const s of __draftOverlaySegments) {
    if (pos >= s.start && pos < s.end) return s;
  }
  return null;
}

let __d4dTipTimer = null;

// D-4E — Tooltip Apply + single-step Undo (Lite-safe)
let __d4eUndo = null;
let __d4eLastApplyAt = 0;

function _d4eIsAcronymLike(s){
  const t = (s || "").trim();
  if (t.length < 2 || t.length > 8) return false;
  if (/\s/.test(t)) return false;
  // Must include at least one letter, and be mostly uppercase/digits
  if (!/[A-Z]/.test(t)) return false;
  return /^[A-Z0-9\-\/]+$/.test(t);
}

function _d4eCanApply(seg){
  if (!seg) return false;
  if (seg.kind === "ukus") return !!(seg.plain && String(seg.plain).trim());
  if (seg.kind === "jargon") return !!(seg.plain && String(seg.plain).trim());
  return false;
}

function d4eUndo(){
  if (!__d4eUndo || !el.agentDraft) return;
  const u = __d4eUndo;
  __d4eUndo = null;

  el.agentDraft.value = u.text || "";
  state.drafts.agent = el.agentDraft.value;
  el.agentDraft.scrollTop = u.scrollTop || 0;
  try { el.agentDraft.setSelectionRange(u.selStart || 0, u.selEnd || 0); } catch(e){}

  toast("Undo: restored previous draft.", false);
  scheduleRender();
}

function _d4ePushUndo(){
  if (!el.agentDraft) return;
  __d4eUndo = {
    text: el.agentDraft.value,
    selStart: el.agentDraft.selectionStart,
    selEnd: el.agentDraft.selectionEnd,
    scrollTop: el.agentDraft.scrollTop
  };
}

function d4eApplyFocused(){
  const now = Date.now();
  if (now - __d4eLastApplyAt < 260) return; // tiny debounce
  __d4eLastApplyAt = now;

  if (!el.agentDraft) return;
  const seg = state.__draftFocusSeg || _d4dFindSegAtPos(el.agentDraft.selectionStart);

  if (!seg) { toast("No highlighted issue under the cursor.", true); return; }
  if (!_d4eCanApply(seg)) { toast("No safe fix available for this item yet.", true); return; }

  const text = el.agentDraft.value || "";
  const start = seg.start, end = seg.end;
  if (typeof start !== "number" || typeof end !== "number" || end <= start || start < 0 || end > text.length){
    toast("Could not apply — position mismatch.", true);
    return;
  }

  const orig = text.slice(start, end);
  const plain = String(seg.plain || "").trim();

  _d4ePushUndo();

  let replacement = plain;

  if (seg.kind === "jargon") {
    const term = (seg.term || orig || "").trim();
    const after = text.slice(end);

    const acronym = _d4eIsAcronymLike(term) || _d4eIsAcronymLike(orig);
    if (acronym) {
      replacement = plain;
      // If plain doesn't already include the acronym, keep it for recognition
      if (term && plain.toUpperCase().indexOf(term.toUpperCase()) === -1) {
        replacement = `${plain} (${term})`;
      }
    } else {
      // Default = explain (keep term, add meaning) — avoids replacing domain terms like "policyholder"
      if (/^\s*\(/.test(after)) {
        toast("Already looks like it has an explanation.", true);
        return;
      }
      replacement = `${orig} (${plain})`;
    }
  }

  try {
    // setRangeText keeps textarea as truth-layer + tends to preserve native undo in many browsers
    el.agentDraft.setRangeText(replacement, start, end, "end");
  } catch(e) {
    // Fallback
    el.agentDraft.value = text.slice(0, start) + replacement + text.slice(end);
    try { el.agentDraft.setSelectionRange(start + replacement.length, start + replacement.length); } catch(err){}
  }

  state.drafts.agent = el.agentDraft.value;
  state.lastEdited = "agent";

  // Keep focus + re-sync overlay & CX cards
  try { el.agentDraft.focus(); } catch(e){}

  try {
    state.__draftFocusSeg = Object.assign({}, seg, { start, end: start + replacement.length, term: seg.term || orig });
    state.__draftFocusIssueId = (seg.issueId || state.__draftFocusIssueId || "");
    showDraftTip(state.__draftFocusSeg);
  } catch(e){}

  toast("Applied inline fix.", false);
  scheduleRender();
}


function showDraftTip(seg) {
  const tip = el.agentDraftTip;
  if (!tip || !seg) return;

  const kindLabel = seg.kind === "ukus" ? "UK/US" : "Jargon";
  const cat = seg.category || (seg.kind === "ukus" ? "Variant" : "General");

  const rhs =
    seg.kind === "ukus"
      ? (seg.plain ? `→ ${seg.plain}` : "→ (suggested UK spelling)")
      : (seg.plain ? `→ ${seg.plain}` : "→ (plain meaning not set yet)");

  const why = seg.why ? seg.why : (seg.kind === "jargon" ? "Jargon can reduce clarity — consider a plain-language version." : "Keeps spelling consistent for UK customers and docs.");

  const canApply = _d4eCanApply(seg);
  const isAcr = (seg.kind === "jargon") && (_d4eIsAcronymLike(seg.term || "") || _d4eIsAcronymLike((seg.term || "").split(" ")[0] || ""));
  const applyLabel = (seg.kind === "jargon") ? (isAcr ? "Spell out" : "Explain") : "Apply";
  const applyDisabled = canApply ? "" : "disabled";
  const undoDisabled = __d4eUndo ? "" : "disabled";

  tip.innerHTML =
    `<span class="pill"><span class="k">${_d4dEscapeHtml(kindLabel)}</span> <span class="v">${_d4dEscapeHtml(seg.term || "")}</span></span>` +
    `<span class="k">${_d4dEscapeHtml(rhs)}</span><br>` +
    `<span class="k">Category:</span> ${_d4dEscapeHtml(cat)} · <span class="k">Why:</span> ${_d4dEscapeHtml(why)}` +
    `<div class="actions">` +
      `<button class="tip-btn" data-act="apply" ${applyDisabled}>${_d4dEscapeHtml(applyLabel)}</button>` +
      `<button class="tip-btn" data-act="undo" ${undoDisabled}>Undo</button>` +
    `</div>`;

  tip.dataset.show = "true";
  // Trust pass: anchor tooltip near the highlighted range (not mouse/caret position).
  try { window.requestAnimationFrame(()=>positionDraftTipToSeg(seg)); } catch(_e){}

  if (__d4dTipTimer) window.clearTimeout(__d4dTipTimer);
  __d4dTipTimer = window.setTimeout(() => { hideDraftTip(); }, 5200);
}

function hideDraftTip() {
  const tip = el.agentDraftTip;
  if (!tip) return;
  tip.dataset.show = "false";
  if (__d4dTipTimer) window.clearTimeout(__d4dTipTimer);
  __d4dTipTimer = null;
}

function focusIssueCard(issueId, attempt = 0) {
  if (!issueId) return;
  const domId = "issue-" + _safeDomId(issueId);
  const node = document.getElementById(domId);
  if (node) {
    node.scrollIntoView({ behavior: "smooth", block: "nearest" });
    node.classList.add("is-flash");
    window.setTimeout(() => node.classList.remove("is-flash"), 850);
    return;
  }
  if (attempt < 10) window.setTimeout(() => focusIssueCard(issueId, attempt + 1), 60);
}

function draftFocusFromCaret(userInitiated) {
  const ta = el.agentDraft;
  if (!ta) return;

  // only act on a caret (not a selection)
  if (ta.selectionStart !== ta.selectionEnd) {
    hideDraftTip();
    return;
  }

  const pos = ta.selectionStart;
  const seg = _d4dFindSegAtPos(pos);

  if (!seg) {
    state.__draftFocusIssueId = "";
    state.__draftFocusSeg = null;
    hideDraftTip();
    scheduleRender();
    return;
  }

  state.__draftFocusIssueId = seg.issueId || "";
  state.__draftFocusSeg = seg;
  showDraftTip(seg);
  scheduleRender();

  if (userInitiated && seg.issueId) {
    // Sync CX Insights to the correct tab and jump to the card
    setCxMode(seg.kind);
    focusIssueCard(seg.issueId);
  }
}


function render() {
    // Safe UI updates (UI-only fork: never assume elements exist)
    if (el.wordCount) el.wordCount.textContent = String(wordCount(state.drafts.agent));
    if (el.checkerState) el.checkerState.textContent = state.checkerOn ? "ON" : "OFF";

    if (el.previewToggle && el.previewState){
      el.previewToggle.setAttribute("aria-pressed", String(!!state.previewOn));
      el.previewState.textContent = state.previewOn ? "ON" : "OFF";
      el.previewToggle.title = state.previewOn ? "Preview: ON" : "Preview: OFF";
    }

    // Glass clarity toggle state (independent of Preview toggle)
    if (el.glassToggle){
      const isClear = (state.glassMode === "clear");
      el.glassToggle.dataset.active = isClear ? "true" : "false";
      el.glassToggle.setAttribute("aria-pressed", isClear ? "true" : "false");
      if (el.glassState) el.glassState.textContent = isClear ? "Clear" : "Frosted";
      el.glassToggle.title = isClear ? "Glass: Clear" : "Glass: Frosted";
    }

    document.body.dataset.motion = state.motionOn ? "on" : "off";
    document.body.dataset.glass = state.glassMode || "frosted";
    if (el.fxBtn) el.fxBtn.dataset.active = state.motionOn ? "true" : "false";
    if (el.fxBtn) el.fxBtn.setAttribute("aria-pressed", state.motionOn ? "true" : "false");
    if (el.fxBtn) el.fxBtn.title = state.motionOn ? "Animations: ON (auto theme shuffle active)" : "Animations: OFF";

    const agentText = state.drafts.agent || "";
    if (el.charCount) el.charCount.textContent = String(agentText.length);

    const ukusN = countUKUS(agentText);
    const jargonN = countJargon(agentText);

    // Optional toolbar chips (may be removed in UI-only forks)
    if (state.checkerOn){
      if (el.ukusCount){
        el.ukusCount.textContent = String(ukusN);
        if (el.ukusCount.parentElement) el.ukusCount.parentElement.style.opacity = "1";
      }
      if (el.jargonCount){
        el.jargonCount.textContent = String(jargonN);
        if (el.jargonCount.parentElement) el.jargonCount.parentElement.style.opacity = "1";
      }
    } else {
      if (el.ukusCount){
        el.ukusCount.textContent = "—";
        if (el.ukusCount.parentElement) el.ukusCount.parentElement.style.opacity = ".70";
      }
      if (el.jargonCount){
        el.jargonCount.textContent = "—";
        if (el.jargonCount.parentElement) el.jargonCount.parentElement.style.opacity = ".70";
      }
    }

    // Writer + Experience cards
    if (state.checkerOn){
      // Phase-F writer recompute (Lite-safe)
      const t = state.drafts.agent || "";
      state.analysis = state.analysis || {};
      const writer = state.analysis.writer || (state.analysis.writer = {});
      writer.text = t;

      if (t.trim()) {
        writer.matchesRaw = buildDraftMatchListRaw(t);
        writer.matchesEffective = resolveDraftMatchesEffective(writer.matchesRaw);
      } else {
        writer.matchesRaw = [];
        writer.matchesEffective = [];
      }

      const eff = writer.matchesEffective || [];
      const clarityFlags = listClarityFlags(t);
      const toneFlags = listToneFlags(t);

      writer.counts = {
        ukus: eff.filter(m => m.kind === "ukus").length,
        jargon: eff.filter(m => m.kind === "jargon").length,
        clarity: clarityFlags.length,
        tone: toneFlags.length
      };
      writer.flags = { clarity: clarityFlags, tone: toneFlags };
      writer.issues = deriveWriterIssues(eff);

      // MFCX Pack output (Writer + Experience)
      try{
        state.mfcx = buildMFCXLite(
          String(state.drafts.customer||""),
          String(state.drafts.agent||""),
          writer.counts,
          writer.flags
        );
      }catch(e){
        state.mfcx = null;
      }


      if (el.writerUKUSN) el.writerUKUSN.textContent = String(writer.counts.ukus);
      if (el.writerJargonN) el.writerJargonN.textContent = String(writer.counts.jargon);
      if (el.writerUKUSN2) el.writerUKUSN2.textContent = String(writer.counts.ukus);
      if (el.writerJargonN2) el.writerJargonN2.textContent = String(writer.counts.jargon);
      if (el.writerClarityN) el.writerClarityN.textContent = String(writer.counts.clarity);
      if (el.writerToneN) el.writerToneN.textContent = String(writer.counts.tone);

      // Rich list render (Jump / Hide / Apply / Ignore)
      renderWriterIssues();

      // Experience signals (money / stress / vulnerability) — keep lightweight (render only in Experience tab)
      const curMode = (state.cxMode || (el.insightsPanel && el.insightsPanel.dataset.cxmode) || "writer");
      if (curMode === "experience") {
        const ex = listExperienceSignals(state.drafts.customer || "");
        if (el.expMoneyN) el.expMoneyN.textContent = String(ex.money.length);
        if (el.expStressN) el.expStressN.textContent = String(ex.stress.length);
        if (el.expVulnN) el.expVulnN.textContent = String(ex.vuln.length);

        const expItems = [];
        for (const msg of ex.money) expItems.push({ key:"Money signal", val: msg });
        for (const msg of ex.stress) expItems.push({ key:"Stress signal", val: msg });
        for (const msg of ex.vuln) expItems.push({ key:"Vulnerability cue", val: msg });
        setExperienceList(el.expList, ex);
      } else if (curMode === "compose") {
        try{ setComposePanel(el.composePanelMount); }catch(e){}
      } else {
        if (el.expMoneyN) el.expMoneyN.textContent = String(listExperienceSignals(state.drafts.customer || "").money.length);
        if (el.expStressN) el.expStressN.textContent = String(listExperienceSignals(state.drafts.customer || "").stress.length);
        if (el.expVulnN) el.expVulnN.textContent = String(listExperienceSignals(state.drafts.customer || "").vuln.length);
        // don't render list when not on Experience tab
        setList(el.expList, []);
      }
    } else {
      if (el.writerUKUSN) el.writerUKUSN.textContent = "—";
      if (el.writerJargonN) el.writerJargonN.textContent = "—";
      if (el.writerClarityN) el.writerClarityN.textContent = "—";
      if (el.writerToneN) el.writerToneN.textContent = "—";
      setList(el.writerList, []);
      if (el.expMoneyN) el.expMoneyN.textContent = "—";
      if (el.expStressN) el.expStressN.textContent = "—";
      if (el.expVulnN) el.expVulnN.textContent = "—";
      setList(el.expList, []);
    }

// Phone transcript (ChatFlow order) + placeholder seeding + live preview / typing dots
    if (el.chatCount) el.chatCount.textContent = `Interactions: ${state.messages.length}`;

    el.chatList.innerHTML = "";

    const hasCustomerCommitted = state.messages.some(m => m.role === "customer");
    const hasAgentCommitted = state.messages.some(m => m.role === "agent");
    const firstCustomerIdx = state.messages.findIndex(m => m.role === "customer");

    // Seed: classic opening bubbles persist until their first real message is committed.
    // When Preview is ON and the user is typing the *first* message for that side,
    // we reuse the seeded bubble as the live preview (no duplicate preview bubble below).
    let seedCustomerBubble = null;
    let seedAgentBubble = null;

    if (!hasCustomerCommitted) {
      const c0 = document.createElement("div");
      c0.className = "bubble placeholder";
      c0.dataset.role = "customer";
      c0.textContent = PLACEHOLDERS.initialCustomer;
      el.chatList.appendChild(c0);
      seedCustomerBubble = c0;

      // If the agent hasn't committed yet, keep the classic agent greeting visible too.
      if (!hasAgentCommitted) {
        const a0 = document.createElement("div");
        a0.className = "bubble placeholder";
        a0.dataset.role = "agent";
        a0.textContent = PLACEHOLDERS.initialAgent;
        el.chatList.appendChild(a0);
        seedAgentBubble = a0;
      }
    }

    // Committed messages (draggable reorder)
    state.messages.forEach((m, idx) => {
      const b = document.createElement("div");
      b.className = "bubble draggable";
      b.dataset.role = m.role;
      b.dataset.idx = String(idx);
      b.draggable = true;
      b.title = "Drag to reorder";
      b.innerHTML = renderRichInline(m.text);
      el.chatList.appendChild(b);

      // Insert the agent greeting after the first committed customer message,
      // if the agent hasn't sent anything yet.
      if (!hasAgentCommitted && !seedAgentBubble && idx === firstCustomerIdx) {
        const a0 = document.createElement("div");
        a0.className = "bubble placeholder";
        a0.dataset.role = "agent";
        a0.textContent = PLACEHOLDERS.initialAgent;
        el.chatList.appendChild(a0);
        seedAgentBubble = a0;
      }
    });

    // Optional typing indicator (demo customer)
    if (state.customerTyping) {
      const t = document.createElement("div");
      t.className = "bubble typing";
      t.dataset.role = "customer";
      t.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
      el.chatList.appendChild(t);
    }

    // Draft signal: live preview OR typing dots depending on Preview toggle
    const activePreview = getActivePreview(); // returns null when Preview is OFF
    let draftIndicatorRole = null;

    if (state.previewOn) {
      if (activePreview) {
        // Special-case: the *first* customer or agent message is a pinned bubble.
        // When previewing it, we replace the seeded placeholder instead of creating a second bubble.
        if (activePreview.role === "customer" && seedCustomerBubble) {
          const t = safeText(activePreview.text).trim();
          if (t) {
            seedCustomerBubble.classList.add("preview");
            seedCustomerBubble.textContent = t;
          } else {
            seedCustomerBubble.classList.remove("preview");
            seedCustomerBubble.textContent = PLACEHOLDERS.initialCustomer;
          }
        } else if (activePreview.role === "agent" && seedAgentBubble) {
          const t = safeText(activePreview.text).trim();
          if (t) {
            seedAgentBubble.classList.add("preview");
            seedAgentBubble.textContent = t;
          } else {
            seedAgentBubble.classList.remove("preview");
            seedAgentBubble.textContent = PLACEHOLDERS.initialAgent;
          }
        } else {
          const p = document.createElement("div");
          p.className = "bubble preview";
          p.dataset.role = activePreview.role;
          p.innerHTML = renderRichInline(activePreview.text);
          el.chatList.appendChild(p);
        }
      }
    } else {
      const aDraft = (state.drafts.agent || "").trim();
      const cDraft = (state.drafts.customer || "").trim();
      let role = null;

      if (state.lastEdited === "agent" && aDraft) role = "agent";
      else if (state.lastEdited === "customer" && cDraft) role = "customer";
      else if (aDraft) role = "agent";
      else if (cDraft) role = "customer";

      if (role) {
        const t = document.createElement("div");
        t.className = "bubble typing";
        t.dataset.role = role;
        t.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
        el.chatList.appendChild(t);
        draftIndicatorRole = role;
      }
    }scrollToBottom();


    updateCxDebug();

    // Keep inputs synced
    if (el.customerMsg.value !== state.drafts.customer) el.customerMsg.value = state.drafts.customer;
    if (el.agentDraft.value !== state.drafts.agent) el.agentDraft.value = state.drafts.agent;
  
  // D-4D overlay render (Lite-safe)
  renderAgentDraftOverlay();
}

  // Experience: render grouped "Customer signals" without adding new detection depth.
  function setExperienceList(container, ex){
  if (!container) return;
  container.innerHTML = "";

  const pack = state.mfcx || buildMFCXLite(
    String(state.drafts.customer||""),
    String(state.drafts.agent||""),
    (state.analysis && state.analysis.writer && state.analysis.writer.counts) ? state.analysis.writer.counts : null,
    (state.analysis && state.analysis.writer && state.analysis.writer.flags) ? state.analysis.writer.flags : null
  );

  const customer = String(state.drafts.customer||"").trim();

  const wrap = document.createElement("div");
  wrap.className = "sig-wrap";

  const intro = document.createElement("div");
  intro.className = "sig-intro";
  intro.textContent = "Experience — customer signals, intent ladder, top questions, and recommended inserts.";
  wrap.appendChild(intro);

  if (!customer){
    const d = document.createElement("div");
    d.className = "insight-muted";
    d.textContent = "Add a customer message to see Experience insights.";
    wrap.appendChild(d);
    container.appendChild(wrap);
    return;
  }

  // Recommended inserts (cards)
  const rec = document.createElement("div");
  rec.className = "mf-sec";
  rec.appendChild(MF_el("div","mf-sec-head","Recommended inserts"));

  const cards = (pack && pack.experience && Array.isArray(pack.experience.cards)) ? pack.experience.cards : [];
  if (!cards.length){
    rec.appendChild(MF_el("div","insight-muted","No inserts yet — start drafting and the engine will suggest what’s missing."));
  } else {
    for (const c of cards){
      const box = MF_el("div","mf-exp-card");
      box.appendChild(MF_el("div","mf-exp-title", c.title || "Recommendation"));
      box.appendChild(MF_el("div","mf-exp-why", c.why || ""));

      const dn = MF_el("ul","mf-exp-next");
      (c.doNext||[]).forEach(x=>{
        const li = document.createElement("li");
        li.textContent = x;
        dn.appendChild(li);
      });
      box.appendChild(dn);

      const actions = MF_el("div","mf-actions");

      const bAdd = MF_el("button","btn-mini","Add to Compose");
      bAdd.type="button";
      bAdd.addEventListener("click", ()=>{
        const name = MF_guessName(customer);
        const ctx = { name, time: MF_nowHM(), topQuestion: (pack.experience.topQuestions && pack.experience.topQuestions[0]) ? pack.experience.topQuestions[0] : "" };
        MF_addToCompose((c.inserts && c.inserts[0]) ? c.inserts[0] : "", ctx, { title: c.title || "Recommendation", source: "experience-card" });
      });
      actions.appendChild(bAdd);

      const bIns = MF_el("button","btn-mini","Insert now");
      bIns.type="button";
      bIns.addEventListener("click", ()=>{
        const name = MF_guessName(customer);
        const ctx = { name, time: MF_nowHM(), topQuestion: (pack.experience.topQuestions && pack.experience.topQuestions[0]) ? pack.experience.topQuestions[0] : "" };
        MF_insertIntoAgentDraft((c.inserts && c.inserts[0]) ? c.inserts[0] : "", ctx);
      });
      actions.appendChild(bIns);

      box.appendChild(actions);

      rec.appendChild(box);
    }
  }
  wrap.appendChild(rec);

  // Signals
  const sig = MF_el("div","mf-sec");
  sig.appendChild(MF_el("div","mf-sec-head","Signals"));
  const sList = MF_el("div","insight-list");
  const groups = [
    { k:"Money", arr:(ex && ex.money) || [] },
    { k:"Stress", arr:(ex && ex.stress) || [] },
    { k:"Vulnerability", arr:(ex && ex.vuln) || [] }
  ];
  let anySig = false;
  for (const g of groups){
    if (!g.arr.length) continue;
    anySig = true;
    for (const msg of g.arr){
      const row = MF_el("div","insight-item");
      row.innerHTML = `<div class="insight-dot"></div>`;
      const col = MF_el("div","insight-col");
      col.appendChild(MF_el("div","k", g.k));
      col.appendChild(MF_el("div","v", msg));
      row.appendChild(col);
      sList.appendChild(row);
    }
  }
  if (!anySig) sList.innerHTML = `<div class="insight-muted">No strong signals detected yet.</div>`;
  sig.appendChild(sList);
  wrap.appendChild(sig);

  // Intent ladder
  const il = (pack && pack.experience && pack.experience.intentLadder) ? pack.experience.intentLadder : {tier1:[],tier2:[],tier3:[]};
  const ladder = MF_el("div","mf-sec");
  ladder.appendChild(MF_el("div","mf-sec-head","Intent ladder"));

  const mkTier = (label, arr)=>{
    const d = MF_el("div","mf-tier");
    d.appendChild(MF_el("div","mf-tier-label", label));
    const chips = MF_el("div","mf-chiprow");
    (arr||[]).forEach(x=>{
      const c = MF_el("span","chip", x);
      chips.appendChild(c);
    });
    if (!(arr||[]).length) chips.appendChild(MF_el("span","insight-muted","None"));
    d.appendChild(chips);
    return d;
  };

  ladder.appendChild(mkTier("Tier 1 (highest impact)", il.tier1));
  ladder.appendChild(mkTier("Tier 2", il.tier2));
  ladder.appendChild(mkTier("Tier 3", il.tier3));
  wrap.appendChild(ladder);

  // Top questions + insert scaffold
  const qs = MF_el("div","mf-sec");
  qs.appendChild(MF_el("div","mf-sec-head","Top questions"));

  const topQs = (pack && pack.experience && Array.isArray(pack.experience.topQuestions)) ? pack.experience.topQuestions : [];
  if (!topQs.length){
    qs.appendChild(MF_el("div","insight-muted","No direct questions detected (no “?” style questions found)."));
  } else {
    for (const q of topQs){
      const row = MF_el("div","insight-item");
      row.innerHTML = `<div class="insight-dot"></div>`;
      const col = MF_el("div","insight-col");
      col.appendChild(MF_el("div","k","Question"));
      col.appendChild(MF_el("div","v", q));

      const actions = MF_el("div","mf-actions");

      const bAdd = MF_el("button","btn-mini","Add answer scaffold");
      bAdd.type="button";
      bAdd.addEventListener("click", ()=>{
        const name = MF_guessName(customer);
        const ctx = { name, time: MF_nowHM(), topQuestion: q, answer: "[Answer]" };
        const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_clarifier_topq");
        MF_addToCompose(t ? t.insert : "", ctx, { title: "Answer scaffold", source: "top-question" });
      });
      actions.appendChild(bAdd);

      const b = MF_el("button","btn-mini","Insert now");
      b.type="button";
      b.addEventListener("click", ()=>{
        const name = MF_guessName(customer);
        const ctx = { name, time: MF_nowHM(), topQuestion: q, answer: "[Answer]" };
        const t = MFCX_CONTENT.suggestion_templates.find(x=>x.id==="sg_clarifier_topq");
        MF_insertIntoAgentDraft(t ? t.insert : "", ctx);
      });
      actions.appendChild(b);

      col.appendChild(actions);

      row.appendChild(col);
      qs.appendChild(row);
    }
  }
  wrap.appendChild(qs);

  container.appendChild(wrap);
}

  // --------------------------------
  // Compose (CX tab) — assemble → commit
  // --------------------------------
  function setComposePanel(mount){
    const m = mount;
    if (!m) return;
    m.innerHTML = "";

    const pack = state.mfcx || {};
    const customer = String(state.drafts.customer || "");

    const name = MF_guessName(customer);
    const ctx = { name, time: MF_nowHM() };

    // -------------------------------
    // Local history (Compose draft)
    // -------------------------------
    state.composeDraft = state.composeDraft || { text: "" };
    state.composeHist = state.composeHist || { stack: [], idx: -1 };

    function composeHistPush(prev){
      const h = state.composeHist;
      // drop redo tail
      if (h.idx < h.stack.length - 1) h.stack = h.stack.slice(0, h.idx + 1);
      h.stack.push(String(prev || ""));
      h.idx = h.stack.length - 1;
      // cap
      if (h.stack.length > 60){
        const drop = h.stack.length - 60;
        h.stack = h.stack.slice(drop);
        h.idx = Math.max(-1, h.idx - drop);
      }
    }

    function composeUndo(){
      const h = state.composeHist;
      if (h.idx < 0) return;
      const prev = h.stack[h.idx];
      h.idx -= 1;
      state.composeDraft.text = String(prev || "");
      render();
    }

    function composeRedo(){
      const h = state.composeHist;
      if (h.idx >= h.stack.length - 1) return;
      h.idx += 1;
      const val = h.stack[h.idx];
      state.composeDraft.text = String(val || "");
      render();
    }

    function insertIntoComposeDraft(template, opts){
      const o = opts || {};
      const raw = (o.raw === true) ? String(template || "") : MF_tokenReplace(String(template || ""), ctx);
      const txt = String(raw || "");
      if (!txt.trim()) return;

      const ta = el.composeDraft;
      if (!ta) return;
      const before = String(ta.value || "");
      composeHistPush(before);

      // smart insert behavior
      const isEmpty = !before.trim();
      const forceReplace = (o.forceReplace === true);

      if (isEmpty || forceReplace){
        ta.value = txt.trim() + "\n";
        state.composeDraft.text = ta.value;
        ta.focus();
        ta.setSelectionRange(ta.value.length, ta.value.length);
        return;
      }

      const s = ta.selectionStart ?? before.length;
      const e = ta.selectionEnd ?? before.length;
      const head = before.slice(0, s);
      const tail = before.slice(e);

      // spacing: ensure a blank line between blocks unless already present
      const needsLead = head && !head.endsWith("\n\n") ? (head.endsWith("\n") ? "\n" : "\n\n") : "";
      const needsTail = tail && !tail.startsWith("\n") ? "\n" : "";

      const mid = needsLead + txt.trim() + "\n" + needsTail;
      ta.value = head + mid + tail;
      state.composeDraft.text = ta.value;

      const cursor = (head + mid).length;
      ta.focus();
      ta.setSelectionRange(cursor, cursor);
    }

    function render(){
      m.innerHTML = "";

      // Ensure auto-draft seed
      const autoText = MF_buildAutoDraft(customer, pack) || "";
      if (!state.composeDraft.text.trim()){
        state.composeDraft.text = autoText ? (String(autoText).trim() + "\n") : "";
      }

      // Header blurb
      const hint = MF_el("div","mf-hint", "Compose — assemble and edit your reply here, then commit to the draft when ready.");
      m.appendChild(hint);

      // --------------------------------
      // Auto-draft (suggested)
      // --------------------------------
      const autoSec = MF_el("div","mf-sec");
      const autoHead = MF_el("div","mf-sec-head","Auto-draft");
      autoSec.appendChild(autoHead);

      const autoCard = MF_el("div","mf-card");
      const autoPreview = MF_el("pre","mf-pre");
      autoPreview.textContent = String(autoText || "").trim() || "(No suggestion yet — add a customer message.)";
      autoCard.appendChild(autoPreview);

      const autoBtns = MF_el("div","mf-actions");

      const bCopy = MF_el("button","mf-btn", "Copy");
      bCopy.addEventListener("click", async ()=>{
        try{ await navigator.clipboard.writeText(String(autoText||"")); toast("Copied.", false); }
        catch(e){ toast("Copy failed.", true); }
      });
      autoBtns.appendChild(bCopy);

      const bLoad = MF_el("button","mf-btn", "Load into Compose");
      bLoad.addEventListener("click", ()=>{
        if (!el.composeDraft) return;
        composeHistPush(String(el.composeDraft.value||""));
        state.composeDraft.text = String(autoText||"").trim() + "\n";
        render();
        requestAnimationFrame(()=>{ el.composeDraft?.focus(); el.composeDraft?.setSelectionRange(el.composeDraft.value.length, el.composeDraft.value.length); });
        toast("Loaded into Compose.", false);
      });
      autoBtns.appendChild(bLoad);

      const bAppend = MF_el("button","mf-btn", "Add to Compose");
      bAppend.addEventListener("click", ()=> insertIntoComposeDraft(String(autoText||""), { raw:true }));
      autoBtns.appendChild(bAppend);

      const bEdit = MF_el("button","mf-btn", "Edit in Compose");
      bEdit.addEventListener("click", ()=>{
        if (!el.composeDraft) return;
        if (!state.composeDraft.text.trim()){
          composeHistPush(String(el.composeDraft.value||""));
          state.composeDraft.text = String(autoText||"").trim() + "\n";
          render();
        }
        requestAnimationFrame(()=>{ el.composeDraft?.focus(); });
      });
      autoBtns.appendChild(bEdit);

      autoCard.appendChild(autoBtns);
      autoSec.appendChild(autoCard);
      m.appendChild(autoSec);

      // --------------------------------
      // Compose draft (editable)
      // --------------------------------
      const draftSec = MF_el("div","mf-sec");
      draftSec.appendChild(MF_el("div","mf-sec-head","Compose draft"));

      const ta = MF_el("textarea","mf-compose-ta");
      ta.spellcheck = true;
      ta.value = String(state.composeDraft.text || "");
      ta.addEventListener("input", ()=>{ state.composeDraft.text = ta.value; });
      el.composeDraft = ta;
      draftSec.appendChild(ta);

      const row = MF_el("div","mf-actions");

      const btnCopy = MF_el("button","mf-btn", "Copy");
      btnCopy.addEventListener("click", async ()=>{
        try{ await navigator.clipboard.writeText(String(el.composeDraft?.value||"")); toast("Copied.", false); }
        catch(e){ toast("Copy failed.", true); }
      });
      row.appendChild(btnCopy);

      const btnAppend = MF_el("button","mf-btn", "Append → Draft");
      btnAppend.addEventListener("click", ()=>{
        MF_insertIntoAgentDraft(String(el.composeDraft?.value||""), ctx, { raw:true, forceReplace:false });
        MF_syncAgentToPhone();
      });
      row.appendChild(btnAppend);

      const btnReplace = MF_el("button","mf-btn", "Replace draft");
      btnReplace.addEventListener("click", ()=>{
        MF_insertIntoAgentDraft(String(el.composeDraft?.value||""), ctx, { raw:true, forceReplace:true });
        MF_syncAgentToPhone();
      });
      row.appendChild(btnReplace);

      const btnUndo = MF_el("button","mf-btn", "Undo");
      btnUndo.addEventListener("click", composeUndo);
      row.appendChild(btnUndo);

      const btnRedo = MF_el("button","mf-btn", "Redo");
      btnRedo.addEventListener("click", composeRedo);
      row.appendChild(btnRedo);

      const btnClear = MF_el("button","mf-btn", "Clear");
      btnClear.addEventListener("click", ()=>{
        composeHistPush(String(el.composeDraft?.value||""));
        state.composeDraft.text = "";
        render();
      });
      row.appendChild(btnClear);

      draftSec.appendChild(row);
      m.appendChild(draftSec);

      // --------------------------------
      // Compose library (click to insert into Compose)
      // --------------------------------
      const libSec = MF_el("div","mf-sec");
      libSec.appendChild(MF_el("div","mf-sec-head","Compose library"));

      const libHint = MF_el("div","mf-hint", "Tip: pick any block below — it inserts into your Compose draft (not the agent draft)." );
      libSec.appendChild(libHint);

      // 1) Experience recommended inserts (from cards)
      const expCards = (pack.experience && Array.isArray(pack.experience.cards)) ? pack.experience.cards : [];
      if (expCards.length){
        const details = MF_el("details","mf-block");
        details.open = true;
        details.appendChild(MF_el("summary","mf-block-sum","Recommended inserts (Experience)"));
        const list = MF_el("div","mf-chipwrap");
        for (const c of expCards){
          const t = String(c.insert || c.text || "");
          if (!t.trim()) continue;
          const chip = MF_el("button","mf-chip", c.title || "Insert");
          chip.addEventListener("click", ()=> insertIntoComposeDraft(t, { raw:true }));
          list.appendChild(chip);
        }
        details.appendChild(list);
        libSec.appendChild(details);
      }

      // 2) Writer Top Picks
      const topPicks = (pack.writer && Array.isArray(pack.writer.topPicks)) ? pack.writer.topPicks : [];
      if (topPicks.length){
        const details = MF_el("details","mf-block");
        details.open = true;
        details.appendChild(MF_el("summary","mf-block-sum","Top Picks (Writer)"));
        const list = MF_el("div","mf-chipwrap");
        for (const p of topPicks){
          const t = String(p.insert || "");
          if (!t.trim()) continue;
          const chip = MF_el("button","mf-chip", p.title || p.label || "Pick");
          chip.addEventListener("click", ()=> insertIntoComposeDraft(t, { raw:true }));
          list.appendChild(chip);
        }
        details.appendChild(list);
        libSec.appendChild(details);
      }

      // 3) Reply blocks
      const rbs = Array.isArray(MFCX_CONTENT.reply_blocks) ? MFCX_CONTENT.reply_blocks : [];
      if (rbs.length){
        const details = MF_el("details","mf-block");
        details.appendChild(MF_el("summary","mf-block-sum","Reply blocks"));
        const list = MF_el("div","mf-list");
        for (const rb of rbs){
          const row = MF_el("div","mf-row");
          const left = MF_el("div","mf-row-left");
          left.appendChild(MF_el("div","mf-row-title", rb.title || "Block"));
          const act = MF_el("div","mf-row-actions");
          const b = MF_el("button","mf-btn-sm", "Add");
          b.addEventListener("click", ()=> insertIntoComposeDraft(String(rb.text||""), { raw:true }));
          act.appendChild(b);
          row.appendChild(left);
          row.appendChild(act);
          list.appendChild(row);
        }
        details.appendChild(list);
        libSec.appendChild(details);
      }

      // 4) Power phrases (same as Writer, but insert into Compose)
      const phraseGroups = [
        ["Openers","openers"],
        ["Empathy","empathy"],
        ["Ownership","ownership"],
        ["Clarifiers","clarifiers"],
        ["Expectations","expectations"],
        ["Money clarity","money_clarity"],
        ["Closing","closing"],
      ];
      for (const [label, key] of phraseGroups){
        const items = (MFCX_CONTENT.power_phrases && Array.isArray(MFCX_CONTENT.power_phrases[key])) ? MFCX_CONTENT.power_phrases[key] : [];
        if (!items.length) continue;
        const details = MF_el("details","mf-block");
        details.open = (key === "openers");
        details.appendChild(MF_el("summary","mf-block-sum", label));
        const wrap = MF_el("div","mf-chipwrap");
        for (const t0 of items){
          const chip = MF_el("button","mf-chip", MF_tokenReplace(String(t0||""), ctx));
          chip.addEventListener("click", ()=> insertIntoComposeDraft(String(t0||""), { raw:false }));
          wrap.appendChild(chip);
        }
        details.appendChild(wrap);
        libSec.appendChild(details);
      }

      m.appendChild(libSec);
    }

    render();
  }





  function addMessage(role, text) {
    const t = safeText(text).trim();
    if (!t) return false;

    // On first real commit, switch inputs to default placeholders (classic behaviour)
    if (!state.hasCommitted) {
      state.hasCommitted = true;
      applyInputPlaceholders("default");
    }

    state.messages.push({ role, text: t, ts: Date.now() });
    render();
    return true;
  }

  function addCustomer() {
    const txt = (state.drafts.customer || "").trim();
    if (!txt) { toast("Customer message is empty", true); return; }
    addMessage("customer", txt);
    state.drafts.customer = "";
    render();
  }

  function sendAgent() {
    const txt = (state.drafts.agent || "").trim();
    if (!txt) { toast("Agent draft is empty", true); return; }
    addMessage("agent", txt);
    state.drafts.agent = "";
    histPush("");
    render();
  }

  function pulsePhoneSendDot(){
    el.phoneSendBtn.classList.remove("pulse");
    void el.phoneSendBtn.offsetWidth; // reflow to restart animation
    el.phoneSendBtn.classList.add("pulse");
    window.setTimeout(() => el.phoneSendBtn.classList.remove("pulse"), 520);
  }

  function sendNextCustomerReply(){
    // Safety: only intended when agent draft is empty
    if(state.customerTyping) return;
    if(!DEMO_CUSTOMER_REPLIES || !DEMO_CUSTOMER_REPLIES.length){
      toast("No demo customer replies configured.", true);
      return;
    }

    pulsePhoneSendDot();
    state.customerTyping = true;
    render();

    const idx = state.demoCustomerIndex % DEMO_CUSTOMER_REPLIES.length;
    const text = DEMO_CUSTOMER_REPLIES[idx];
    state.demoCustomerIndex = (idx + 1) % DEMO_CUSTOMER_REPLIES.length;

    window.setTimeout(() => {
      state.customerTyping = false;
      addMessage("customer", text);
    persistSave(true);
    }, 420);
  }


  function clearAll() {
    state.messages = [];
    state.drafts.customer = "";
    state.drafts.agent = "";
    state.hasCommitted = false;
    applyInputPlaceholders("initial");
    try { localStorage.removeItem(STORAGE_KEY); } catch(e){}
    hist.stack = [""]; hist.idx = 0;
    render();
    toast("Cleared");
  }

  async function doPaste(){
    try{
      const txt = await navigator.clipboard.readText();
      if (!txt) { toast("Clipboard empty", true); return; }
      el.agentDraft.focus();
      const v = el.agentDraft.value;
      const start = el.agentDraft.selectionStart ?? v.length;
      const end = el.agentDraft.selectionEnd ?? v.length;
      const next = v.slice(0, start) + txt + v.slice(end);
      el.agentDraft.value = next;
      el.agentDraft.setSelectionRange(start + txt.length, start + txt.length);
      state.drafts.agent = next;
      histPush(next);
      render();
    } catch(e){
      toast("Paste blocked by browser", true);
    }
  }

  async function doCopy(){
    const txt = el.agentDraft.value || "";
    try{
      await navigator.clipboard.writeText(txt);
      toast("Copied");
    } catch(e){
      try{
        el.agentDraft.select();
        document.execCommand("copy");
        toast("Copied");
      } catch(_){
        toast("Copy blocked by browser", true);
      } finally {
        el.agentDraft.setSelectionRange(el.agentDraft.value.length, el.agentDraft.value.length);
        el.agentDraft.focus();
      }
    }
  }

  const QUICK_REPLIES = [
    "Hi, thanks for reaching out — I can help with that.",
    "Thanks for your patience. I’m going to check this now and come back to you with an update.",
    "I’m sorry this has been frustrating. I’ll take ownership and make sure we get you clarity."
  ];
  const QUICK_PHRASES = [
    "Next steps:",
    "To confirm,",
    "Just so you’re aware,",
    "One idea per sentence keeps things clear."
  ];
  function insertAtCursor(textarea, snippet){
    // Raw text insert (preserve spacing + cursor position)
    const v = textarea.value || "";
    const start = (typeof textarea.selectionStart === "number") ? textarea.selectionStart : v.length;
    const end   = (typeof textarea.selectionEnd   === "number") ? textarea.selectionEnd   : v.length;

    const prevScroll = textarea.scrollTop;

    if (typeof textarea.setRangeText === "function"){
      textarea.focus();
      textarea.setRangeText(String(snippet), start, end, "end");
    } else {
      const next = v.slice(0, start) + String(snippet) + v.slice(end);
      textarea.value = next;
      const caret = start + String(snippet).length;
      textarea.setSelectionRange(caret, caret);
      textarea.focus();
    }

    textarea.scrollTop = prevScroll;
  }

  function openMenu(anchorBtn, items, onPick){
    closeMenu();
    const r = anchorBtn.getBoundingClientRect();
    const m = document.createElement("div");
    m.id = "mfMenu";
    m.style.position = "fixed";
    m.style.left = `${Math.min(window.innerWidth - 240, r.left)}px`;
    m.style.top = `${r.bottom + 8}px`;
    m.style.width = "240px";
    m.style.borderRadius = "14px";
    m.style.border = "1px solid rgba(255,255,255,.16)";
    m.style.background = "rgba(0,0,0,.66)";
    m.style.backdropFilter = "blur(12px)";
    m.style.boxShadow = "0 18px 50px rgba(0,0,0,.55)";
    m.style.padding = "6px";
    m.style.zIndex = "9998";
    items.forEach((t) => {
      const b = document.createElement("button");
      b.type = "button";
      b.textContent = t;
      b.style.width = "100%";
      b.style.textAlign = "left";
      b.style.padding = "10px 10px";
      b.style.borderRadius = "12px";
      b.style.border = "1px solid rgba(255,255,255,.10)";
      b.style.background = "rgba(255,255,255,.06)";
      b.style.color = "rgba(255,255,255,.90)";
      b.style.cursor = "pointer";
      b.style.margin = "4px 0";
      b.onmouseenter = () => b.style.background = "rgba(255,255,255,.10)";
      b.onmouseleave = () => b.style.background = "rgba(255,255,255,.06)";
      b.onclick = () => { onPick(t); closeMenu(); };
      m.appendChild(b);
    });
    document.body.appendChild(m);
    setTimeout(() => window.addEventListener("mousedown", onOutside, { once:true }), 0);
    function onOutside(e){ if (!m.contains(e.target)) closeMenu(); }
  }
  
// Compose builder (multi-select) – preview shows exactly what will be inserted.
function openComposeMenu(anchorBtn, items, onInsert){
  closeMenu();
  const r = anchorBtn.getBoundingClientRect();
  const m = document.createElement("div");
  m.id = "mfMenu";
  m.setAttribute("role","dialog");
  m.setAttribute("aria-label","Compose scaffold");

  // Layout + positioning
  const width = 360;
  const left = Math.min(window.innerWidth - (width + 16), Math.max(12, r.left));
  const top = Math.min(window.innerHeight - 420, r.bottom + 10);

  m.style.position = "fixed";
  m.style.left = `${left}px`;
  m.style.top = `${top}px`;
  m.style.width = `${width}px`;
  m.style.borderRadius = "16px";
  m.style.border = "1px solid rgba(255,255,255,.16)";
  m.style.background = "rgba(0,0,0,.66)";
  m.style.backdropFilter = "blur(12px)";
  m.style.boxShadow = "0 18px 55px rgba(0,0,0,.62)";
  m.style.padding = "10px";
  m.style.zIndex = "9998";
  m.style.display = "flex";
  m.style.flexDirection = "column";
  m.style.gap = "10px";

  // Header
  const head = document.createElement("div");
  head.style.display = "flex";
  head.style.alignItems = "center";
  head.style.justifyContent = "space-between";
  head.style.gap = "10px";

  const title = document.createElement("div");
  title.textContent = "Compose";
  title.style.fontSize = "0.78rem";
  title.style.fontWeight = "700";
  title.style.letterSpacing = "0.06em";
  title.style.textTransform = "uppercase";
  title.style.color = "rgba(255,255,255,.88)";

  const x = document.createElement("button");
  x.type = "button";
  x.textContent = "×";
  x.style.width = "28px";
  x.style.height = "28px";
  x.style.borderRadius = "999px";
  x.style.border = "1px solid rgba(255,255,255,.16)";
  x.style.background = "rgba(255,255,255,.06)";
  x.style.color = "rgba(255,255,255,.9)";
  x.style.cursor = "pointer";
  x.style.fontSize = "1.05rem";
  x.onclick = () => closeMenu();

  head.appendChild(title);
  head.appendChild(x);

  // Body split: pick list + preview
  const body = document.createElement("div");
  body.style.display = "grid";
  body.style.gridTemplateColumns = "1fr";
  body.style.gap = "10px";

  const listWrap = document.createElement("div");
  listWrap.style.border = "1px solid rgba(255,255,255,.10)";
  listWrap.style.borderRadius = "14px";
  listWrap.style.background = "rgba(255,255,255,.04)";
  listWrap.style.padding = "8px";
  listWrap.style.maxHeight = "150px";
  listWrap.style.overflow = "auto";

  const previewWrap = document.createElement("div");
  previewWrap.style.border = "1px solid rgba(255,255,255,.10)";
  previewWrap.style.borderRadius = "14px";
  previewWrap.style.background = "rgba(255,255,255,.04)";
  previewWrap.style.padding = "10px";

  const previewLabel = document.createElement("div");
  previewLabel.textContent = "Preview";
  previewLabel.style.fontSize = "0.70rem";
  previewLabel.style.letterSpacing = "0.06em";
  previewLabel.style.textTransform = "uppercase";
  previewLabel.style.color = "rgba(255,255,255,.68)";
  previewLabel.style.marginBottom = "6px";

  const preview = document.createElement("pre");
  preview.style.margin = "0";
  preview.style.whiteSpace = "pre-wrap";
  preview.style.wordBreak = "break-word";
  preview.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  preview.style.fontSize = "0.74rem";
  preview.style.lineHeight = "1.45";
  preview.style.color = "rgba(255,255,255,.88)";
  preview.style.maxHeight = "155px";
  preview.style.overflow = "auto";

  const emptyHint = document.createElement("div");
  emptyHint.textContent = "Select blocks to assemble a reply";
  emptyHint.style.fontSize = "0.74rem";
  emptyHint.style.lineHeight = "1.35";
  emptyHint.style.color = "rgba(255,255,255,.62)";
  emptyHint.style.padding = "4px 0";

  previewWrap.appendChild(previewLabel);
  previewWrap.appendChild(emptyHint);
  previewWrap.appendChild(preview);

  // State
  const picked = new Array(items.length).fill(false);

  function buildOutput(){
    // Option A (clean): plain lines in list order
    const blocks = [];
    for(let i=0;i<items.length;i++){
      if(picked[i]) blocks.push(String(items[i]));
    }
    const out = blocks.join("\n\n");
    preview.textContent = out;
    const has = out.trim().length > 0;
    emptyHint.style.display = has ? "none" : "block";
    btnInsert.disabled = !has;
    btnInsert.style.opacity = has ? "1" : "0.55";
    return out;
  }

  // List
  items.forEach((t, i) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.alignItems = "flex-start";
    row.style.gap = "10px";
    row.style.padding = "8px 8px";
    row.style.borderRadius = "12px";
    row.style.cursor = "pointer";
    row.style.userSelect = "none";
    row.style.border = "1px solid rgba(255,255,255,.10)";
    row.style.background = "rgba(255,255,255,.05)";
    row.style.margin = "6px 0";
    row.onmouseenter = () => row.style.background = "rgba(255,255,255,.09)";
    row.onmouseleave = () => row.style.background = picked[i] ? "rgba(56,189,248,.16)" : "rgba(255,255,255,.05)";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.style.marginTop = "3px";
    cb.checked = false;

    const txt = document.createElement("div");
    txt.textContent = t;
    txt.style.flex = "1";
    txt.style.fontSize = "0.74rem";
    txt.style.lineHeight = "1.35";
    txt.style.color = "rgba(255,255,255,.90)";

    function sync(){
      picked[i] = cb.checked;
      row.style.background = picked[i] ? "rgba(56,189,248,.16)" : "rgba(255,255,255,.05)";
      row.style.borderColor = picked[i] ? "rgba(56,189,248,.45)" : "rgba(255,255,255,.10)";
      buildOutput();
    }

    cb.addEventListener("change", sync);
    row.addEventListener("click", (e)=>{
      if(e.target !== cb) cb.checked = !cb.checked;
      sync();
    });

    row.appendChild(cb);
    row.appendChild(txt);
    listWrap.appendChild(row);
  });

  body.appendChild(listWrap);
  body.appendChild(previewWrap);

  // Actions
  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  actions.style.justifyContent = "space-between";

  const btnReset = document.createElement("button");
  btnReset.type = "button";
  btnReset.textContent = "Reset scaffold";
  btnReset.style.flex = "1";
  btnReset.style.padding = "10px 10px";
  btnReset.style.borderRadius = "12px";
  btnReset.style.border = "1px solid rgba(255,255,255,.16)";
  btnReset.style.background = "rgba(255,255,255,.06)";
  btnReset.style.color = "rgba(255,255,255,.85)";
  btnReset.style.cursor = "pointer";

  const btnInsert = document.createElement("button");
  btnInsert.type = "button";
  btnInsert.textContent = "Insert";
  btnInsert.style.flex = "1";
  btnInsert.style.padding = "10px 10px";
  btnInsert.style.borderRadius = "12px";
  btnInsert.style.border = "1px solid rgba(56,189,248,.55)";
  btnInsert.style.background = "rgba(56,189,248,.18)";
  btnInsert.style.color = "rgba(255,255,255,.95)";
  btnInsert.style.cursor = "pointer";
  btnInsert.disabled = true;
  btnInsert.style.opacity = "0.55";

  btnReset.onclick = () => {
    for(let i=0;i<picked.length;i++) picked[i] = false;
    Array.from(listWrap.querySelectorAll('input[type="checkbox"]')).forEach(cb=>cb.checked=false);
    Array.from(listWrap.children).forEach((row)=>{
      row.style.background = "rgba(255,255,255,.05)";
      row.style.borderColor = "rgba(255,255,255,.10)";
    });
    buildOutput();
  };

  btnInsert.onclick = () => {
    const out = buildOutput();
    if (!out.trim()) return;
    onInsert(out);
    closeMenu();
  };

  actions.appendChild(btnReset);
  actions.appendChild(btnInsert);

  m.appendChild(head);
  m.appendChild(body);
  m.appendChild(actions);

  document.body.appendChild(m);

  buildOutput();

  setTimeout(() => {
    window.addEventListener("mousedown", onOutside, { once:true });
    window.addEventListener("keydown", onKeyDown, { once:true });
  }, 0);

  function onOutside(e){ if (!m.contains(e.target)) closeMenu(); }
  function onKeyDown(e){ if(e.key === "Escape") closeMenu(); }
}

function closeMenu(){
    const m = document.getElementById("mfMenu");
    if (m) m.remove();
  }

  // Particles
  const P = {
    ctx: null, w: 0, h: 0,
    dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
    parts: [], raf: 0, running: false,
    c1: [122,180,255], c2: [185,139,255]
  };

  function hexToRgb(hex){
    const h = (hex || "").trim();
    const m = /^#?([0-9a-f]{6})$/i.exec(h);
    if (!m) return [122,180,255];
    const n = parseInt(m[1], 16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  }
  function cssVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
  function syncParticleColours(){
    P.c1 = hexToRgb(cssVar("--accent") || "#7AB4FF");
    P.c2 = hexToRgb(cssVar("--accent2") || "#B98BFF");
    document.documentElement.style.setProperty("--accentRGB", P.c1.join(','));
    document.documentElement.style.setProperty("--accent2RGB", P.c2.join(','));
  }
  function resizeCanvas(){
    const rect = el.canvas.getBoundingClientRect();
    P.w = Math.max(1, Math.floor(rect.width));
    P.h = Math.max(1, Math.floor(rect.height));
    el.canvas.width = Math.floor(P.w * P.dpr);
    el.canvas.height = Math.floor(P.h * P.dpr);
    el.canvas.style.width = P.w + "px";
    el.canvas.style.height = P.h + "px";
    if (P.ctx) P.ctx.setTransform(P.dpr, 0, 0, P.dpr, 0, 0);
  }
  function makeParts(){
    const bgmode = (document.body.dataset.bgmode || "static").toLowerCase();
    const starsInt = Math.max(0, Number(cssVar("--stars-int") || 0) || 0);
    const dens = Math.max(0.25, Number(cssVar("--mag-den") || 1) || 1);

    let count;
    if(bgmode === "stars"){
      // starfield: scale by area; keep a sane cap so laptops don't melt
      count = Math.round((P.w * P.h) / 9000 * Math.max(0.5, starsInt || 1));
      count = Math.max(80, Math.min(320, count));
    } else {
      // legacy soft particles (kept for non-stars modes)
      count = Math.round(Math.sqrt(P.w * P.h) / 18 * dens);
      count = Math.max(40, Math.min(220, count));
    }

    P.parts = [];
    for (let i=0;i<count;i++){
      if(bgmode === "stars"){
        const s = 0.6 + Math.random()*1.6;
        P.parts.push({
          x: Math.random()*P.w, y: Math.random()*P.h,
          r: s,
          a: 0.25 + Math.random()*0.55,
          vx: (-0.08 + Math.random()*0.16),
          vy: (0.15 + Math.random()*0.55),
          tw: 0.002 + Math.random()*0.010,
          t: Math.random()*Math.PI*2
        });
      } else {
        P.parts.push({
          x: Math.random()*P.w, y: Math.random()*P.h,
          r: 0.6 + Math.random()*1.8,
          a: 0.10 + Math.random()*0.22,
          vx: (-0.10 + Math.random()*0.20),
          vy: (-0.18 + Math.random()*0.22),
          t: Math.random()*Math.PI*2
        });
      }
    }
  }
  function drawParticles(){
    if (!P.running) return;
    const ctx = P.ctx;
    ctx.clearRect(0,0,P.w,P.h);

    const bgmode = (document.body.dataset.bgmode || "static").toLowerCase();
    if(bgmode === "stars"){
      // Subtle wash so stars sit in the sky (no heavy vignette here; CSS vignette handles it)
      const wash = ctx.createLinearGradient(0,0,0,P.h);
      wash.addColorStop(0, "rgba(0,0,0,0.10)");
      wash.addColorStop(1, "rgba(0,0,0,0.22)");
      ctx.fillStyle = wash;
      ctx.fillRect(0,0,P.w,P.h);

      for (const p of P.parts){
        p.t += p.tw;
        p.x += p.vx;
        p.y += p.vy;

        if (p.x < -20) p.x = P.w + 20;
        if (p.x > P.w + 20) p.x = -20;
        if (p.y < -20) p.y = P.h + 20;
        if (p.y > P.h + 20) p.y = -20;

        // twinkle
        const tw = 0.65 + 0.35 * (Math.sin(p.t*6) * 0.5 + 0.5);

        // tint stars slightly toward accent (keeps brand feel without neon)
        const mix = (Math.sin(p.t)+1)/2;
        const r = Math.round(240*(1-mix) + P.c1[0]*mix);
        const g2 = Math.round(240*(1-mix) + P.c1[1]*mix);
        const b = Math.round(248*(1-mix) + P.c2[2]*mix);

        ctx.fillStyle = `rgba(${r},${g2},${b},${(p.a*tw).toFixed(3)})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      }

      P.raf = requestAnimationFrame(drawParticles);
      return;
    }

    const g = ctx.createRadialGradient(P.w*0.5, P.h*0.35, 0, P.w*0.5, P.h*0.45, Math.max(P.w,P.h)*0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.12)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,P.w,P.h);

    for (const p of P.parts){
      p.t += 0.006;
      p.x += p.vx + Math.cos(p.t)*0.03;
      p.y += p.vy + Math.sin(p.t)*0.03;
      if (p.x < -10) p.x = P.w + 10;
      if (p.x > P.w + 10) p.x = -10;
      if (p.y < -10) p.y = P.h + 10;
      if (p.y > P.h + 10) p.y = -10;

      const mix = (Math.sin(p.t)+1)/2;
      const r = Math.round(P.c1[0]*(1-mix) + P.c2[0]*mix);
      const g2 = Math.round(P.c1[1]*(1-mix) + P.c2[1]*mix);
      const b = Math.round(P.c1[2]*(1-mix) + P.c2[2]*mix);
      ctx.fillStyle = `rgba(${r},${g2},${b},${p.a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }

    P.raf = requestAnimationFrame(drawParticles);
  }
  function startParticles(){
    if (P.running) return;
    P.ctx = el.canvas.getContext("2d", { alpha: true });
    resizeCanvas();
    syncParticleColours();
    makeParts();
    P.running = true;
    cancelAnimationFrame(P.raf);
    P.raf = requestAnimationFrame(drawParticles);
  }
  function stopParticles(){
    P.running = false;
    cancelAnimationFrame(P.raf);
    P.raf = 0;
    if (P.ctx) P.ctx.clearRect(0,0,P.w,P.h);
  }
  function setMotion(on){
    state.motionOn = !!on;
    document.body.dataset.motion = state.motionOn ? "on" : "off";
    if (el.fxBtn) el.fxBtn.dataset.active = state.motionOn ? "true" : "false";
    if (el.fxBtn) el.fxBtn.setAttribute("aria-pressed", state.motionOn ? "true" : "false");
    if (el.fxBtn) el.fxBtn.title = state.motionOn ? "Animations: ON (auto theme shuffle active)" : "Animations: OFF";

    setPanelTranslucency(state.motionOn);

    const bgmode = (document.body.dataset.bgmode || "static").toLowerCase();
    const wantsBgFx = (bgmode !== "static"); // background motion can run even if UI animations are off

    if (state.motionOn){
      startParticles();
      startThemeAutoShuffle();
    } else {
      // Keep subtle background motion for non-static modes (Lite: movement without UI chaos)
      if (wantsBgFx) startParticles(); else stopParticles();
      stopThemeAutoShuffle();
    }

    // Re-apply theme so panel translucency matches the motion state
    applyTheme({ animate:false, user:false });
  }

// --- Utilities: theme auto-shuffle (tied to motion) ---
let __themeShuffleTO = null;
let __themeShuffleIV = null;
const THEME_SHUFFLE_FIRST_MS = 45000; // 2 min after enabling motion
const THEME_SHUFFLE_EVERY_MS = 45000; // every 3 min thereafter

function stopThemeAutoShuffle(){
  if(__themeShuffleTO){ clearTimeout(__themeShuffleTO); __themeShuffleTO = null; }
  if(__themeShuffleIV){ clearInterval(__themeShuffleIV); __themeShuffleIV = null; }
}

function startThemeAutoShuffle(){
  stopThemeAutoShuffle();
  __themeShuffleTO = setTimeout(()=>{
    pickRandomTheme({ animate:true, user:false });
    __themeShuffleIV = setInterval(()=> pickRandomTheme({ animate:true, user:false }), THEME_SHUFFLE_EVERY_MS);
  }, THEME_SHUFFLE_FIRST_MS);
}

function touchThemeShuffleTimer(){
  // reset schedule so it doesn't swap right after a manual change
  if(state.motionOn) startThemeAutoShuffle();
}

function pickRandomTheme(opts={}){
  const animate = (opts.animate != null) ? !!opts.animate : !!state.motionOn;
  const user = (opts.user !== false);

  const modes = ["sol","lunar"];
  let mode = state.themeMode;
  let idx = state.themeIndex;

  for(let t=0; t<12; t++){
    const m = modes[Math.floor(Math.random()*modes.length)];
    const i = Math.floor(Math.random()*THEMES[m].length);
    if(m !== state.themeMode || i !== state.themeIndex){
      mode = m; idx = i;
      break;
    }
  }

  state.themeMode = mode;
  state.themeIndex = idx;
  applyTheme({ animate, user });
  persistSave(true);
}

function setPanelTranslucency(on){
  const root = document.documentElement.style;
  root.setProperty("--panelBlur", on ? "7px" : "10px");
  root.setProperty("--panelHeaderA", on ? "rgba(0,0,0,.12)" : "rgba(0,0,0,.18)");
  root.setProperty("--panelHeaderB", on ? "rgba(0,0,0,.03)" : "rgba(0,0,0,.06)");
}


  // Minimal render scheduler (prevents spam)
  let _rAF = 0;
  function scheduleRender(){
    if (_rAF) return;
    _rAF = requestAnimationFrame(() => {
      _rAF = 0;
      try {
        render();
        try { MF_updateComposeCount(); } catch(_e){}
      } catch (err) {
        console.error("[MF Lite] render() crashed", err);
        state.__lastRenderError = {
          at: Date.now(),
          name: err && err.name,
          message: err && err.message,
          stack: err && err.stack
        };
        // Attempt to surface in CX debug strip without bricking UI
        try { updateCxDebug(); } catch(e) {}
      }
    });
  }

  // Pulse helper for SKY indicators
  function pulseSky(){
    const box = document.querySelector(".swatches");
    if (!box) return;
    box.classList.remove("pulse");
    void box.offsetWidth;
    box.classList.add("pulse");
    setTimeout(() => box.classList.remove("pulse"), 650);
  }


// Utilities: fidget / widget feedback (force animation on every click)
function fidget(elm, cls){
  if(!elm) return;
  elm.classList.remove(cls);
  // force reflow so re-adding triggers animation
  void elm.offsetWidth;
  elm.classList.add(cls);
  // cleanup so next click always retriggers
  window.clearTimeout(elm.__mfFidgetTO);
  elm.__mfFidgetTO = window.setTimeout(()=> elm.classList.remove(cls), 700);
}

// Utilities: shuffle within a specific mode (SOL/LUNAR also changes sky theme)
function pickRandomThemeInMode(mode, opts={}){
  const animate = (opts.animate != null) ? !!opts.animate : !!state.motionOn;
  const user = (opts.user !== false);

  const list = (THEMES && THEMES[mode]) ? THEMES[mode] : [];
  if(!list.length) return;

  let idx = state.themeIndex|0;

  if(mode !== state.themeMode){
    idx = Math.floor(Math.random()*list.length);
  } else {
    // try to pick a different index within the same mode
    for(let t=0; t<12; t++){
      const next = Math.floor(Math.random()*list.length);
      if(next !== (state.themeIndex|0)){ idx = next; break; }
    }
  }

  state.themeMode = mode;
  state.themeIndex = idx;
  applyTheme({ animate, user });
  persistSave(true);
}


    // Track active composer for previews
  el.customerMsg.addEventListener("focus", () => { state.lastEdited = "customer"; scheduleRender(); });
  el.agentDraft.addEventListener("focus", () => { state.lastEdited = "agent"; scheduleRender(); });


  // CX Insights mode switching (accessible tabs)
  function setCxMode(mode){
    const next = String(mode || "writer").toLowerCase().trim();
    state.cxMode = next;

    // Update the panel attribute (CSS-driven visibility depends on this)
    if (el.insightsPanel) el.insightsPanel.dataset.cxmode = next;
    // D-4I: show/hide header actions by tab (UK/US + Jargon)
    try{
      const showUkus = (next === "ukus");
      const a = document.getElementById("btnUkusApplyAll");
      const p = document.getElementById("btnUkusJumpPrev");
      const n = document.getElementById("btnUkusJumpNext");
      if (a) a.style.display = showUkus ? "" : "none";
      if (p) p.style.display = showUkus ? "" : "none";
      if (n) n.style.display = showUkus ? "" : "none";

      const showJargon = (next === "jargon");
      const jp = document.getElementById("btnJargonJumpPrev");
      const jn = document.getElementById("btnJargonJumpNext");
      if (jp) jp.style.display = showJargon ? "" : "none";
      if (jn) jn.style.display = showJargon ? "" : "none";
    }catch(e){}


    // Scope queries to the CX Insights panel to avoid side effects
    const root = el.insightsPanel || document;
    const btns = Array.from(root.querySelectorAll('.modebtn[data-cxmode]'));
    const panels = Array.from(root.querySelectorAll('.card[data-cx]'));

    btns.forEach(b=>{
      const isActive = String(b.dataset.cxmode || "").toLowerCase() === next;
      b.dataset.active = isActive ? "true" : "false";
      b.classList.toggle("is-active", isActive);
      b.setAttribute("aria-selected", isActive ? "true" : "false");
      b.tabIndex = isActive ? 0 : -1;
    });

    // Belt + suspenders:
    // - CSS shows the matching card via data-cxmode on the panel
    // - JS also forces the correct card to be display:block so we don't depend on CSS in future forks
    panels.forEach(p=>{
      const cx = String(p.dataset.cx || "").toLowerCase();
      const show = (cx === next);
      p.style.display = show ? "block" : "none";
      p.toggleAttribute("hidden", !show);
      p.setAttribute("aria-hidden", show ? "false" : "true");
    });

    updateCxDebug();
    scheduleRender();
  }

  // CX debug harness (mode + counts + card visibility + last render error)
  function updateCxDebug(){
    const box = document.getElementById("cxDebug");
    if (!box) return;

    const root = el.insightsPanel || document;
    const mode = String(state.cxMode || (el.insightsPanel && el.insightsPanel.dataset.cxmode) || "writer");

    const writer = (state.analysis && state.analysis.writer) ? state.analysis.writer : null;
    const eff = writer && Array.isArray(writer.matchesEffective) ? writer.matchesEffective : [];
    const ukusN = eff.filter(m => m && m.kind === "ukus").length;
    const jargonN = eff.filter(m => m && m.kind === "jargon").length;

    const cards = Array.from(root.querySelectorAll('.card[data-cx]')).map(c=>{
      const cx = c.dataset.cx;
      const ds = getComputedStyle(c).display;
      return `${cx}:${ds==="none" ? "off" : "on"}`;
    }).join("  ");

    const err = state.__lastRenderError;
    const errText = err ? `${err.name || "Error"}: ${(err.message || "").slice(0,120)}` : "";

    box.innerHTML = [
      `<span class="pill"><span class="k">mode</span><span class="v">${mode}</span></span>`,
      `<span class="pill"><span class="k">uk/us</span><span class="v">${ukusN}</span></span>`,
      `<span class="pill"><span class="k">jargon</span><span class="v">${jargonN}</span></span>`,
      `<span class="pill"><span class="k">cards</span><span class="v">${cards}</span></span>`,
      errText ? `<span class="pill err"><span class="k">render</span><span class="v">${String(errText).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span></span>` : ``
    ].filter(Boolean).join("");
  }



  // Wire mode buttons
  (function(){
    const btns = Array.from(document.querySelectorAll('.modebtn[data-cxmode]'));
    if (!btns.length) return;

    btns.forEach((b, i)=>{
      b.addEventListener("click", ()=> setCxMode(b.dataset.cxmode));
      b.addEventListener("keydown", (e)=>{
        const key = e.key;
        if (!["ArrowLeft","ArrowRight","Home","End"].includes(key)) return;
        e.preventDefault();
        let nextIndex = i;
        if (key==="ArrowLeft") nextIndex = (i-1+btns.length)%btns.length;
        if (key==="ArrowRight") nextIndex = (i+1)%btns.length;
        if (key==="Home") nextIndex = 0;
        if (key==="End") nextIndex = btns.length-1;
        btns[nextIndex].focus();
        setCxMode(btns[nextIndex].dataset.cxmode);
      });
    });

    // ensure initial state is writer unless already set
    const initial = state.cxMode || (el.insightsPanel && el.insightsPanel.dataset.cxmode) || "writer";
    setCxMode(initial);
  })();

  // D-4I: UK/US header controls (Apply all + jump next/prev)
  (function(){
    const applyBtn = document.getElementById("btnUkusApplyAll");
    const prevBtn  = document.getElementById("btnUkusJumpPrev");
    const nextBtn  = document.getElementById("btnUkusJumpNext");
    if (applyBtn) applyBtn.addEventListener("click", (e)=>{ e.preventDefault(); try{ applyAllUkus(); }catch(err){} });
    function jumpCard(dir){
      const list = document.querySelectorAll("#ukusList .insight-item.issue");
      if (!list || !list.length) return;
      if (typeof state.ukusJumpIndex !== "number") state.ukusJumpIndex = -1;
      const n = list.length;
      state.ukusJumpIndex = (state.ukusJumpIndex + (dir||1) + n) % n;
      const elCard = list[state.ukusJumpIndex];
      if (!elCard) return;
      try{ elCard.scrollIntoView({behavior:"smooth", block:"nearest"}); }catch(e){}
      elCard.classList.add("is-flash");
      setTimeout(()=>{ try{ elCard.classList.remove("is-flash"); }catch(e){} }, 650);
    }
    if (prevBtn) prevBtn.addEventListener("click", (e)=>{ e.preventDefault(); jumpCard(-1); });
    if (nextBtn) nextBtn.addEventListener("click", (e)=>{ e.preventDefault(); jumpCard(1); });
  })();




  // D-4J — Jargon header controls (jump next/prev; parity with UK/US)
  (function(){
    const prevBtn  = document.getElementById("btnJargonJumpPrev");
    const nextBtn  = document.getElementById("btnJargonJumpNext");

    function jumpCard(dir){
      const list = document.querySelectorAll("#jargonList .insight-item.issue");
      if (!list || !list.length) return;
      if (typeof state.jargonJumpIndex !== "number") state.jargonJumpIndex = -1;
      const n = list.length;
      state.jargonJumpIndex = (state.jargonJumpIndex + (dir||1) + n) % n;
      const elCard = list[state.jargonJumpIndex];
      if (!elCard) return;
      try{ elCard.scrollIntoView({behavior:"smooth", block:"nearest"}); }catch(e){}
      elCard.classList.add("is-flash");
      setTimeout(()=>{ try{ elCard.classList.remove("is-flash"); }catch(e){} }, 650);
    }

    if (prevBtn) prevBtn.addEventListener("click", (e)=>{ e.preventDefault(); jumpCard(-1); });
    if (nextBtn) nextBtn.addEventListener("click", (e)=>{ e.preventDefault(); jumpCard(1); });
  })();
// Events
  el.customerMsg.addEventListener("input", () => {
    state.lastEdited = "customer";
    state.drafts.customer = el.customerMsg.value;
    scheduleRender();
  });

let _histTimer = 0;
  el.agentDraft.addEventListener("input", () => {
    state.lastEdited = "agent";
    state.drafts.agent = el.agentDraft.value;
    clearTimeout(_histTimer);
    _histTimer = setTimeout(() => histPush(state.drafts.agent), 220);
    scheduleRender();
  });

  el.customerMsg.addEventListener("keydown", (e) => {
    if (e.ctrlKey && e.key === "Enter"){
      e.preventDefault();
      addCustomer();
      persistSave(true);
    }
  });

  el.agentDraft.addEventListener("keydown", (e) => {
    if (e.ctrlKey && e.key === "Enter"){
      e.preventDefault();
      sendAgent();
      persistSave(true);
    }
  });



  // D-4D — Inline flagging overlay: keep mirror layer in sync (Lite-safe)
  el.agentDraft.addEventListener("scroll", syncAgentDraftOverlayScroll);
  el.agentDraft.addEventListener("mouseup", () => requestAnimationFrame(() => draftFocusFromCaret(true)));
  el.agentDraft.addEventListener("keyup", (e) => {
    const k = e.key || "";
    if (k.startsWith("Arrow") || k === "Home" || k === "End") requestAnimationFrame(() => draftFocusFromCaret(false));
  });
  el.agentDraft.addEventListener("blur", () => hideDraftTip());

  // D-4E — Tooltip actions: Apply + Undo (Lite-safe)
  if (el.agentDraftTip) {
    el.agentDraftTip.addEventListener("mousedown", (e) => {
      // prevent textarea losing caret when clicking buttons
      const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
      if (b) { e.preventDefault(); e.stopPropagation(); }
    });

    el.agentDraftTip.addEventListener("click", (e) => {
      const btn = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
      if (!btn) return;
      e.preventDefault(); e.stopPropagation();
      const act = btn.getAttribute("data-act") || "";
      if (act === "apply") d4eApplyFocused();
      if (act === "undo") d4eUndo();
    });

    // Keep tip open while hovering it (so buttons are usable)
    el.agentDraftTip.addEventListener("mouseenter", () => {
      if (__d4dTipTimer) { clearTimeout(__d4dTipTimer); __d4dTipTimer = null; }
    });
    el.agentDraftTip.addEventListener("mouseleave", () => {
      if (el.agentDraftTip.dataset && el.agentDraftTip.dataset.show === "true") {
        if (__d4dTipTimer) clearTimeout(__d4dTipTimer);
        __d4dTipTimer = window.setTimeout(() => { hideDraftTip(); }, 2400);
      }
    });
  }

  el.addCustomerBtn.addEventListener("click", () => { addCustomer(); persistSave(true); });
  el.sendAgentBtn.addEventListener("click", () => { sendAgent(); persistSave(true); });
  el.phoneSendBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Phone send dot is reserved for the rolling tip ticker (no message commit here)
    if (window.__MF_TIP_NUDGE) window.__MF_TIP_NUDGE();
  });

  el.clearBtn.addEventListener("click", clearAll);
el.checkerBtn.addEventListener("click", () => {
    state.checkerOn = !state.checkerOn;
    el.checkerBtn.dataset.active = state.checkerOn ? "true" : "false";
    scheduleRender();
    persistSave(true);
  });

  el.pasteBtn.addEventListener("click", doPaste);
  el.copyBtn.addEventListener("click", doCopy);

  el.modeSol.addEventListener("click", () => {
    pickRandomThemeInMode("sol", { animate: state.motionOn, user:true });
    fidget(el.modeSol, "mf-fidget-pulse");
    pulseSky();
  });
el.modeLunar.addEventListener("click", () => {
    pickRandomThemeInMode("lunar", { animate: state.motionOn, user:true });
    fidget(el.modeLunar, "mf-fidget-pulse");
    pulseSky();
  });
el.sw.forEach((btn, i) => {
    btn.addEventListener("click", () => {
      state.themeIndex = i;
      applyTheme();
    try{ mfApplyBgPreset(state.themeMode); }catch(e){}
      pulseSky();
      persistSave(true);
    });
  });

  el.diceBtn.addEventListener("click", () => {
    fidget(el.diceBtn, "mf-fidget-wobble");
    pickRandomTheme({ animate: state.motionOn, user:true });
    pulseSky();
  });
el.fxBtn.addEventListener("click", () => {
    fidget(el.fxBtn, "mf-fidget-pulse");
    setMotion(!state.motionOn);
    persistSave(true);
  });
el.ts.forEach((b) => {
    b.addEventListener("click", () => {
      state.textSize = Number(b.dataset.size || 1);
      applyTextSize();
      persistSave(true);
    });
  });

  // Focus controls
  el.focusPhoneBtn.addEventListener("click", () => setFocus("phone"));
  el.focusEditorBtn.addEventListener("click", () => setFocus("editor"));
  el.exitFocusBtnPhone.addEventListener("click", () => setFocus("none"));
  el.exitFocusBtnDraft.addEventListener("click", () => setFocus("none"));

  if (el.previewToggle){
    el.previewToggle.addEventListener("click", () => {
      state.previewOn = !state.previewOn;
      render();
    });
  }


  if (el.glassToggle){
    el.glassToggle.addEventListener("click", () => {
      state.glassMode = (state.glassMode === "clear") ? "frosted" : "clear";
      render();
    });
  }


  // Enable ChatFlow drag-reorder
  bindChatflowDnD();

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") setFocus("none");
  });

  // Toolbar actions (lightweight)
  const getActiveTA = () => (state.lastEdited === "customer" ? el.customerMsg : el.agentDraft);
  const syncDraftFromTA = (ta) => {
    if (ta === el.customerMsg) state.drafts.customer = ta.value;
    else state.drafts.agent = ta.value;
  };


const adjustIndent = (ta, dir) => {
  const v = ta.value || "";
  let s = ta.selectionStart ?? 0;
  let e = ta.selectionEnd ?? 0;
  if (s > e){ const tmp = s; s = e; e = tmp; }

  // Expand selection to full lines
  const lineStart = v.lastIndexOf("\n", Math.max(0, s - 1)) + 1;
  let lineEnd = v.indexOf("\n", e);
  if (lineEnd === -1) lineEnd = v.length;

  const block = v.slice(lineStart, lineEnd);
  const lines = block.split("\n");

  let removedFirst = 0;
  let removedTotal = 0;

  const nextLines = lines.map((ln, idx) => {
    if (dir > 0){
      // indent
      removedTotal += 0;
      return "  " + ln;
    } else {
      // outdent: remove up to 2 leading spaces or a leading tab
      const m = ln.match(/^(\t| {1,2})/);
      const rem = m ? m[0].length : 0;
      if (idx === 0) removedFirst = rem;
      removedTotal += rem;
      return rem ? ln.slice(rem) : ln;
    }
  });

  const nextBlock = nextLines.join("\n");
  ta.value = v.slice(0, lineStart) + nextBlock + v.slice(lineEnd);

  // Restore selection (best-effort)
  if (dir > 0){
    const lineCount = lines.length;
    const addTotal = 2 * lineCount;
    const addFirst = 2;
    ta.selectionStart = Math.min(ta.value.length, s + addFirst);
    ta.selectionEnd   = Math.min(ta.value.length, e + addTotal);
  } else {
    ta.selectionStart = Math.max(0, s - removedFirst);
    ta.selectionEnd   = Math.max(0, e - removedTotal);
  }
};


  // Ensure toolbar targets the last edited box
  ["focus","click","input"].forEach(evt => {
    el.customerMsg.addEventListener(evt, () => { state.lastEdited = "customer"; });
    el.agentDraft.addEventListener(evt, () => { state.lastEdited = "agent"; });
  });

  el.btnBold.addEventListener("click", () => {
    const ta = getActiveTA();
    wrapSelection(ta, "**", "**");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });

  el.btnItalic.addEventListener("click", () => {
    const ta = getActiveTA();
    wrapSelection(ta, "*", "*");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });


el.btnUnderline?.addEventListener("click", () => {
  const ta = getActiveTA();
  wrapSelection(ta, "__", "__");
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnStrike?.addEventListener("click", () => {
  const ta = getActiveTA();
  wrapSelection(ta, "~~", "~~");
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnCode?.addEventListener("click", () => {
  const ta = getActiveTA();
  wrapSelection(ta, "`", "`");
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnQuote?.addEventListener("click", () => {
  const ta = getActiveTA();
  addListPrefix(ta, "quote");
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnChecklist?.addEventListener("click", () => {
  const ta = getActiveTA();
  addListPrefix(ta, "check");
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnLink?.addEventListener("click", () => {
  const ta = getActiveTA();
  insertMarkdownLink(ta);
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

  el.btnBullets.addEventListener("click", () => {
    const ta = getActiveTA();
    addListPrefix(ta, "bullets");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });


el.btnIndent?.addEventListener("click", () => {
  const ta = getActiveTA();
  adjustIndent(ta, +1);
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});

el.btnOutdent?.addEventListener("click", () => {
  const ta = getActiveTA();
  adjustIndent(ta, -1);
  syncDraftFromTA(ta);
  if (ta === el.agentDraft) histPush(state.drafts.agent);
  scheduleRender();
});


  el.btnUndo.addEventListener("click", () => {
    // Undo only tracks the agent draft history for now (safest)
    histUndo();
  });

  el.btnRedo.addEventListener("click", () => {
    histRedo();
  });

  // Extra tools
  el.btnHighlight?.addEventListener("click", () => {
    const ta = getActiveTA();
    wrapSelection(ta, "==", "==");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });

  el.btnClearFmt?.addEventListener("click", () => {
    const ta = getActiveTA();
    // Minimal "clear formatting": remove markdown wrappers we add and normalise whitespace
    ta.value = ta.value
      .replace(/\*\*(.*?)\*\*/g, "$1")
      .replace(/\*(.*?)\*/g, "$1")
      .replace(/==(.*?)==/g, "$1")
      .replace(/__(.*?)__/g, "$1")
      .replace(/~~(.*?)~~/g, "$1")
      .replace(/`([^`]+)`/g, "$1")
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1")
      .replace(/^\s*>\s?/gm, "")
      .replace(/^\s*-\s*\[\s\]\s+/gm, "- ");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
    toast("Cleared formatting");
  });

  el.btnRule?.addEventListener("click", () => {
    const ta = getActiveTA();
    insertAtCursor(ta, "\n---\n");
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });

  el.btnPasteTop?.addEventListener("click", async () => {
    const ta = getActiveTA();
    try {
      const txt = await navigator.clipboard.readText();
      insertAtCursor(ta, txt);
      syncDraftFromTA(ta);
      if (ta === el.agentDraft) histPush(state.drafts.agent);
      scheduleRender();
      toast("Pasted");
    } catch {
      toast("Paste blocked");
    }
  });

  el.btnCopyTop?.addEventListener("click", async () => {
    const ta = getActiveTA();
    try {
      await navigator.clipboard.writeText(ta.value || "");
      toast("Copied");
    } catch {
      toast("Copy blocked");
    }
  });

  el.btnClearTop?.addEventListener("click", () => {
    const ta = getActiveTA();
    ta.value = "";
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
  });

  el.btnClean.addEventListener("click", () => {
    const ta = getActiveTA();
    const cleaned = normaliseWhitespace(ta.value);
    ta.value = cleaned;
    syncDraftFromTA(ta);
    if (ta === el.agentDraft) histPush(state.drafts.agent);
    scheduleRender();
    toast("Cleaned");
  });


  el.btnReplies.addEventListener("click", () => {
    openComposeMenu(el.btnReplies, QUICK_REPLIES, (t) => {
      insertAtCursor(el.agentDraft, t);
      state.drafts.agent = el.agentDraft.value;
      histPush(state.drafts.agent);
      scheduleRender();
    });
  });
  el.btnPhrases.addEventListener("click", () => {
    openMenu(el.btnPhrases, QUICK_PHRASES, (t) => {
      insertAtCursor(el.agentDraft, t);
      state.drafts.agent = el.agentDraft.value;
      histPush(state.drafts.agent);
      scheduleRender();
    });
  });

  // Compose (CX tab) controls
  if (el.composeKeepToggle){
    el.composeKeepToggle.addEventListener("click", () => {
      if (!state.composeTray) state.composeTray = { blocks: [], keepAfterCommit: false };
      state.composeTray.keepAfterCommit = !state.composeTray.keepAfterCommit;

      try{
        if (el.composeKeepState) el.composeKeepState.textContent = state.composeTray.keepAfterCommit ? "ON" : "OFF";
        el.composeKeepToggle.setAttribute("aria-pressed", state.composeTray.keepAfterCommit ? "true" : "false");
      }catch(_e){}

      if ((state.cxMode || "") === "compose"){
        try{ setComposePanel(el.composePanelMount); }catch(e){}
      }
      toast(state.composeTray.keepAfterCommit ? "Keep after commit: ON" : "Keep after commit: OFF", false);
    });
  }

// Resize handlers for particles
  window.addEventListener("resize", () => {
    resizeCanvas();
    makeParts();
    updatePhoneScale();
    try { syncDraftOverlayMetrics(); } catch(_e){}
    try { positionDraftTipToSeg(state.__draftFocusSeg); } catch(_e){}
  });

  // === Toolbar Pocket (2-row cap, pinned optional tools) ===
  const TOOL_PINS_KEY = "mf_toolbar_pins_v2";
  const TOOL_DEFAULT_PINS = []; // off by default (Strike/Quote available via tool pocket) // light defaults; user can change

  const TOOL_META = [
    { id:"btnStrike", label:"Strikethrough", ico:"S" },
    { id:"btnQuote", label:"Quote", ico:"❝" },
    { id:"btnChecklist", label:"Checklist", ico:"☐" },
    { id:"btnCode", label:"Inline code", ico:"</>" },
    { id:"btnLink", label:"Link", ico:"🔗" },
    { id:"btnIndent", label:"Indent", ico:"⇥" },
    { id:"btnOutdent", label:"Outdent", ico:"⇤" },
    { id:"btnUndo", label:"Undo", ico:"↺" },
    { id:"btnRedo", label:"Redo", ico:"↻" },
  ];

  function loadPins(){
    try{
      const raw = localStorage.getItem(TOOL_PINS_KEY);
      const arr = raw ? JSON.parse(raw) : null;
      return Array.isArray(arr) ? arr.filter(Boolean) : [...TOOL_DEFAULT_PINS];
    }catch(_){
      return [...TOOL_DEFAULT_PINS];
    }
  }
  function savePins(pins){
    try{ localStorage.setItem(TOOL_PINS_KEY, JSON.stringify(pins)); }catch(_){}
  }

  function initToolbarPocket(){
    const btnPocket = document.getElementById("btnToolPocket");
    const pocket = document.getElementById("toolPocket");
    const grid = document.getElementById("toolPocketGrid");
    const slot = document.getElementById("pinnedToolsSlot");
    const bin  = document.getElementById("toolBin");
    const btnDone = document.getElementById("btnPocketDone");
    const btnReset = document.getElementById("btnPocketReset");
    if(!btnPocket || !pocket || !grid || !slot || !bin) return;

    let pins = loadPins();

    const isPinned = (id)=> pins.includes(id);

    const renderPins = ()=>{
      // move all optional tools back to bin first
      TOOL_META.forEach(t=>{
        const elTool = document.getElementById(t.id);
        if(elTool && elTool.parentElement !== bin && !isPinned(t.id)){
          bin.appendChild(elTool);
        }
      });
      // then append pinned in order
      pins.forEach(id=>{
        const elTool = document.getElementById(id);
        if(elTool) slot.appendChild(elTool);
      });
    };

    const renderPocket = ()=>{
      grid.innerHTML = "";
      TOOL_META.forEach(t=>{
        const row = document.createElement("div");
        row.className = "toolToggle";
        row.innerHTML = `
          <div class="left">
            <div class="ico">${t.ico}</div>
            <div class="lbl" title="${t.label}">${t.label}</div>
          </div>
          <input type="checkbox" ${isPinned(t.id) ? "checked" : ""} aria-label="Pin ${t.label}">
        `;
        const cb = row.querySelector("input");
        cb.addEventListener("change", ()=>{
          if(cb.checked){
            if(!pins.includes(t.id)) pins.push(t.id);
          }else{
            pins = pins.filter(x=>x!==t.id);
          }
          savePins(pins);
          renderPins();
          renderPocket();
        });
        grid.appendChild(row);
      });
    };

    const closePocket = ()=>{ pocket.hidden = true; btnPocket.dataset.active = "false"; };
    const openPocket = ()=>{ pocket.hidden = false; btnPocket.dataset.active = "true"; };

    btnPocket.addEventListener("click", ()=>{
      if(pocket.hidden) openPocket(); else closePocket();
    });
    btnDone?.addEventListener("click", closePocket);
    btnReset?.addEventListener("click", ()=>{
      pins = [...TOOL_DEFAULT_PINS];
      savePins(pins);
      renderPins();
      renderPocket();
    });

    // close if user clicks outside pocket
    document.addEventListener("mousedown", (e)=>{
      if(pocket.hidden) return;
      if(pocket.contains(e.target) || btnPocket.contains(e.target)) return;
      closePocket();
    });

    renderPins();
    renderPocket();
  }

// Init
  function init(){
    persistLoad();
    try{ ignoreRulesLoad(); }catch(e){}
    try{ hiddenIssuesLoad(); }catch(e){}


    // Defaults safety
    if (typeof state.motionOn !== "boolean") state.motionOn = false;
    state.checkerOn = state.checkerOn !== false;
    state.themeMode = (state.themeMode === "lunar") ? "lunar" : "sol";
    state.themeIndex = Math.max(0, Math.min(3, state.themeIndex|0));
    state.textSize = Math.max(0, Math.min(3, state.textSize|0));

    el.customerMsg.value = state.drafts.customer || "";
    el.agentDraft.value = state.drafts.agent || "";

    // History seed
    hist.stack = [el.agentDraft.value || ""];
    hist.idx = 0;

    applyTheme();
    applyTextSize();
      updatePhoneScale();
setMotion(state.motionOn);
    el.checkerBtn.dataset.active = state.checkerOn ? "true" : "false";

    // Mark current theme swatch active correctly
    el.sw.forEach((btn, i) => btn.dataset.active = (i === state.themeIndex) ? "true" : "false");

    el.timeNow.textContent = nowHM();
    applyInputPlaceholders(state.messages.length ? "default" : "initial");
    setupAgentTips();
    initToolbarPocket();
    render();
    setInterval(() => { el.timeNow.textContent = nowHM(); }, 15000);
  }

  try{
    init();
  }catch(e){
    // Boot should never brick the UI. Log + store for DevLab/debug, but do not surface banners in the UI.
    console.error("[MF Lite] init() failed", e);
    try{
      state.__bootError = {
        at: Date.now(),
        name: e && e.name,
        message: e && e.message,
        stack: e && e.stack
      };
    }catch(_){}
  }
})();

</script>
<!-- // UI LAYER START -->
<style id="mf-ui-layer-css">
  /* === MirrorFlow UI-Layer Seal (UI-only fork)
     - Never touch engine logic.
     - Visual polish + interaction safety only.
  */

  :root{
    /* Lighter glass (never opaque) */
    --ui-glass-1: rgba(255,255,255,.055);
    --ui-glass-2: rgba(255,255,255,.035);
    --ui-stroke-1: rgba(255,255,255,.11);
    --ui-stroke-2: rgba(255,255,255,.16);
    --ui-press: rgba(255,255,255,.10);
    --ui-hover: rgba(255,255,255,.08);
    --ui-focus: 0 0 0 3px rgba(122,180,255,.18);
  }

  /* Layer depth: gently lift panels without changing layout */
  .panel{
    background: linear-gradient(180deg, var(--ui-glass-1), var(--ui-glass-2)) !important;
    border: 1px solid var(--ui-stroke-1) !important;
    box-shadow:
      0 24px 60px rgba(0,0,0,.22),
      0 1px 0 rgba(255,255,255,.06) inset;
  }
  .panel .panel-header{
    border-bottom: 1px solid rgba(255,255,255,.08) !important;
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)) !important;
  }

  /* Buttons: stable hover/focus/pressed */
  button, .btn, .pillbtn, .chipbtn{
    transition: transform .08s ease, background-color .12s ease, border-color .12s ease, box-shadow .12s ease, opacity .12s ease;
  }
  button:focus-visible, .btn:focus-visible, .pillbtn:focus-visible, .chipbtn:focus-visible{
    outline: none !important;
    box-shadow: var(--ui-focus) !important;
  }
  button:active, .btn:active, .pillbtn:active, .chipbtn:active{
    transform: translateY(1px);
  }

  /* Inputs: consistent focus ring */
  textarea:focus-visible, [contenteditable="true"]:focus-visible{
    outline: none !important;
    box-shadow: var(--ui-focus) !important;
    border-color: rgba(122,180,255,.35) !important;
  }

  /* Phone: keep device centred; never overflow its column */
  [data-panel="phone"], [data-panel="phone"] *{ min-width:0; }
  .phone-panel-body{ overflow:hidden !important; }
  .phone-wrap{
    max-width: 100% !important;
    width: calc(380px * var(--phone-scale, 1)) !important;
    height: calc(760px * var(--phone-scale, 1)) !important;
    margin: 0 auto !important;
  }

  /* Hide UI-seal badge */
  .mf-ui-seal-badge{ display:none !important; }

  /* Scrollbars: subtle + modern */
  *{ scrollbar-width: thin; scrollbar-color: rgba(255,255,255,.18) rgba(255,255,255,.05); }
  *::-webkit-scrollbar{ width: 10px; height: 10px; }
  *::-webkit-scrollbar-track{ background: rgba(255,255,255,.04); border-radius: 999px; }
  *::-webkit-scrollbar-thumb{ background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.10)); border: 2px solid rgba(0,0,0,.18); border-radius: 999px; }
  *::-webkit-scrollbar-thumb:hover{ background: linear-gradient(180deg, rgba(255,255,255,.30), rgba(255,255,255,.14)); }

  /* Rolling tips (visual only): reduce risk of motion fatigue; motion off by default */
  body[data-motion="off"] .tipline, body[data-motion="off"] #agentTipTicker{
    animation: none !important;
  }

  /* UI safety: if engine stalls/missing snapshot, show a tiny badge */
  .mf-ui-seal-badge{
    position: fixed;
    left: 14px;
    bottom: 14px;
    z-index: 9998;
    padding: 6px 10px;
    border-radius: 999px;
    font: 12px/1.1 var(--font);
    color: rgba(255,255,255,.78);
    background: rgba(0,0,0,.28);
    border: 1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(10px) saturate(1.15);
    -webkit-backdrop-filter: blur(10px) saturate(1.15);
    pointer-events: none;
    user-select: none;
  }
  .mf-ui-seal-badge strong{ color: rgba(255,255,255,.92); font-weight: 650; }


  /* ================================
     UI TIGHTENING — DRAFT TOOLBARS (v3)
     Purely visual: reduces vertical spacing + button density.
     ================================ */
  .panel[data-panel="draft"] .hint{ margin-top: 6px !important; margin-bottom: 8px !important; }

  .panel[data-panel="draft"] .classic-toolbar{
    gap: 6px !important;
    padding: 6px 8px !important;
    margin-top: 8px !important;
    margin-bottom: 8px !important;
    border-radius: 14px !important;
  }

  /* First row (formatbar) a touch tighter */
  .panel[data-panel="draft"] .classic-toolbar[role="toolbar"]{
    margin-top: 6px !important;
    margin-bottom: 6px !important;
  }

  /* Second row (quick inserts) tuck closer */
  .panel[data-panel="draft"] .classic-toolbar.insertbar{
    margin-top: 6px !important;
    margin-bottom: 10px !important;
  }

  /* Pill buttons: slimmer */
  .panel[data-panel="draft"] .classic-toolbar .pillbtn{
    height: 23px !important;
    min-height: 23px !important;
    padding: 0 8px !important;
    font-size: 11px !important;
    border-radius: 999px !important;
    letter-spacing: .15px !important;
  }

  /* Icon-only buttons: compact squares */
  .panel[data-panel="draft"] .classic-toolbar .pillbtn.icononly{
    width: 24px !important;
    min-width: 24px !important;
    height: 23px !important;
    padding: 0 !important;
    border-radius: 8px !important;
    font-size: 12px !important;
  }

  /* Caret a bit smaller so pills don't look tall */
  .panel[data-panel="draft"] .classic-toolbar .caret{
    font-size: 10px !important;
    opacity: .9 !important;
    margin-left: 5px !important;
  }

  /* Reduce “double glow” to feel more pro */
  .panel[data-panel="draft"] .classic-toolbar .pillbtn{
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) !important;
  }
  .panel[data-panel="draft"] .classic-toolbar .pillbtn:hover{
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.14) !important;
  }



  /* ================================
     UI RHYTHM + REORDER (v4)
     - Tighten vertical spacing between Customer → Toolbars → Agent
     - Swap Insertbar (Clean/Replies/Phrases) ABOVE Format toolbar
     - Pure CSS: no DOM edits, no engine touches
     ================================ */

  
  /* When quick inserts are merged into the format toolbar */
  .panel[data-panel="draft"] .classic-toolbar[role="toolbar"]{
    flex-wrap: wrap !important;
    gap: 6px !important;
  }
  .mf-toolbar-spacer{
    display:inline-block;
    width: 10px;
    height: 1px;
    opacity: .0;
  }
/* Normalize stack spacing (single rhythm unit) */
  .panel[data-panel="draft"] .stack{
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
  }

  /* Reduce extra vertical padding that creates uneven spacing */
  .panel[data-panel="draft"] label{ margin-bottom: 6px !important; }
  .panel[data-panel="draft"] .hint{
    margin-top: 6px !important;
    margin-bottom: 2px !important;
  }

  /* Toolbars: unify spacing and make them feel like one block */
  .panel[data-panel="draft"] .classic-toolbar{
    margin: 0 !important;
  }

  /* Draft stack ordering (set by UI-layer JS to avoid brittle nth-of-type selectors)
     Desired order:
     1) Customer message
     2) Writer toolbar (Replies/Phrases/Clean/Paste/Copy/Clear + formatting)
     3) Agent draft
     4) Dock (metrics/check)
     5) Utilities (pinned bottom)
  */
  .panel[data-panel="draft"] .stack{ display:flex !important; flex-direction:column !important; }
  .panel[data-panel="draft"] .stack > .utilitiesHub{ margin-top: auto !important; }

  /* Micro-tighten: slightly smaller gap between insertbar + formatbar */
  .panel[data-panel="draft"] .classic-toolbar.insertbar{ margin-bottom: 6px !important; }
  .panel[data-panel="draft"] .classic-toolbar[role="toolbar"]{ margin-top: 0 !important; }

/* Writer toolbar layout: left-aligned, consistent spacing, no weird gaps */
.panel[data-panel="draft"] .classic-toolbar[role="toolbar"]{
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: flex-start !important;
  align-items: center !important;
  gap: 8px !important;
}
.panel[data-panel="draft"] .classic-toolbar[role="toolbar"] > *{
  flex: 0 0 auto !important;
}
.mf-toolbar-spacer{
  width: 8px !important;
  height: 1px !important;
  display: inline-block !important;
  flex: 0 0 8px !important;
}

/* Toolbar dividers + grouping (UI-only) */
.mf-toolbar-divider{
  width: 1px !important;
  height: 18px !important;
  background: rgba(255,255,255,.14) !important;
  border-radius: 1px !important;
  margin: 0 4px !important;
  align-self: center !important;
  flex: 0 0 1px !important;
  opacity: .9 !important;
}


.mf-toolbar-break{
  flex: 0 0 100% !important;
  width: 100% !important;
  height: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
}
.panel[data-panel="draft"] #btnHighlight,
.panel[data-panel="draft"] #btnCode,
.panel[data-panel="draft"] #btnRule{ display:none !important; }
/* Dock becomes a mini-insights + quick inserts row */
.panel[data-panel="draft"] .dock-left{
  display:flex !important;
  flex-wrap: nowrap !important;
  align-items: center !important;
  gap: 6px !important;
  min-width: 0 !important;
  overflow-x: auto !important;
  overflow-y: hidden !important;
  scrollbar-width: none !important;

}
.panel[data-panel="draft"] .dock-left::-webkit-scrollbar{ height: 0px; width: 0px; }
.panel[data-panel="draft"] .dock{
  flex-wrap: nowrap !important;
}
.panel[data-panel="draft"] .dock-left .mini{
  height: 21px !important;
  min-height: 21px !important;
  padding: 0 8px !important;
  font-size: 11px !important;
  border-radius: 999px !important;
  display: inline-flex !important;
  align-items: center !important;
  gap: 6px !important;
  line-height: 1 !important;
}

.panel[data-panel="draft"] .dock-left .pillbtn{
  height: 21px !important;
  min-height: 21px !important;
  padding: 0 8px !important;
  font-size: 11px !important;
}
.panel[data-panel="draft"] .dock-right:empty{
  display:none !important;
}

/* Checker pill lives in Utilities bar now */
.panel[data-panel="draft"] .utilities-bar #checkerBtn{
  height: 21px !important;
  min-height: 21px !important;
  padding: 0 9px !important;
  font-size: 11px !important;
  border-radius: 999px !important;
  margin-left: 6px !important;
  margin-right: 8px !important;
  white-space: nowrap !important;
}






/* =========================================
   Toolbar Alignment Fix (MirrorFlow Editor)
   - Removes the “mystery left gutter” that shifts REPLIES/PHRASES/Clean.
   - Root cause: .classic-toolbar::before/::after are flex items (16px) that push content right.
   - Fix: make edge fades overlays (absolute) + align padding with textarea left padding (12px).
   ========================================= */
.panel[data-panel="draft"] .classic-toolbar{
  padding-left: 12px !important;
  padding-right: 12px !important;
}
.panel[data-panel="draft"] .classic-toolbar::before,
.panel[data-panel="draft"] .classic-toolbar::after{
  position: absolute !important;
  top: 0 !important;
  bottom: 0 !important;
  width: 10px !important; /* keep a subtle edge fade without affecting layout */
  height: auto !important;
  pointer-events: none !important;
  flex: none !important;
}
.panel[data-panel="draft"] .classic-toolbar::before{ left: 0 !important; }
.panel[data-panel="draft"] .classic-toolbar::after{ right: 0 !important; }



/* =========================================
   Phone Frame V2 (MirrorFlow Viewer)
   - Solid, glossy bezel + slimmer halo
   - Keeps canon size + rolling tips + layout
   ========================================= */
.phone-wrap::before{
  inset: -10px !important;
  border-radius: 60px !important;
  background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(0,0,0,.50)) !important;
  border: 1px solid rgba(255,255,255,.12) !important;
  box-shadow:
    0 26px 90px rgba(0,0,0,.62),
    0 10px 30px rgba(0,0,0,.34),
    inset 0 0 0 1px rgba(0,0,0,.65),
    inset 0 0 0 1px rgba(255,255,255,.10),
    inset 0 14px 26px rgba(255,255,255,.04),
    inset 0 -24px 44px rgba(0,0,0,.55) !important;
  opacity: .98 !important;
  filter: saturate(1.05) !important;
}
.phone-wrap::after{
  inset: -2px !important;
  border-radius: 52px !important;
  background:
    linear-gradient(120deg, rgba(255,255,255,.12), transparent 55%),
    radial-gradient(520px 420px at 30% 18%, rgba(255,255,255,.06), transparent 60%) !important;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.08),
    inset 0 -22px 45px rgba(0,0,0,.42) !important;
  opacity: .92 !important;
}
.phone-inner{
  border-radius: 48px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background:
    radial-gradient(680px 520px at 45% 12%, rgba(185,139,255,.10), transparent 58%),
    radial-gradient(680px 520px at 70% 30%, rgba(122,180,255,.10), transparent 58%),
    linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.46)) !important;
  box-shadow:
    0 18px 70px rgba(0,0,0,.56),
    inset 0 0 0 1px rgba(0,0,0,.62),
    inset 0 1px 0 rgba(255,255,255,.07) !important;
}
.phone-inner::before{
  inset: 10px !important;
  border-radius: 40px !important;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.08),
    inset 0 20px 55px rgba(0,0,0,.36) !important;
}
.phone-inner::after{
  top: 8px !important;
  width: 150px !important;
  height: 30px !important;
  background:
    radial-gradient(circle at 80% 50%, rgba(255,255,255,.14) 0 2px, transparent 3px),
    linear-gradient(180deg, rgba(0,0,0,.60), rgba(0,0,0,.30)) !important;
  border: 1px solid rgba(255,255,255,.10) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.10),
    0 6px 16px rgba(0,0,0,.22) !important;
  opacity: .92 !important;
}


/* === Option B: Experience tab structure tightening (Customer signals) === */
.sig-wrap{display:flex;flex-direction:column;gap:10px}
.sig-intro{padding:8px 10px;border:1px dashed var(--stroke2);border-radius:14px;color:var(--muted);font-size:12px;letter-spacing:.2px}
.sig-group{display:flex;flex-direction:column;gap:6px}
.sig-head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border:1px solid var(--stroke2);border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02))}
.sig-head .label{font-weight:700;font-size:12px;letter-spacing:.35px;text-transform:uppercase;color:var(--text)}
.sig-head .count{font-size:12px;color:var(--muted)}
.sig-empty{padding:6px 10px;color:var(--muted);font-size:13px}

</style>
<script id="mf-ui-layer-js">
/*
  =========================
  MirrorFlow UI-Layer Seal
  =========================
  UI-only fork rules:
  - Treat the existing engine as a black box.
  - UI reads ONLY from window.MirrorFlowEngineSnapshot.
  - UI writes ONLY via window.MirrorFlowCommands.*

  IMPORTANT:
  This base file does not yet expose Snapshot/Commands.
  To keep engine untouched, we provide *DOM-backed shims* that:
  - Build an immutable snapshot by reading current DOM.
  - Implement commands by dispatching DOM events / clicks.

  When the real engine contract is added later, it can replace these shims
  without breaking this UI layer.
*/
(() => {
  'use strict';

  // ---------- tiny utils (UI-only) ----------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const safeStr = (v) => (v == null) ? '' : String(v);
  const safeNum = (v, d=0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : d;
  };
  const deepFreeze = (obj) => {
    if (!obj || typeof obj !== 'object' || Object.isFrozen(obj)) return obj;
    Object.freeze(obj);
    for (const k of Object.keys(obj)) deepFreeze(obj[k]);
    return obj;
  };

  // ---------- DOM-backed snapshot adapter ----------
  function readSnapshotFromDOM(){
    // Drafts
    const customerText = safeStr($('#customerMsg')?.value);
    const agentDraftText = safeStr($('#agentDraft')?.value);

    // Preview
    const previewState = safeStr($('#previewState')?.textContent).toLowerCase();
    const previewMode = previewState.includes('on');

    // Active editor (best-effort)
    const ae = document.activeElement;
    let activeEditor = 'agent';
    if (ae && ae.id === 'customerMsg') activeEditor = 'customer';
    else if (ae && ae.id === 'agentDraft') activeEditor = 'agent';

    // Metrics
    const metrics = {
      chars: safeNum($('#charCount')?.textContent, 0),
      ukUs: safeNum($('#ukusCount')?.textContent, 0),
      jargon: safeNum($('#jargonCount')?.textContent, 0),
    };

    // Phone messages
    const phoneMsgs = [];
    const list = $('#chatList');
    if (list){
      for (const node of Array.from(list.children)){
        if (!(node instanceof HTMLElement)) continue;
        const roleRaw = safeStr(node.dataset.role).toLowerCase();
        const role = (roleRaw === 'customer' || roleRaw === 'agent') ? roleRaw : 'preview';
        const id = node.dataset.id || `${role}_${phoneMsgs.length}`;
        const pinned = node.classList.contains('pinned') || node.dataset.pinned === 'true';
        const text = safeStr(node.innerText || node.textContent).trim();
        phoneMsgs.push({ id, role, text, pinned: pinned || undefined });
      }
    }

    // Theme
    const mode = ($('#modeLunar')?.dataset.active === 'true') ? 'lunar' : 'sol';
    const skyVariant = safeStr($('#themeLabel')?.textContent).trim() || 'default';
    const animationsOn = (document.body?.getAttribute('data-motion') === 'on');

    // Text size: find active size button if present
    let textSize = 'md';
    const sizeBtn = $$('.textsize button').find(b => b?.dataset?.active === 'true');
    if (sizeBtn){
      const idx = safeNum(sizeBtn.dataset.size, 1);
      textSize = (idx<=0) ? 'sm' : (idx===1) ? 'md' : (idx===2) ? 'lg' : 'lg';
    }

    // Insights are intentionally treated as opaque data; default to zeros.
    const snap = {
      customerText,
      agentDraftText,
      previewMode,
      activeEditor,
      metrics,
      insights: {
        writer: { flags: 0, summary: '' },
        experience: { money: 0, stress: 0, vulnerability: 0 }
      },
      phone: { messages: phoneMsgs },
      theme: {
        mode,
        skyVariant,
        animationsOn,
        textSize,
      }
    };

    return deepFreeze(snap);
  }

  // ---------- DOM-backed command shims (NO engine calls) ----------
  function ensureCommandsShim(){
    if (window.MirrorFlowCommands && typeof window.MirrorFlowCommands === 'object') return;

    const fireInput = (el) => {
      if (!el) return;
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
    };

    const click = (el) => { try{ el?.click?.(); }catch(_){ } };

    window.MirrorFlowCommands = {
      setCustomerText(text){
        const el = $('#customerMsg');
        if (!el) return;
        el.value = safeStr(text);
        fireInput(el);
      },
      setAgentDraftText(text){
        const el = $('#agentDraft');
        if (!el) return;
        el.value = safeStr(text);
        fireInput(el);
      },
      commitCustomerMessage(){ click($('#addCustomerBtn')); },
      commitAgentMessage(){ click($('#sendAgentBtn')); },
      togglePreview(onOff){
        const want = !!onOff;
        const isOn = safeStr($('#previewState')?.textContent).toLowerCase().includes('on');
        if (want !== isOn) click($('#previewToggle'));
      },
      setActiveEditor(which){
        const w = (which === 'customer') ? 'customer' : 'agent';
        const el = (w === 'customer') ? $('#customerMsg') : $('#agentDraft');
        try{ el?.focus?.(); }catch(_){ }
      },
      setThemeMode(mode){
        const m = (mode === 'lunar') ? 'lunar' : 'sol';
        if (m === 'lunar') click($('#modeLunar')); else click($('#modeSol'));
      },
      shuffleSkyVariant(){ click($('#diceBtn')); },
      setAnimations(onOff){
        const want = !!onOff;
        const isOn = (document.body?.getAttribute('data-motion') === 'on');
        if (want !== isOn) click($('#fxBtn'));
      },
      setTextSize(size){
        const map = { xs: 0, sm: 0, md: 1, lg: 2 };
        const idx = (size in map) ? map[size] : 1;
        const btn = $$('.textsize button').find(b => safeNum(b.dataset.size, -1) == idx);
        if (btn) click(btn);
      }
    };
  }

  // ---------- Publish snapshot (immutable) ----------
  function publishSnapshot(){
    try{
      window.MirrorFlowEngineSnapshot = readSnapshotFromDOM();
      return true;
    }catch(e){
      // Never throw.
      try{ window.MirrorFlowEngineSnapshot = deepFreeze({
        customerText:'', agentDraftText:'', previewMode:false, activeEditor:'agent',
        metrics:{chars:0,ukUs:0,jargon:0},
        insights:{writer:{flags:0,summary:''}, experience:{money:0,stress:0,vulnerability:0}},
        phone:{messages:[]},
        theme:{mode:'sol', skyVariant:'default', animationsOn:false, textSize:'md'}
      }); }catch(_){}
      return false;
    }
  }

  // ---------- Minimal status badge (non-interactive) ----------
  let badge;
  function ensureBadge(){
    if (badge) return;
    badge = document.createElement('div');
    badge.className = 'mf-ui-seal-badge';
    badge.innerHTML = '<strong>UI‑Seal</strong> · snapshot ok';
    document.body.appendChild(badge);
  }
  function setBadge(ok){
    if (!badge) return;
    badge.innerHTML = ok ? '<strong>UI‑Seal</strong> · snapshot ok' : '<strong>UI‑Seal</strong> · snapshot fallback';
    badge.style.opacity = ok ? '0.55' : '0.85';
  }

  
  // ---------- UI-only DOM layout helpers ----------
  let __draftToolbarMerged = false;
  
function mergeDraftToolbarsOnce(){
  if (__draftToolbarMerged) return true;
  const draft = document.querySelector('.panel[data-panel="draft"]');
  if (!draft) return false;

  const formatbar = draft.querySelector('.classic-toolbar[role="toolbar"]');
  const insertbar = draft.querySelector('.classic-toolbar.insertbar');
  const dockEl    = draft.querySelector('.dock');
  const dockLeft  = draft.querySelector('.dock-left');
  const utilsBar  = draft.querySelector('.utilities-bar');

  if (!formatbar) return false;

  // --- Move REPLIES / PHRASES into the mini-insights dock (left), before the counters ---
  if (dockLeft && insertbar){
    const replies = insertbar.querySelector('#btnReplies');
    const phrases = insertbar.querySelector('#btnPhrases');
    // Insert phrases first, then replies so order becomes Replies → Phrases
    if (phrases) dockLeft.insertBefore(phrases, dockLeft.firstChild);
    if (replies) dockLeft.insertBefore(replies, dockLeft.firstChild);

    // Compact labels so the whole row fits (no caret, no ALL CAPS)
    if (replies) replies.textContent = 'Replies';
    if (phrases) phrases.textContent = 'Phrases';
  }

  // --- Move CHECKER toggle into Utilities bar ---
  const checker = draft.querySelector('#checkerBtn');
  if (checker && utilsBar){
    const themeLabel = utilsBar.querySelector('#themeLabel');
    const fxBtn = utilsBar.querySelector('#fxBtn');
    // Place it after FX toggle (before the theme label) if possible
    if (themeLabel) utilsBar.insertBefore(checker, themeLabel);
    else if (fxBtn && fxBtn.nextSibling) utilsBar.insertBefore(checker, fxBtn.nextSibling);
    else utilsBar.appendChild(checker);
  }

  // --- Move CLEAN + CLEAR/COPY/PASTE into the start of the format toolbar ---
  const findBtnByText = (root, label) => {
    if (!root) return null;
    const norm = String(label||'').trim().toLowerCase();
    const btns = Array.from(root.querySelectorAll('button,[role="button"]'));
    return btns.find(b => (b.textContent||'').trim().toLowerCase() === norm) || null;
  };

  const clean = insertbar?.querySelector('#btnClean') || draft.querySelector('#btnClean');
  const paste = findBtnByText(dockEl, 'PASTE') || draft.querySelector('#btnPaste');
  const copy  = findBtnByText(dockEl, 'COPY')  || draft.querySelector('#btnCopy');
  const clear = findBtnByText(dockEl, 'CLEAR') || draft.querySelector('#btnClear');

  if (!clean) return false;

  // Prepend in reverse so final order is: Clean → Clear → Copy → Paste → | → formatting…
  const anchor = formatbar.firstChild;
  if (paste) formatbar.insertBefore(paste, anchor);
  if (copy)  formatbar.insertBefore(copy,  paste || anchor);
  if (clear) formatbar.insertBefore(clear, copy  || paste || anchor);
  formatbar.insertBefore(clean, clear || copy || paste || anchor);

  // Insert a visible divider between PASTE and the first formatting tool (B)
  const bold = formatbar.querySelector('#btnBold');
  if (bold && !formatbar.querySelector('.mf-toolbar-divider')){
    const div = document.createElement('span');
    div.className = 'mf-toolbar-divider';
    div.setAttribute('aria-hidden', 'true');
    formatbar.insertBefore(div, bold);
  }

  // Force Bold/Italic (and all formatting tools) onto row 2
  if (bold && !formatbar.querySelector('.mf-toolbar-break')){
    const br = document.createElement('span');
    br.className = 'mf-toolbar-break';
    br.setAttribute('aria-hidden', 'true');
    const divider = formatbar.querySelector('.mf-toolbar-divider');
    if (divider && divider.nextSibling) formatbar.insertBefore(br, divider.nextSibling);
    else formatbar.insertBefore(br, bold);
  }

  // Remove tools we don't want here (keep the toolbar tight)
  for (const id of ['btnHighlight','btnCode','btnRule']){
    const node = formatbar.querySelector('#' + id);
    if (node){
      try{ node.remove(); }catch(_){ node.style.display = 'none'; }
    }
  }


  // Remove any compact icon duplicates for paste/copy/clear in the toolbar,
  // keeping the (moved) pill buttons for consistency.
  const killDup = (label, keepEl) => {
    const norm = String(label||'').toLowerCase();
    const candidates = Array.from(formatbar.querySelectorAll('button,[role="button"]')).filter(el => el !== keepEl);
    for (const el of candidates){
      const t = (el.getAttribute('aria-label')||el.getAttribute('title')||el.textContent||'').trim().toLowerCase();
      const id = (el.id||'').toLowerCase();
      if (id.includes(norm) || t.includes(norm)){
        const txt = (el.textContent||'').trim();
        if (txt.length <= 2){
          try{ el.remove(); }catch(_){ el.style.display='none'; }
        }
      }
    }
  };
  if (paste) killDup('paste', paste);
  if (copy)  killDup('copy',  copy);
  if (clear) killDup('clear', clear);

  // Remove the now-empty insertbar container (UI only).
  if (insertbar){
    try{ insertbar.remove(); }catch(_){ insertbar.style.display='none'; }
  }

  __draftToolbarMerged = true;
  return true;
}

  // Ensure MirrorFlow Editor stack order is stable (avoid brittle nth-of-type CSS).
  
function enforceDraftStackOrder(){
  const draft = document.querySelector('.panel[data-panel="draft"]');
  if (!draft) return false;
  const stack = draft.querySelector('.stack');
  if (!stack) return false;

  const children = Array.from(stack.children);

  const customerBlock = children.find(el => el.tagName === 'DIV' && !el.className && (el.textContent || '').includes('Customer message'));
  const agentBlock    = children.find(el => el.tagName === 'DIV' && !el.className && (el.textContent || '').includes('Agent draft'));

  const formatbar = draft.querySelector('.classic-toolbar[role="toolbar"]');
  const dock      = draft.querySelector('.dock');
  const utils     = draft.querySelector('.utilitiesHub');

  // Desired order:
  // 1) Customer message
  // 2) Writer toolbar
  // 3) Mini-insights dock (with Replies/Phrases + counters)
  // 4) Agent draft
  // 5) Utilities
  if (customerBlock) customerBlock.style.order = '1';
  if (formatbar)     formatbar.style.order     = '2';
  if (dock)          dock.style.order          = '3';
  if (agentBlock)    agentBlock.style.order    = '4';
  if (utils)         utils.style.order         = '5';

  // If insertbar still exists (e.g. merge failed), keep it under the format bar.
  const insertbar = draft.querySelector('.classic-toolbar.insertbar');
  if (insertbar){
    insertbar.style.order = '2';
    const hasButtons = insertbar.querySelector('button, [role="button"]');
    if (!hasButtons) insertbar.style.display = 'none';
  }
  return true;
}


    // Phone shell picker (cycles phone frame styles)
  (function initPhoneShellPicker(){
    const wrap =
      document.querySelector('.phoneWrap') ||
      document.querySelector('.phone-wrap') ||
      document.querySelector('.phoneShell') ||
      document.querySelector('[data-shell]');
    const btn =
      document.getElementById('mfPhoneShellBtn') ||
      document.querySelector('[data-action="cycle-phone-shell"]') ||
      document.querySelector('.mfPhoneShellBtn');
    const lab =
      document.getElementById('mfPhoneShellLabel') ||
      document.querySelector('[data-role="phone-shell-label"]') ||
      document.querySelector('.mfPhoneShellLabel');

    const shells = [
      { id: 'canon',   label: 'Canon' },
      { id: 'compact', label: 'Compact' },
      { id: 'pill',    label: 'Pill' }
    ];

    if (!wrap || !btn) return;

    let saved = null;
    try{ saved = sessionStorage.getItem('mf_phone_shell'); }catch(_){}

    let i = Math.max(0, shells.findIndex(s => s.id === saved));
    if (saved == null || i < 0) i = 0;

    function apply(){
      const s = shells[i] || shells[0];
      wrap.setAttribute('data-shell', s.id);
      if (lab) lab.textContent = s.label;
      try{ sessionStorage.setItem('mf_phone_shell', s.id); }catch(_){}
    }

    btn.addEventListener('click', () => {
      i = (i + 1) % shells.length;
      apply();
    });

    apply();
  })();
;

// ---------- Loop (safe + non-invasive) ----------
  function tick(){
    mergeDraftToolbarsOnce();
    enforceDraftStackOrder();
    const ok = publishSnapshot();
    setBadge(ok);
    // Note: UI layer does NOT render; it only maintains the contract object.
    // Future UI components can subscribe to window.MirrorFlowEngineSnapshot.
    window.requestAnimationFrame(tick);
  }

  // Boot
  ensureCommandsShim();
  // Badge is tiny; remove if you want a totally clean UI.
  try{ /* ui-seal badge disabled */ }catch(_){ }
  publishSnapshot();
  window.requestAnimationFrame(tick);

  // ===== Utilities Modals (UI-only) =====
  // NOTE: In this build, the modal DOM is declared *after* the scripts.
  // So we resolve elements lazily + bind listeners on DOMContentLoaded (and re-resolve on open).
  const modal = {
    overlay: null,
    title: null,
    tabs: null,
    body: null,
    footer: null,
    search: null,
    close: null,
    grab: null,
    active: null,
    q: ""
  };

  const utilBtns = { dict: null, how: null };

  // --- How it works: mini spec + rolling changelog (last 3) ---
  // Update this array each ship. One ship-run = one entry, even if multiple changes landed together.
  // The renderer also supports a local override (localStorage) for quick in-browser notes while testing.
  const MF_CHANGELOG_DEFAULT = [
    {
      date: "2026-02-09",
      title: "PASS2: CX tab routing + UK/US & Jargon scaffolding",
      items: [
        "Fixed CX Insights tab switching so each tab re-renders its own content.",
        "Fixed UK/US pairs loader to use the correct engine key (ukus_pairs_engine) so UK/US counts + findings populate.",
        "UK/US and Jargon now render inside their own tabs with clearer empty-state messaging.",
        "Kept Writer/Experience non-actionable (no insert/rewrite), while UK/US + Jargon remain actionable only in their own tabs."
      ]
    },

  {
    date: "2026-02-09",
    title: "Clear glass tuning + input focus borders",
    items: [
      "Clear glass now increases panel transparency while keeping phone + text inputs solid and readable.",
      "Customer + Agent input boxes now show a solid accent border on focus (matches Insights glow vibe)."
    ]
  },
  {
      date: "2026-02-09",
      title: "D-4B Agent Audit gates + Writer tab clean-up",
      items: [
        "Implemented Agent Audit deterministic gates (Option B) for acknowledgement, next steps, money clarity (2-of-3), clarifier, and support.",
        "Writer tab now stays clean: UK/US + Jargon issue cards render only inside their own tabs (Writer shows counts only).",
        "CX Insights mode buttons now switch panels reliably (Writer / UKUS / Jargon / Experience) with keyboard navigation.",
        "Clear glass mode is now noticeably more transparent (lower tint + near-zero blur).",
        "Restored and wired glass clarity toggle element references (prevents dead toggle state)."
      ]
    },
    {
      date: "2026-02-09",
      title: "Utilities modals + documentation foundation",
      items: [
        "Wired Utilities: “How it works” + “Dictionaries” open the bottom-sheet modal (searchable, draggable).",
        "Added How it works overview + feature map so new users can understand the cockpit fast.",
        "Added rolling changelog (keeps last 3 ship entries) for ongoing iteration."
      ]
    },
    {
      date: "2026-02-08",
      title: "Layout baseline locked + drawer behaviour hardened",
      items: [
        "Locked Classic baseline: staggered corner notches + sweep layers synced to drawer width (hardened).",
        "Writer Insights open requests split layout but keeps Phone Preview visible.",
        "CX pinned drawer remains non-blocking and Coach Mode defaults ON."
      ]
    },
    {
      date: "2026-02-07",
      title: "Lite UI-only fork stabilization",
      items: [
        "Introduced UI-only fork boundary so UI changes don’t touch engine logic.",
        "Improved phone shell + panel spacing to feel lighter and more premium.",
        "Added basic counters/checker guardrails and improved utilities density."
      ]
    }
  ];

  function getChangelog(){
    try{
      const raw = localStorage.getItem("MF_LITE_CHANGELOG_V1");
      if(raw){
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed) && parsed.length) return parsed.slice(0,3);
      }
    }catch(e){}
    return MF_CHANGELOG_DEFAULT.slice(0,3);
  }

  // Optional helper for dev/testing: call window.MF_setChangelog([...]) in the console.
  window.MF_setChangelog = function(entries){
    try{
      if(!Array.isArray(entries)) return;
      localStorage.setItem("MF_LITE_CHANGELOG_V1", JSON.stringify(entries.slice(0,3)));
    }catch(e){}
  };


  function resolveUtilModalEls(){
    modal.overlay = document.getElementById("mfModalOverlay");
    modal.title   = document.getElementById("mfModalTitle");
    modal.tabs    = document.getElementById("mfModalTabs");
    modal.body    = document.getElementById("mfModalBody");
    modal.footer  = document.getElementById("mfModalFooter");
    modal.search  = document.getElementById("mfModalSearch");
    modal.close   = document.getElementById("mfModalClose");
    modal.grab    = document.querySelector("#mfModalOverlay .mf-sheetGrab");

    utilBtns.dict = document.getElementById("dictBtn");
    utilBtns.how  = document.getElementById("howBtn");

    return !!modal.overlay;
  }

  function initUtilModals(){
    resolveUtilModalEls();
    if(!modal.overlay) return;

    if(modal.overlay.dataset.bound === "true") return;
    modal.overlay.dataset.bound = "true";

    utilBtns.dict?.addEventListener("click", ()=> openModal("dict"));
    utilBtns.how ?.addEventListener("click", ()=> openModal("how"));

    modal.close?.addEventListener("click", closeModal);
    // Sheet drag-to-close (Lite premium UX)
    const attachSheetDrag = () => {
      const grab = modal.grab || document.querySelector("#mfModalOverlay .mf-sheetGrab");
      if(!grab) return;
      let startY = 0;
      let curY = 0;
      let dragging = false;

      const onStart = (y) => {
        if(modal.overlay?.dataset.open !== "true") return;
        dragging = true;
        startY = y;
        curY = 0;
        grab.style.cursor = "grabbing";
        modal.overlay.classList.add("mf-sheetDragging");
      };

      const onMove = (y) => {
        if(!dragging) return;
        curY = Math.max(0, y - startY);
        const sheet = modal.overlay.querySelector(".mf-modal");
        if(sheet){
          sheet.style.transition = "none";
          sheet.style.transform = `translate3d(0, ${curY}px, 0)`;
          sheet.style.opacity = String(Math.max(0.35, 1 - (curY/240)));
        }
      };

      const onEnd = () => {
        if(!dragging) return;
        dragging = false;
        grab.style.cursor = "";
        modal.overlay.classList.remove("mf-sheetDragging");
        const sheet = modal.overlay.querySelector(".mf-modal");
        const shouldClose = curY > 90;
        if(shouldClose){
          // reset inline styles after close
          closeModal();
          if(sheet){
            sheet.style.transition = "";
            sheet.style.transform = "";
            sheet.style.opacity = "";
          }
          return;
        }
        // snap back
        if(sheet){
          sheet.style.transition = "";
          sheet.style.transform = "";
          sheet.style.opacity = "";
        }
      };

      // Mouse
      grab.addEventListener("mousedown", (e)=>{ onStart(e.clientY); });
      window.addEventListener("mousemove", (e)=>{ onMove(e.clientY); });
      window.addEventListener("mouseup", onEnd);

      // Touch
      grab.addEventListener("touchstart", (e)=>{ onStart(e.touches[0].clientY); }, {passive:true});
      window.addEventListener("touchmove", (e)=>{ onMove(e.touches[0].clientY); }, {passive:true});
      window.addEventListener("touchend", onEnd);
    };
    attachSheetDrag();


    modal.overlay.addEventListener("click", (e)=>{
      if(e.target === modal.overlay) closeModal();
    });

    document.addEventListener("keydown", (e)=>{
      if(e.key === "Escape" && modal.overlay?.dataset?.open === "true") closeModal();
    });

    modal.search?.addEventListener("input", ()=>{
      modal.q = modal.search.value || "";
      buildModal(modal.active);
    });
  }

  function esc(s){ return (s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }

  function openModal(which){
    if(!modal.overlay) resolveUtilModalEls();
    if(!modal.overlay) return;
    modal.active = which;
    modal.q = "";
    if(modal.search) modal.search.value = "";
    modal.overlay.dataset.open = "true";
    modal.overlay.setAttribute("aria-hidden","false");
    document.documentElement.classList.add("mf-modalOpen");
    buildModal(which);
    // focus
    setTimeout(()=> { try{ modal.search?.focus(); }catch(e){} }, 0);
  }

  function closeModal(){
    if(!modal.overlay) resolveUtilModalEls();
    if(!modal.overlay) return;
    // reset any drag inline transforms
    try{
      const sheet = modal.overlay.querySelector(".mf-modal");
      if(sheet){ sheet.style.transition = ""; sheet.style.transform = ""; sheet.style.opacity = ""; }
    }catch(e){}
    modal.overlay.dataset.open = "false";
    modal.overlay.setAttribute("aria-hidden","true");
    document.documentElement.classList.remove("mf-modalOpen");
    modal.active = null;
  }

  function setTabs(items, activeId){
    if(!modal.tabs) return;
    modal.tabs.innerHTML = items.map(it => {
      const sel = it.id === activeId ? 'aria-selected="true"' : 'aria-selected="false"';
      return `<button class="mf-tab" type="button" data-tab="${esc(it.id)}" ${sel}>${esc(it.label)}</button>`;
    }).join("");
    modal.tabs.querySelectorAll("button[data-tab]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-tab");
        buildModal(modal.active, id);
      });
    });
  }

  function buildModal(which, forcedTab){
    if(!which) return;
    if(which === "dict"){
      buildDictionaries(forcedTab);
    } else if(which === "how"){
      buildHowItWorks(forcedTab);
    }
  }

  function buildDictionaries(tab){
    const tabs = [
      {id:"ukus", label:`UK ↔ US spelling`},
      {id:"jargon", label:`Jargon → plain English`},
      {id:"categories", label:`Categories`},
    ];
    const activeTab = tab || "ukus";
    modal.title.textContent = "Dictionaries & Jargon Encyclopedia";
    setTabs(tabs, activeTab);

    const q = (modal.q || "").trim().toLowerCase();

    const ukusPairs = Array.isArray(ENGINE_BUNDLE?.engine?.ukus_pairs) ? ENGINE_BUNDLE.engine.ukus_pairs : [];
    const jargonRules = Array.isArray(ENGINE_BUNDLE?.engine?.jargon_rules) ? ENGINE_BUNDLE.engine.jargon_rules : [];

    if(activeTab === "ukus"){
      const rows = ukusPairs
        .filter(p => !q || (p.uk||"").toLowerCase().includes(q) || (p.us||"").toLowerCase().includes(q) || (p.type||"").toLowerCase().includes(q))
        .slice(0, 400);
      modal.body.innerHTML = `
        <table class="mf-table" role="table" aria-label="UK/US spelling pairs">
          <thead><tr>
            <th>US form</th><th>UK form (preferred)</th><th>Type</th><th>Notes</th>
          </tr></thead>
          <tbody>
            ${rows.map(p=>`
              <tr>
                <td><b>${esc(p.us)}</b></td>
                <td>${esc(p.uk)}</td>
                <td>${esc(p.type || "")}</td>
                <td>${esc(p.notes || "")}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
      modal.footer.innerHTML = `<span class="mf-chip">Pairs: <b>${rows.length}</b></span> <span class="mf-chip">Tip: search “organise” or “analyze”.</span>`;
      return;
    }

    if(activeTab === "jargon"){
      const rows = jargonRules
        .filter(r => !q || (r.term||"").toLowerCase().includes(q) || (r.suggestion||"").toLowerCase().includes(q) || (r.notes||"").toLowerCase().includes(q))
        .slice(0, 400);
      modal.body.innerHTML = `
        <table class="mf-table" role="table" aria-label="Claims and support jargon">
          <thead><tr>
            <th>Term</th><th>Plain-English meaning</th><th>Preferred phrasing</th><th>Notes</th>
          </tr></thead>
          <tbody>
            ${rows.map(r=>`
              <tr>
                <td><b>${esc(r.term)}</b></td>
                <td>${esc((r.suggestion||"").replace(/\s*\(.+\)\s*$/,""))}</td>
                <td>${esc(r.suggestion || "")}</td>
                <td>${esc(r.notes || "")}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
      modal.footer.innerHTML = `<span class="mf-chip">Rules: <b>${rows.length}</b></span> <span class="mf-chip">Tip: search “FNOL” or “NCD”.</span>`;
      return;
    }

    // categories
    const typeCounts = {};
    ukusPairs.forEach(p=>{
      const t = (p.type || "other").toLowerCase();
      typeCounts[t] = (typeCounts[t]||0)+1;
    });
    const catItems = Object.entries(typeCounts).sort((a,b)=>b[1]-a[1]);
    const jargonCount = jargonRules.length;

    modal.body.innerHTML = `
      <div style="margin-bottom:10px;">
        <span class="mf-chip">UK/US types: <b>${catItems.length}</b></span>
        <span class="mf-chip">Jargon rules: <b>${jargonCount}</b></span>
      </div>

      <table class="mf-table" role="table" aria-label="Dictionary categories">
        <thead><tr><th>Category</th><th>Count</th><th>What it covers</th></tr></thead>
        <tbody>
          ${catItems
            .filter(([k])=> !q || k.includes(q))
            .map(([k,v])=>`
              <tr>
                <td><b>${esc(k)}</b></td>
                <td>${esc(String(v))}</td>
                <td>${esc(categoryHelp(k))}</td>
              </tr>
          `).join("")}
        </tbody>
      </table>
    `;
    modal.footer.innerHTML = `<span class="mf-chip">Tip: categories help explain patterns (e.g. “ise/ize”, “our/or”).</span>`;
  }

  function categoryHelp(key){
    const k = (key||"").toLowerCase();
    if(k.includes("ise")) return "UK -ise vs US -ize variations.";
    if(k.includes("our") || k.includes("or")) return "UK -our vs US -or variations.";
    if(k.includes("double")) return "Double consonant differences (e.g. cancelled/canceled).";
    if(k.includes("re")) return "UK -re vs US -er differences (centre/center).";
    return "General spelling or regional phrasing differences.";
  }

  function buildHowItWorks(tab){
    const tabs = [
      {id:"overview", label:"Overview"},
      {id:"changelog", label:"Changelog"},
      {id:"next", label:"Next steps"},
    ];
    const activeTab = tab || "overview";
    modal.title.textContent = "How MirrorFlow works";
    setTabs(tabs, activeTab);

    if(activeTab === "overview"){
      const features = [
        {k:"MirrorFlow Editor", v:"Draft your reply in the left panel — this is the only place you type."},
        {k:"Phone Truth Layer", v:"Live mirror of the conversation so you can judge tone, spacing, and clarity like the customer sees it."},
        {k:"Insights", v:"Light guidance: UK-first spelling, jargon flags, and quick clarity checks (kept intentionally small in Lite)."},
        {k:"Preview toggle", v:"Turn live preview on/off without losing your draft."},
        {k:"Send shortcut", v:"Ctrl + Enter sends the draft into the phone preview; Shift + Enter adds a new line."},
        {k:"Focus Editor", v:"A notepad-style view that hides distractions and expands the editor when you just need to write."},
        {k:"Focus phone", v:"Zoom into the phone panel for final polish and spacing checks."},
        {k:"Live checks", v:"CHECKER toggles the counters and quick flags on/off (UK-first by default)."},
        {k:"Dictionaries", v:"Search UK/US pairs and claims jargon in plain English — designed for quick lookups mid-draft."},
        {k:"SOL / LUNAR", v:"Switch between daytime and nighttime lighting without changing the layout."},
        {k:"SKY colourways", v:"Pick a colourway swatch or roll the dice for a random Skyglass look."},
        {k:"FX toggle", v:"Turn animations on/off for performance or a calmer drafting session."},
        {k:"Text size", v:"Adjust phone text size to match the customer experience you’re aiming for."},
        {k:"Modal controls", v:"Esc closes popups; you can also click the backdrop or drag the sheet down to close."},
      ];

      modal.body.innerHTML = `
        <div style="max-width:900px; line-height:1.55; color:rgba(255,255,255,.84); font-size:13px;">
          <p style="margin:0 0 10px 0;">
            MirrorFlow Lite is a drafting cockpit built around one habit: <b>see your message the way the customer will see it</b>.
            Write in the Editor, check the Phone Truth Layer, and use the smallest possible set of nudges to stay clear and compliant.
          </p>

          <h3 style="margin:12px 0 8px 0; font-size:13px; letter-spacing:.2px;">Panels</h3>
          <ul style="margin:0; padding-left:18px;">
            <li><b>Editor</b>: your working draft + quick-send.</li>
            <li><b>Phone</b>: customer view of the conversation.</li>
            <li><b>Insights</b>: guidance and checks (kept lightweight in Lite).</li>
          </ul>

          <h3 style="margin:12px 0 8px 0; font-size:13px; letter-spacing:.2px;">Features & toggles (1-liners)</h3>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:6px;">
            ${features.map(f=>`
              <div style="padding:10px 10px; border-radius:12px; background: rgba(255,255,255,.045); border:1px solid rgba(255,255,255,.08);">
                <div style="font-weight:700; font-size:12px; letter-spacing:.2px; opacity:.95;">${esc(f.k)}</div>
                <div style="margin-top:3px; opacity:.85;">${esc(f.v)}</div>
              </div>
            `).join("")}
          </div>

          <div style="margin-top:12px;">
            <span class="mf-chip"><span class="mf-kbd">Ctrl</span> + <span class="mf-kbd">Enter</span> = Send</span>
            <span class="mf-chip"><span class="mf-kbd">Shift</span> + <span class="mf-kbd">Enter</span> = New line</span>
            <span class="mf-chip"><span class="mf-kbd">Esc</span> = Close popups</span>
          </div>
        </div>
      `;
      modal.footer.innerHTML = `Lite rule: guidance stays small — the conversation stays the star.`;
      return;
    }

    if(activeTab === "changelog"){
      const log = getChangelog();
      const q = (modal.q || "").trim().toLowerCase();
      const filtered = !q ? log : log.filter(e =>
        (e.date||"").toLowerCase().includes(q) ||
        (e.title||"").toLowerCase().includes(q) ||
        (Array.isArray(e.items)? e.items.join(" ").toLowerCase().includes(q) : false)
      );

      modal.body.innerHTML = `
        <div style="max-width:900px; line-height:1.55; color:rgba(255,255,255,.84); font-size:13px;">
          <p style="margin:0 0 10px 0; opacity:.9;">
            Last 3 ship entries (update this each run). One run = one entry, even if multiple changes landed together.
          </p>

          ${filtered.map(entry=>`
            <div style="margin:0 0 12px 0; padding:12px 12px; border-radius:14px; background: rgba(255,255,255,.045); border:1px solid rgba(255,255,255,.08);">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:800; letter-spacing:.2px; opacity:.95;">${esc(entry.title || "Update")}</div>
                <span class="mf-chip">${esc(entry.date || "")}</span>
              </div>
              <ul style="margin:8px 0 0 0; padding-left:18px;">
                ${(Array.isArray(entry.items)? entry.items: []).map(it=>`<li style="margin:2px 0;">${esc(it)}</li>`).join("")}
              </ul>
            </div>
          `).join("")}

          ${filtered.length ? "" : `<div style="opacity:.8;">No matching changelog items for “${esc(modal.q)}”.</div>`}

          <div style="margin-top:8px; opacity:.8;">
            Tip: You can temporarily override entries in-browser via <span class="mf-kbd">window.MF_setChangelog([...])</span> (stores to localStorage).
          </div>
        </div>
      `;
      modal.footer.innerHTML = `Changelog is part of the product: small, honest, and always visible.`;
      return;
    }

    // next
    modal.body.innerHTML = `
      <div style="max-width:860px; line-height:1.55; color:rgba(255,255,255,.84); font-size:13px;">
        <h3 style="margin:0 0 8px 0; font-size:13px;">Next steps checklist</h3>
        <ul style="margin:0; padding-left:18px;">
          <li><b>Writer Insights depth</b>: richer tone/clarity suggestions and apply/ignore actions.</li>
          <li><b>Composer blocks</b>: recommended build + undo/redo for block edits.</li>
          <li><b>CX drawer pin/visibility</b>: keep phone preview visible while drafting.</li>
          <li><b>Jargon/UKUS tooltips</b>: on-hover explanations + quick apply replacements.</li>
          <li><b>DevLab tiles</b>: “wired ✅ / safe ✅ / counts ✅” health checks.</li>
        </ul>
        <div style="margin-top:12px;">
          <span class="mf-chip">Rule: UI reads state — UI never owns logic.</span>
        </div>
      </div>
    `;
    modal.footer.innerHTML = `If you want, we can turn this checklist into a ship-by-ship tracker.`;
  }

  // Wire buttons + overlay behaviours
    // Boot utilities modals (after DOM is ready)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initUtilModals, { once: true });
  } else {
    initUtilModals();
  }


})();
</script>
<!-- // UI LAYER END -->
<!-- UTIL MODALS (UI-only, engine-agnostic) -->
<div aria-hidden="true" class="mf-modalOverlay" id="mfModalOverlay">
<div aria-labelledby="mfModalTitle" aria-modal="true" class="mf-modal" role="dialog">
<div aria-hidden="true" class="mf-sheetGrab"></div>
<div class="mf-modalHeader">
<div class="mf-modalTitle" id="mfModalTitle">Modal</div>
<div class="mf-modalHeaderRight">
<input aria-label="Search within modal" class="mf-modalSearch" id="mfModalSearch" placeholder="Search…" type="search"/>
<button aria-label="Close" class="iconbtn mf-modalClose" id="mfModalClose" type="button">
          ✕
        </button>
</div>
</div>
<div aria-label="Modal tabs" class="mf-modalTabs" id="mfModalTabs"></div>
<div class="mf-modalBody" id="mfModalBody"></div>
<div class="mf-modalFooter" id="mfModalFooter"></div>
</div>
</div>
<!-- ===== LITE-SAFE POPUPS (CSS :target) =====
     These are intentionally independent of the JS modal system above.
     They guarantee that Utilities always work even if engine scripts fail.
-->
<div aria-hidden="true" class="mf-popup" id="modal-how">
<div aria-labelledby="mfHowTitle" aria-modal="true" class="mf-popupCard" role="dialog">
<div class="mf-popupHeader">
<div class="mf-popupTitle" id="mfHowTitle">How MirrorFlow works</div>
<div class="mf-popupHeaderRight">
<a aria-label="Close" class="mf-popupClose" href="#">×</a>
</div>
</div>
<div class="mf-popupBody">
<div class="mf-howGrid">
<!-- LEFT: feature overview (2/3) -->
<div class="mf-panelCard">
<div class="mini" style="opacity:.94; margin: 0 0 10px;">
            MirrorFlow Lite is a drafting cockpit built around one habit: <b>see the message the way the customer will see it</b>.
          </div>
<h3>Panels</h3>
<ul class="mini" style="opacity:.92; line-height:1.55;">
<li><b>MirrorFlow Editor (left)</b>: write the reply and use quick tools (clean/copy/paste, formatting, replies, phrases).</li>
<li><b>MirrorFlow Viewer (middle)</b>: the Phone Truth Layer — live preview of customer + agent bubbles as they’ll appear on a phone.</li>
<li><b>Insights (right)</b>: fast checks (UK/US, jargon, clarity, tone, experience signals) before you send.</li>
</ul>
<h3 style="margin-top:12px;">Utilities &amp; toggles</h3>
<ul class="mini" style="opacity:.92; line-height:1.55;">
<li><b>How it works</b>: this cheat sheet (features, toggles, shortcuts, ship notes).</li>
<li><b>Dictionaries</b>: full UK/US + jargon reference (mirrors what UK/US + Jargon checks can flag).</li>
<li><b>CHECKER: ON/OFF</b>: turns live badges/counters on or off (draft mode vs focus mode).</li>
<li><b>Colourway dots</b>: swap themes (Sol/Lunar vibe) without touching any logic.</li>
<li><b>Animations</b>: toggles visual FX for performance or focus.</li>
<li><b>Text size (A)</b>: adjusts phone bubble text to sanity-check readability.</li>
</ul>
<h3 style="margin-top:12px;">Shortcuts (Lite)</h3>
<div class="mf-chipRow">
<span class="mf-chipPill"><b>Ctrl + Enter</b> <span style="opacity:.8;">add customer message</span></span>
<span class="mf-chipPill"><b>Ctrl + Enter</b> <span style="opacity:.8;">send agent draft to phone</span></span>
<span class="mf-chipPill"><b>Shift + Enter</b> <span style="opacity:.8;">new line</span></span>
</div>
<div class="mf-miniNote">One sentence per feature is intentional — this is the “get oriented fast” page.</div>
</div>
<!-- RIGHT: changelog (1/3) -->
<div class="mf-panelCard mf-sideSticky">
<h3 style="margin:0 0 8px;">Changelog (last 3)</h3>
<div class="mf-changelog" id="mfLiteChangelogCards">
<!-- CHANGELOG: keep last 3 entries only (update as we ship) -->
<div class="mf-changelogItem">
<div class="mf-changelogTop">
<span><strong>v7</strong> — solid phone + theme glow</span>
<span>2026-02-09</span>
</div>
<ul class="mf-changelogBullets">
<li>Clear/Frosted glass stays on background panels only — phone + text inputs remain fully solid.</li>
<li>Theme-dynamic glow borders added for Clear mode (uses accent colours via --accentRGB / --accent2RGB).</li>
</ul>
</div>
<div class="mf-changelogItem"><div class="mf-changelogTop"><b>v20.2.2</b><span style="opacity:.75;">Utilities polish</span></div><ul class="mf-changelogBullets mini"><li>How it works now uses a 2‑panel layout (features left, changelog right).</li><li>Dictionaries now auto-render from ENGINE_BUNDLE (UK/US pairs + jargon), with tabs + search.</li></ul></div>
<div class="mf-changelogItem"><div class="mf-changelogTop"><b>v20.2.1</b><span style="opacity:.75;">Utilities</span></div><ul class="mf-changelogBullets mini"><li>Hardened popups: How it works + Dictionaries open via CSS (:target), no JS required.</li><li>Expanded feature map + rolling ship notes scaffold.</li></ul></div>
</div>
<div class="mf-miniNote">Rule: multiple fixes in one run = one ship entry (list the changes as bullets).</div>
</div>
</div>
</div>
</div>
</div>
<div aria-hidden="true" class="mf-popup" id="modal-dict">
<div aria-labelledby="mfDictTitle" aria-modal="true" class="mf-popupCard" role="dialog">
<div class="mf-popupHeader">
<div class="mf-popupTitle" id="mfDictTitle">Dictionaries &amp; Jargon</div>
<div class="mf-popupHeaderRight">
<input aria-label="Search dictionaries" class="mf-modalSearch" id="mfDictSearch" placeholder="Search (colour / FNOL / NCD)…" type="search"/>
<a aria-label="Close" class="mf-popupClose" href="#">×</a>
</div>
</div>
<div class="mf-popupBody">
<div class="mini" style="opacity:.9; margin: 0 0 10px;">
        This is the reference library for anything that can be flagged by <b>UK/US</b> or <b>Jargon</b> checks.
      </div>
<div aria-label="Dictionaries tabs" class="mf-dictTabs" role="tablist">
<button aria-selected="true" class="mf-dictTabBtn is-active" data-tab="ukus" role="tab" type="button">UK ↔ US</button>
<button aria-selected="false" class="mf-dictTabBtn" data-tab="jargon" role="tab" type="button">Claims jargon</button>
</div>
<div aria-hidden="true" class="mf-kpiRow" id="mfDictKpis"></div>
<!-- UK/US -->
<section class="mf-dictSection is-active" data-tab="ukus" id="mfDictSectionUkus">
<h3 style="margin: 8px 0 6px;">UK ↔ US spelling pairs</h3>
<table aria-label="UK/US spelling pairs" class="mf-table" role="table">
<thead><tr>
<th>US form</th><th>UK form (preferred)</th><th>Type</th><th>Notes</th>
</tr></thead>
<tbody id="mfDictPairs"></tbody>
</table>
<p class="mini" style="opacity:.72; margin: 10px 0 0;">Tip: search “organise”, “cancelled”, or “programme”.</p>
</section>
<!-- Jargon -->
<section class="mf-dictSection" data-tab="jargon" id="mfDictSectionJargon">
<h3 style="margin: 8px 0 6px;">Claims / support jargon</h3>
<table aria-label="Claims jargon" class="mf-table" role="table">
<thead><tr>
<th>Term</th><th>Plain-English meaning</th><th>Preferred phrasing</th><th>Notes</th>
</tr></thead>
<tbody id="mfDictJargon"></tbody>
</table>
<p class="mini" style="opacity:.72; margin: 10px 0 0;">Rule of thumb: spell it out once, then the acronym is fine.</p>
</section>
</div>
</div>
</div>
<script>
// Lite-safe Dictionaries: render from ENGINE_BUNDLE + search + tabs (no external deps)
(function(){
  const root = document.getElementById('modal-dict');
  if(!root) return;

  const input = document.getElementById('mfDictSearch');
  const kpis = document.getElementById('mfDictKpis');
  const pairsTbody = document.getElementById('mfDictPairs');
  const jargonTbody = document.getElementById('mfDictJargon');
  const tabBtns = Array.from(root.querySelectorAll('.mf-dictTabBtn'));
  const sections = Array.from(root.querySelectorAll('.mf-dictSection'));

  const norm = (s)=> (s||'').toString().toLowerCase();
  const esc = (s)=> (s??'').toString().replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

  function buildRows(){
    const bundle = (window.ENGINE_BUNDLE && window.ENGINE_BUNDLE.engine) ? window.ENGINE_BUNDLE : null;

    // UK/US pairs
    const enginePairs = bundle?.engine?.ukus_pairs_engine || [];
    const legacyPairs = bundle?.legacy_ui_lists?.ukus_pairs_simple || [];
    const allPairs = [...enginePairs, ...legacyPairs]
      .map(p=>({ us: p.us || '', uk: p.uk || '', type: p.type || '', notes: p.notes || '' }))
      .filter(p=>p.us && p.uk);
    // de-dupe (us+uk)
    const seenPU = new Set();
    const pairs = [];
    for(const p of allPairs){
      const key = `${norm(p.us)}|${norm(p.uk)}`;
      if(seenPU.has(key)) continue;
      seenPU.add(key);
      pairs.push(p);
    }
    pairs.sort((a,b)=> norm(a.us).localeCompare(norm(b.us)));

    pairsTbody.innerHTML = pairs.map(p=>(
      `<tr><td><b>${esc(p.us)}</b></td><td>${esc(p.uk)}</td><td>${esc(p.type)}</td><td class="mini" style="opacity:.78;">${esc(p.notes||'')}</td></tr>`
    )).join('') || `<tr><td colspan="4" class="mini" style="opacity:.75; padding:10px;">No UK/US pairs found in this build.</td></tr>`;

    // Jargon
    const rules = bundle?.engine?.jargon_rules || [];
    const legacyJargon = bundle?.legacy_ui_lists?.jargon_dictionary || [];

    // Map rules -> dictionary rows
    const rRows = rules.map(r=>({
      term: r.term || '',
      plain: r.suggestion || '',
      pref: r.suggestion || '',
      notes: r.notes || ''
    })).filter(x=>x.term);

    // Legacy glossary rows
    const lRows = legacyJargon.map(j=>({
      term: j.term || '',
      plain: j.expansion || '',
      pref: j.term ? `${j.term} (spell out once)` : '',
      notes: j.notes || ''
    })).filter(x=>x.term);

    const allJ = [...rRows, ...lRows];
    const seenJ = new Set();
    const jargon = [];
    for(const j of allJ){
      const key = norm(j.term);
      if(!key) continue;
      if(seenJ.has(key)){
        // keep the first, but backfill missing fields
        const ex = jargon.find(x=>norm(x
<!-- ===== Dev Lab (Lite-safe :target popup) ===== -->
<div aria-hidden="true" class="mf-popup" id="modal-dev">
  <div aria-labelledby="mfDevTitle" aria-modal="true" class="mf-popupCard" role="dialog">
    <div class="mf-popupHeader">
      <div class="mf-popupTitle" id="mfDevTitle">Dev Lab — Visibility Manager</div>
      <div class="mf-popupHeaderRight">
        <a aria-label="Close" class="mf-popupClose" href="#">×</a>
      </div>
    </div>
    <div class="mf-popupBody">
      <div class="mini" style="opacity:.92; margin:0 0 10px; line-height:1.5;">
        Manage <b>Hidden cards</b> (issue IDs) and <b>Ignored rules</b> (rule keys) without clearing all storage.
      </div>
      <div class="mf-devGrid" id="mfDevVisibility">
        <!-- Filled by D-4G JS -->
      </div>
      <div class="mini" style="opacity:.78; margin-top: 10px;">
        Note: this only edits the D-4F persistence lists (<span style="font-family:var(--mono)">mf_lite_hidden_issues_v1</span> / <span style="font-family:var(--mono)">mf_lite_ignore_rules_v1</span>).
      </div>
    </div>
  </div>
</div>

.term)===key);
        if(ex){
          ex.plain = ex.plain || j.plain;
          ex.pref = ex.pref || j.pref;
          ex.notes = ex.notes || j.notes;
        }
        continue;
      }
      seenJ.add(key);
      jargon.push(j);
    }
    jargon.sort((a,b)=> norm(a.term).localeCompare(norm(b.term)));

    jargonTbody.innerHTML = jargon.map(j=>(
      `<tr><td><b>${esc(j.term)}</b></td><td>${esc(j.plain)}</td><td>${esc(j.pref)}</td><td class="mini" style="opacity:.78;">${esc(j.notes||'')}</td></tr>`
    )).join('') || `<tr><td colspan="4" class="mini" style="opacity:.75; padding:10px;">No jargon entries found in this build.</td></tr>`;

    if(kpis){
      const ukusCount = pairs.length;
      const jargonCount = jargon.length;
      const src = bundle?.meta?.source ? `source: ${bundle.meta.source}` : 'embedded';
      kpis.innerHTML = [
        `<span class="mf-kpi">UK/US pairs: <b>${ukusCount}</b></span>`,
        `<span class="mf-kpi">Jargon terms: <b>${jargonCount}</b></span>`,
        `<span class="mf-kpi">${esc(src)}</span>`
      ].join('');
    }
  }

  function setTab(name){
    tabBtns.forEach(btn=>{
      const on = btn.getAttribute('data-tab')===name;
      btn.classList.toggle('is-active', on);
      btn.setAttribute('aria-selected', on ? 'true' : 'false');
    });
    sections.forEach(sec=>{
      sec.classList.toggle('is-active', sec.getAttribute('data-tab')===name);
    });
    // reset search filter per tab change
    if(input) input.dispatchEvent(new Event('input'));
  }

  function applySearch(){
    const q = norm(input?.value).trim();
    // only filter visible section
    const active = sections.find(s=>s.classList.contains('is-active'));
    if(!active) return;
    const rows = Array.from(active.querySelectorAll('tbody tr'));
    rows.forEach(r=>{
      const text = norm(r.innerText);
      r.style.display = (!q || text.includes(q)) ? '' : 'none';
    });
  }

  // init
  buildRows();
  tabBtns.forEach(btn=>btn.addEventListener('click', ()=> setTab(btn.getAttribute('data-tab'))));
  if(input) input.addEventListener('input', applySearch);

  // default tab
  setTab('ukus');
})();
</script>
</body>
</html>
